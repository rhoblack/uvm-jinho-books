<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chapter 7: 드라이버 & 모니터 심화 | 팹리스 검증 엔지니어가 되기 위한 UVM 완전정복</title>
  <style>
    /* =============================================
       UVM Book Publisher - Stylesheet
       Generated by Publisher Agent
       ============================================= */

    @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;600;700&display=swap');

    :root {
      --bg: #ffffff;
      --text: #1a1a2e;
      --accent: #10b981;
      --accent-light: #10b98118;
      --code-bg: #1e1e2e;
      --code-text: #cdd6f4;
      --border: #e2e8f0;
      --blockquote-bg: #f0f9ff;
      --blockquote-border: #3b82f6;
      --table-header: #1e293b;
      --table-stripe: #f8fafc;
      --warning-bg: #fef3c7;
      --warning-border: #f59e0b;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: 'Noto Sans KR', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      line-height: 1.85;
      color: var(--text);
      background: var(--bg);
      font-size: 16px;
    }

    /* === Reading Progress Bar === */
    .progress-bar {
      position: fixed;
      top: 0;
      left: 0;
      width: 0%;
      height: 3px;
      background: linear-gradient(90deg, var(--accent), #10b981cc);
      z-index: 9999;
      transition: width 0.1s;
    }

    /* === Cover Header === */
    .cover-header {
      background: linear-gradient(135deg, #10b98108, #10b98115);
      border-bottom: 3px solid var(--accent);
      padding: 32px 24px 24px;
      text-align: center;
      margin-bottom: 0;
    }
    .cover-part {
      display: inline-block;
      background: var(--accent);
      color: white;
      padding: 4px 16px;
      border-radius: 20px;
      font-size: 0.85em;
      font-weight: 600;
      letter-spacing: 0.5px;
      margin-bottom: 12px;
    }
    .cover-chapter-num {
      font-size: 2em;
      font-weight: 300;
      color: var(--accent);
      letter-spacing: 2px;
      opacity: 0.6;
    }

    /* === Main Content === */
    .content {
      max-width: 860px;
      margin: 0 auto;
      padding: 32px 24px 60px;
    }

    /* === TOC === */
    .toc {
      background: #f8fafc;
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 20px 28px;
      margin: 24px 0 32px;
    }
    .toc-title {
      font-size: 1.1em;
      color: var(--accent);
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 2px solid var(--border);
    }
    .toc ul { list-style: none; padding: 0; }
    .toc li { margin: 6px 0; }
    .toc li a {
      color: var(--text);
      text-decoration: none;
      font-weight: 500;
      font-size: 0.95em;
      padding: 4px 8px;
      border-radius: 4px;
      display: inline-block;
      transition: background 0.15s;
    }
    .toc li a:hover {
      background: var(--accent-light);
      color: var(--accent);
    }
    .toc li.toc-sub { padding-left: 24px; }
    .toc li.toc-sub a {
      font-weight: 400;
      font-size: 0.9em;
      color: #475569;
    }

    /* === Headings === */
    h1 {
      font-size: 2em;
      border-bottom: 3px solid var(--accent);
      padding-bottom: 12px;
      margin: 40px 0 20px;
      color: var(--text);
    }
    h1:first-child { margin-top: 0; }
    h2 {
      font-size: 1.5em;
      color: var(--accent);
      margin: 40px 0 16px;
      padding-bottom: 8px;
      border-bottom: 2px solid var(--border);
      scroll-margin-top: 16px;
    }
    h3 {
      font-size: 1.25em;
      margin: 28px 0 12px;
      color: #334155;
      scroll-margin-top: 16px;
    }
    h4 { font-size: 1.05em; margin: 20px 0 8px; color: #475569; }
    p { margin: 12px 0; }
    a { color: var(--accent); text-decoration: none; }
    a:hover { text-decoration: underline; }
    hr { border: none; border-top: 2px solid var(--border); margin: 32px 0; }
    strong { color: #1e293b; }
    img { max-width: 100%; border-radius: 8px; margin: 16px 0; }

    /* === Code Blocks === */
    pre {
      position: relative;
      background: var(--code-bg);
      border-radius: 12px;
      padding: 0;
      margin: 20px 0;
      overflow: hidden;
      box-shadow: 0 4px 16px rgba(0,0,0,0.12), 0 1px 4px rgba(0,0,0,0.08);
      border: 1px solid #313244;
    }
    pre::before {
      content: attr(data-lang);
      display: block;
      background: #313244;
      color: #a6adc8;
      padding: 8px 16px;
      font-size: 0.8em;
      font-family: 'Fira Code','JetBrains Mono',monospace;
      letter-spacing: 0.5px;
      border-bottom: 1px solid #45475a;
    }
    pre code {
      display: block;
      padding: 16px 20px;
      overflow-x: auto;
      font-family: 'Fira Code','JetBrains Mono','Cascadia Code','D2Coding',monospace;
      font-size: 0.88em;
      line-height: 1.75;
      tab-size: 4;
      color: var(--code-text);
    }
    pre code::-webkit-scrollbar { height: 6px; }
    pre code::-webkit-scrollbar-track { background: #1e1e2e; }
    pre code::-webkit-scrollbar-thumb { background: #45475a; border-radius: 3px; }

    code:not(pre code) {
      background: #f1f5f9;
      color: #be185d;
      padding: 2px 7px;
      border-radius: 5px;
      font-family: 'Fira Code','JetBrains Mono','D2Coding',monospace;
      font-size: 0.86em;
      border: 1px solid #e2e8f0;
    }

    /* Highlight.js Catppuccin */
    .hljs { background: transparent; color: #cdd6f4; }
    .hljs-keyword { color: #cba6f7; font-weight: bold; }
    .hljs-type { color: #f9e2af; }
    .hljs-string { color: #a6e3a1; }
    .hljs-number { color: #fab387; }
    .hljs-comment { color: #6c7086; font-style: italic; }
    .hljs-function, .hljs-title { color: #89b4fa; }
    .hljs-built_in { color: #f38ba8; }
    .hljs-variable { color: #cdd6f4; }
    .hljs-attr { color: #89dceb; }
    .hljs-meta { color: #f5c2e7; }
    .hljs-literal { color: #fab387; }

    /* === SVG Diagrams === */
    .svg-diagram {
      margin: 24px 0;
      padding: 20px;
      background: #fafbfc;
      border: 1px solid var(--border);
      border-radius: 12px;
      text-align: center;
      overflow-x: auto;
    }
    .svg-diagram svg { display: inline-block; }

    /* === Blockquotes === */
    blockquote {
      background: var(--blockquote-bg);
      border-left: 4px solid var(--blockquote-border);
      padding: 16px 20px;
      margin: 16px 0;
      border-radius: 0 8px 8px 0;
    }
    blockquote p:first-child { margin-top: 0; }
    blockquote p:last-child { margin-bottom: 0; }
    blockquote:has(strong:first-child) {
      background: var(--warning-bg);
      border-left-color: var(--warning-border);
    }

    /* === Tables === */
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 1px 4px rgba(0,0,0,0.06);
      border: 1px solid var(--border);
      font-size: 0.95em;
    }
    thead th {
      background: var(--table-header);
      color: white;
      padding: 12px 16px;
      text-align: left;
      font-weight: 600;
      font-size: 0.9em;
    }
    tbody td {
      padding: 10px 16px;
      border-bottom: 1px solid var(--border);
    }
    tbody tr:nth-child(even) { background: var(--table-stripe); }
    tbody tr:hover { background: var(--accent-light); }

    /* === Lists === */
    ul, ol { padding-left: 28px; margin: 12px 0; }
    li { margin: 6px 0; }
    li > ul, li > ol { margin: 4px 0; }

    /* === Details/Summary === */
    details {
      background: #f8fafc;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px 16px;
      margin: 12px 0;
    }
    details summary {
      cursor: pointer;
      font-weight: 600;
      color: var(--accent);
    }
    details[open] summary { margin-bottom: 8px; }

    /* === Plain code blocks === */
    pre:has(code:not(.hljs)) {
      background: #fafbfc;
      border: 2px solid var(--border);
      box-shadow: none;
    }
    pre:has(code:not(.hljs))::before {
      background: #f1f5f9;
      color: #64748b;
      border-bottom-color: var(--border);
    }
    pre:has(code:not(.hljs)) code { color: #334155; }

    /* === Chapter Navigation === */
    .chapter-nav {
      display: flex;
      justify-content: space-between;
      gap: 16px;
      margin: 40px 0 20px;
      padding-top: 24px;
      border-top: 2px solid var(--border);
    }
    .chapter-nav a {
      display: flex;
      flex-direction: column;
      padding: 14px 20px;
      border: 1px solid var(--border);
      border-radius: 10px;
      text-decoration: none;
      transition: all 0.2s;
      min-width: 200px;
    }
    .chapter-nav a:hover {
      border-color: var(--accent);
      background: var(--accent-light);
      text-decoration: none;
    }
    .nav-prev { align-items: flex-start; }
    .nav-next { align-items: flex-end; }
    .nav-label {
      font-size: 0.8em;
      color: #94a3b8;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .nav-title { font-weight: 600; color: var(--accent); margin-top: 2px; }

    /* === Footer === */
    .book-footer {
      text-align: center;
      padding: 20px;
      margin-top: 40px;
      border-top: 1px solid var(--border);
      color: #94a3b8;
      font-size: 0.85em;
    }

    /* === Back to Top === */
    .back-to-top {
      position: fixed;
      bottom: 24px;
      right: 24px;
      width: 44px;
      height: 44px;
      background: var(--accent);
      color: white;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      font-size: 20px;
      display: none;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      transition: opacity 0.3s;
      z-index: 100;
    }
    .back-to-top.visible { display: flex; }

    /* === Print === */
    @media print {
      .progress-bar, .back-to-top, .chapter-nav, .toc { display: none !important; }
      body { font-size: 11pt; }
      .content { max-width: 100%; padding: 0; }
      .cover-header { break-after: page; }
      pre { box-shadow: none; border: 2px solid #ccc; break-inside: avoid; }
      .svg-diagram { break-inside: avoid; border: 1px solid #ccc; }
      table { break-inside: avoid; }
      h2, h3 { break-after: avoid; }
    }

    /* === Responsive === */
    @media (max-width: 640px) {
      .content { padding: 16px 12px 40px; font-size: 15px; }
      h1 { font-size: 1.5em; }
      h2 { font-size: 1.25em; }
      pre code { font-size: 0.8em; padding: 12px; }
      thead th, tbody td { padding: 8px 10px; font-size: 0.88em; }
      .svg-diagram { padding: 10px; }
      .toc { padding: 14px 18px; }
      .chapter-nav { flex-direction: column; }
      .chapter-nav a { min-width: unset; }
      .nav-next { align-items: flex-start; }
      .cover-chapter-num { font-size: 1.5em; }
    }
  </style>
</head>
<body>
  <!-- Reading Progress Bar -->
  <div class="progress-bar" id="progressBar"></div>

  
<header class="cover-header">
  <div class="cover-part" style="--part-color: #10b981">
    <span class="cover-part-label">Part 2: 깊이 파기</span>
  </div>
  <div class="cover-chapter-num">Chapter 07</div>
</header>

  <div class="content">
    <nav class="toc">
<h2 class="toc-title">목차</h2>
<ul>
<li><a href="#7-1-tlm-포트-이해">7.1 TLM 포트 이해</a></li>
  <li class="toc-sub"><a href="#7-1-1-tlm이란">7.1.1 TLM이란?</a></li>
  <li class="toc-sub"><a href="#7-1-2-sequencer-driver-tlm-연결">7.1.2 Sequencer-Driver TLM 연결</a></li>
  <li class="toc-sub"><a href="#7-1-3-analysis-port-1-n-브로드캐스트">7.1.3 Analysis Port — 1:N 브로드캐스트</a></li>
  <li class="toc-sub"><a href="#7-1-4-analysis-port-사용법">7.1.4 Analysis Port 사용법</a></li>
<li><a href="#7-2-clocking-block-amp-modport">7.2 Clocking Block &amp; Modport</a></li>
  <li class="toc-sub"><a href="#7-2-2-해결-clocking-block">7.2.2 해결: Clocking Block</a></li>
  <li class="toc-sub"><a href="#7-2-3-modport-접근-권한-제어">7.2.3 Modport — 접근 권한 제어</a></li>
  <li class="toc-sub"><a href="#7-2-4-clocking-block-적용">7.2.4 Clocking Block 적용</a></li>
<li><a href="#7-3-드라이버-심화">7.3 드라이버 심화</a></li>
  <li class="toc-sub"><a href="#7-3-1-드라이버의-역할-재정의">7.3.1 드라이버의 역할 재정의</a></li>
  <li class="toc-sub"><a href="#7-3-2-get-next-item-vs-try-next-item">7.3.2 get_next_item vs try_next_item</a></li>
  <li class="toc-sub"><a href="#7-3-3-프로토콜-구동-패턴">7.3.3 프로토콜 구동 패턴</a></li>
  <li class="toc-sub"><a href="#7-3-4-response-처리-간단-소개">7.3.4 Response 처리 (간단 소개)</a></li>
<li><a href="#7-4-모니터-심화">7.4 모니터 심화</a></li>
  <li class="toc-sub"><a href="#7-4-1-모니터의-역할">7.4.1 모니터의 역할</a></li>
  <li class="toc-sub"><a href="#7-4-2-실무-수준-모니터">7.4.2 실무 수준 모니터</a></li>
  <li class="toc-sub"><a href="#7-4-3-모니터-설계-규칙">7.4.3 모니터 설계 규칙</a></li>
<li><a href="#7-5-agent-구성-is-active">7.5 Agent 구성 — is_active</a></li>
  <li class="toc-sub"><a href="#7-5-1-능동-에이전트-vs-수동-에이전트">7.5.1 능동 에이전트 vs 수동 에이전트</a></li>
  <li class="toc-sub"><a href="#7-5-2-is-active-구현">7.5.2 is_active 구현</a></li>
  <li class="toc-sub"><a href="#7-5-3-수동-에이전트-활용-예시">7.5.3 수동 에이전트 활용 예시</a></li>
<li><a href="#7-6-종합-실무-수준-테스트벤치">7.6 종합: 실무 수준 테스트벤치</a></li>
  <li class="toc-sub"><a href="#7-6-1-ch-5-6-대비-진화-정리">7.6.1 Ch.5/6 대비 진화 정리</a></li>
<li><a href="#7-7-체크포인트">7.7 체크포인트</a></li>
  <li class="toc-sub"><a href="#셀프-체크">셀프 체크</a></li>
  <li class="toc-sub"><a href="#연습문제">연습문제</a></li>
  <li class="toc-sub"><a href="#흔한-에러와-해결">흔한 에러와 해결</a></li>
  <li class="toc-sub"><a href="#용어-정리">용어 정리</a></li>
  <li class="toc-sub"><a href="#다음-챕터-예고">다음 챕터 예고</a></li>
</ul>
</nav>
    <h1>Chapter 7: 드라이버 &amp; 모니터 심화</h1>
<blockquote>
<p><strong>학습 목표</strong></p>
<ul>
<li>TLM 포트(<code>seq_item_port</code>, <code>analysis_port</code>)의 역할과 연결 방법을 이해한다</li>
<li>Clocking block과 modport로 타이밍 안정성을 확보할 수 있다</li>
<li>실무 수준의 드라이버를 작성할 수 있다</li>
<li>모니터에서 analysis port로 트랜잭션을 브로드캐스트할 수 있다</li>
<li>Agent의 <code>is_active</code> 플래그로 능동/수동 에이전트를 구성할 수 있다</li>
</ul>
</blockquote>
<blockquote>
<p><strong>선수 지식</strong>: Chapter 5의 virtual interface, driver/monitor 기초, Chapter 6의 sequence/sequencer, <code>get_next_item()</code>/<code>item_done()</code> 패턴이 핵심 기반입니다.</p>
</blockquote>
<hr>
<h2 id="7-1-tlm-포트-이해">7.1 TLM 포트 이해</h2>
<blockquote>
<p><strong>이 절의 목표</strong>: Chapter 6에서 &quot;마법처럼&quot; 연결한 <code>seq_item_port</code>와 <code>seq_item_export</code>의 내부 동작을 이해하고, analysis port의 개념을 배웁니다.</p>
</blockquote>
<h3 id="7-1-1-tlm이란">7.1.1 TLM이란?</h3>
<p>Chapter 6에서 이 코드를 기억하시나요?</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// agent의 connect_phase (Chapter 6)</span>
drv<span class="hljs-variable">.seq_item_port</span><span class="hljs-variable">.connect</span>(sqr<span class="hljs-variable">.seq_item_export</span>);
</code></pre><p>이 한 줄로 시퀀서와 드라이버가 연결되었습니다. 이 연결을 가능하게 하는 것이 <strong>TLM(Transaction Level Modeling)</strong> 포트입니다.</p>
<p>TLM은 <strong>컴포넌트 간에 트랜잭션 객체를 주고받는 표준 인터페이스</strong>입니다. 직접 함수를 호출하는 대신, 포트를 통해 간접적으로 통신합니다.</p>
<blockquote>
<p><strong>비유</strong>: TLM 포트 = <strong>우체통 시스템</strong></p>
<ul>
<li><strong>Port</strong> (포트) = 우편함 투입구 — 데이터를 <strong>보내는</strong> 쪽</li>
<li><strong>Export</strong> (익스포트) = 우편함 — 데이터를 <strong>받는</strong> 쪽</li>
<li><strong><code>connect()</code></strong> = 투입구와 우편함을 연결</li>
<li>보내는 쪽은 받는 쪽이 누구인지 몰라도 됩니다 — <strong>느슨한 결합(loose coupling)</strong></li>
</ul>
</blockquote>
<h3 id="7-1-2-sequencer-driver-tlm-연결">7.1.2 Sequencer-Driver TLM 연결</h3>
<p><code>uvm_driver</code> 기본 클래스에는 <code>seq_item_port</code>가 이미 선언되어 있고, <code>uvm_sequencer</code>에는 <code>seq_item_export</code>가 있습니다:</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// uvm_driver 내부 (이미 선언됨 — 사용자가 만들 필요 없음)</span>
<span class="hljs-keyword">class</span> uvm_driver <span class="hljs-variable">#(type REQ=uvm_sequence_item)</span> <span class="hljs-keyword">extends</span> uvm_component;
  uvm_seq_item_pull_port <span class="hljs-variable">#(REQ)</span> seq_item_port;  <span class="hljs-comment">// ← 이미 있음!</span>
  ...
<span class="hljs-keyword">endclass</span>

<span class="hljs-comment">// uvm_sequencer 내부 (이미 선언됨)</span>
<span class="hljs-keyword">class</span> uvm_sequencer <span class="hljs-variable">#(type REQ=uvm_sequence_item)</span> <span class="hljs-keyword">extends</span> uvm_component;
  uvm_seq_item_pull_imp <span class="hljs-variable">#(REQ, ...)</span> seq_item_export;  <span class="hljs-comment">// ← 이미 있음!</span>
  ...
<span class="hljs-keyword">endclass</span>
</code></pre>
<div class="svg-diagram">
<svg viewBox="0 0 700 220" xmlns="http://www.w3.org/2000/svg" style="max-width:700px;width:100%">
  
  <style>
    .diagram-box { fill: #ffffff; stroke: #334155; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-accent { fill: #eff6ff; stroke: #2563eb; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-highlight { fill: #fef3c7; stroke: #f59e0b; stroke-width: 2.5; rx: 10; ry: 10; }
    .diagram-box-dark { fill: #1e293b; stroke: #1e293b; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-run { fill: #fef3c7; stroke: #f59e0b; stroke-width: 3; rx: 10; ry: 10; }
    .diagram-box-green { fill: #ecfdf5; stroke: #10b981; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-purple { fill: #f5f3ff; stroke: #7c3aed; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-red { fill: #fef2f2; stroke: #ef4444; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-gray { fill: #f8fafc; stroke: #94a3b8; stroke-width: 1.5; rx: 8; ry: 8; }
    .diagram-text { font-family: 'Noto Sans KR', sans-serif; fill: #1e293b; }
    .diagram-text-white { font-family: 'Noto Sans KR', sans-serif; fill: #ffffff; }
    .diagram-text-accent { font-family: 'Noto Sans KR', sans-serif; fill: #2563eb; }
    .diagram-text-small { font-family: 'Noto Sans KR', sans-serif; fill: #64748b; font-size: 12px; }
    .diagram-text-code { font-family: 'Fira Code', 'JetBrains Mono', monospace; fill: #1e293b; }
    .diagram-arrow { fill: none; stroke: #64748b; stroke-width: 1.5; }
    .diagram-arrow-accent { fill: none; stroke: #2563eb; stroke-width: 1.5; }
    .diagram-line { stroke: #cbd5e1; stroke-width: 1.5; stroke-dasharray: 6,3; }
  </style>
  <defs>
    <marker id="arrowhead" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#64748b" />
    </marker>
    <marker id="arrowhead-accent" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#2563eb" />
    </marker>
    <marker id="arrowhead-dark" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#1e293b" />
    </marker>
    <marker id="arrowhead-orange" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#f59e0b" />
    </marker>
    <filter id="shadow" x="-5%" y="-5%" width="115%" height="115%">
      <feDropShadow dx="0" dy="2" stdDeviation="3" flood-color="#000" flood-opacity="0.1"/>
    </filter>
  </defs>

  <!-- Title -->
  <text x="350" y="28" text-anchor="middle" class="diagram-text" font-size="15" font-weight="bold">Sequencer-Driver TLM 연결</text>

  <!-- Sequencer box -->
  <rect x="60" y="48" width="240" height="100" class="diagram-box-green" filter="url(#shadow)"/>
  <text x="180" y="74" text-anchor="middle" class="diagram-text" font-size="14" font-weight="bold">Sequencer</text>
  <text x="180" y="100" text-anchor="middle" class="diagram-text-code" font-size="12">seq_item_export</text>
  <text x="180" y="124" text-anchor="middle" class="diagram-text-small" font-size="11">(데이터 제공)</text>

  <!-- Driver box -->
  <rect x="400" y="48" width="240" height="100" class="diagram-box-highlight" filter="url(#shadow)"/>
  <text x="520" y="74" text-anchor="middle" class="diagram-text" font-size="14" font-weight="bold">Driver</text>
  <text x="520" y="100" text-anchor="middle" class="diagram-text-code" font-size="12">seq_item_port</text>
  <text x="520" y="124" text-anchor="middle" class="diagram-text-small" font-size="11">(데이터 요청)</text>

  <!-- Arrow Driver → Sequencer -->
  <line x1="400" y1="98" x2="305" y2="98" class="diagram-arrow-accent" marker-end="url(#arrowhead-accent)" stroke-width="1.5"/>
  <text x="352" y="88" text-anchor="middle" class="diagram-text-accent" font-size="12" font-weight="bold">connect</text>

  <!-- connect code -->
  <rect x="110" y="170" width="480" height="34" rx="6" ry="6" fill="#f0fdf4" stroke="#10b981" stroke-width="1.5"/>
  <text x="350" y="192" text-anchor="middle" class="diagram-text-code" font-size="11">drv.seq_item_port.connect(sqr.seq_item_export)</text>
</svg>
</div><p><strong>핵심 포인트</strong>: 포트와 익스포트는 UVM 기본 클래스에 이미 선언되어 있으므로, 사용자는 <code>connect_phase</code>에서 <strong>연결만</strong> 하면 됩니다. 만들 필요 없이 연결만!</p>
<h3 id="7-1-3-analysis-port-1-n-브로드캐스트">7.1.3 Analysis Port — 1:N 브로드캐스트</h3>
<p>시퀀서→드라이버 연결은 <strong>1:1</strong> 통신입니다. 하지만 모니터는 관찰한 데이터를 <strong>여러 곳</strong>에 동시에 보내야 합니다:</p>
<ul>
<li>스코어보드에게 → 결과 검증용</li>
<li>커버리지 수집기에게 → 기능 커버리지 측정용</li>
<li>로거에게 → 디버깅용</li>
</ul>
<p>이런 <strong>1:N 브로드캐스트</strong>를 위해 <code>uvm_analysis_port</code>를 사용합니다:</p>

<div class="svg-diagram">
<svg viewBox="0 0 700 260" xmlns="http://www.w3.org/2000/svg" style="max-width:700px;width:100%">
  
  <style>
    .diagram-box { fill: #ffffff; stroke: #334155; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-accent { fill: #eff6ff; stroke: #2563eb; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-highlight { fill: #fef3c7; stroke: #f59e0b; stroke-width: 2.5; rx: 10; ry: 10; }
    .diagram-box-dark { fill: #1e293b; stroke: #1e293b; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-run { fill: #fef3c7; stroke: #f59e0b; stroke-width: 3; rx: 10; ry: 10; }
    .diagram-box-green { fill: #ecfdf5; stroke: #10b981; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-purple { fill: #f5f3ff; stroke: #7c3aed; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-red { fill: #fef2f2; stroke: #ef4444; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-gray { fill: #f8fafc; stroke: #94a3b8; stroke-width: 1.5; rx: 8; ry: 8; }
    .diagram-text { font-family: 'Noto Sans KR', sans-serif; fill: #1e293b; }
    .diagram-text-white { font-family: 'Noto Sans KR', sans-serif; fill: #ffffff; }
    .diagram-text-accent { font-family: 'Noto Sans KR', sans-serif; fill: #2563eb; }
    .diagram-text-small { font-family: 'Noto Sans KR', sans-serif; fill: #64748b; font-size: 12px; }
    .diagram-text-code { font-family: 'Fira Code', 'JetBrains Mono', monospace; fill: #1e293b; }
    .diagram-arrow { fill: none; stroke: #64748b; stroke-width: 1.5; }
    .diagram-arrow-accent { fill: none; stroke: #2563eb; stroke-width: 1.5; }
    .diagram-line { stroke: #cbd5e1; stroke-width: 1.5; stroke-dasharray: 6,3; }
  </style>
  <defs>
    <marker id="arrowhead" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#64748b" />
    </marker>
    <marker id="arrowhead-accent" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#2563eb" />
    </marker>
    <marker id="arrowhead-dark" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#1e293b" />
    </marker>
    <marker id="arrowhead-orange" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#f59e0b" />
    </marker>
    <filter id="shadow" x="-5%" y="-5%" width="115%" height="115%">
      <feDropShadow dx="0" dy="2" stdDeviation="3" flood-color="#000" flood-opacity="0.1"/>
    </filter>
  </defs>

  <!-- Title -->
  <text x="350" y="28" text-anchor="middle" class="diagram-text" font-size="15" font-weight="bold">Analysis Port — 1:N 브로드캐스트</text>

  <!-- Monitor box -->
  <rect x="40" y="80" width="180" height="100" class="diagram-box-accent" filter="url(#shadow)"/>
  <text x="130" y="110" text-anchor="middle" class="diagram-text" font-size="14" font-weight="bold">Monitor</text>
  <text x="130" y="135" text-anchor="middle" class="diagram-text-code" font-size="12">analysis_port</text>
  <text x="130" y="158" text-anchor="middle" class="diagram-text-accent" font-size="12" font-weight="bold">write(item)</text>

  <!-- Arrow to Scoreboard -->
  <line x1="220" y1="100" x2="380" y2="65" class="diagram-arrow" marker-end="url(#arrowhead-dark)" stroke-width="1.5"/>
  <!-- Arrow to Coverage -->
  <line x1="220" y1="130" x2="380" y2="130" class="diagram-arrow" marker-end="url(#arrowhead-dark)" stroke-width="1.5"/>
  <!-- Arrow to Logger -->
  <line x1="220" y1="160" x2="380" y2="195" class="diagram-arrow" marker-end="url(#arrowhead-dark)" stroke-width="1.5"/>

  <!-- Scoreboard -->
  <rect x="385" y="42" width="250" height="46" class="diagram-box-highlight" filter="url(#shadow)"/>
  <text x="510" y="62" text-anchor="middle" class="diagram-text" font-size="13" font-weight="bold">Scoreboard</text>
  <text x="510" y="80" text-anchor="middle" class="diagram-text-small" font-size="11">(검증)</text>

  <!-- Coverage -->
  <rect x="385" y="107" width="250" height="46" class="diagram-box-green" filter="url(#shadow)"/>
  <text x="510" y="127" text-anchor="middle" class="diagram-text" font-size="13" font-weight="bold">Coverage</text>
  <text x="510" y="145" text-anchor="middle" class="diagram-text-small" font-size="11">(커버리지)</text>

  <!-- Logger -->
  <rect x="385" y="172" width="250" height="46" class="diagram-box-gray" filter="url(#shadow)"/>
  <text x="510" y="192" text-anchor="middle" class="diagram-text" font-size="13" font-weight="bold">Logger</text>
  <text x="510" y="210" text-anchor="middle" class="diagram-text-small" font-size="11">(로깅)</text>
</svg>
</div><table>
<thead>
<tr>
<th>비교</th>
<th>seq_item_port (1:1)</th>
<th>analysis_port (1:N)</th>
</tr>
</thead>
<tbody><tr>
<td>방향</td>
<td>드라이버가 시퀀서에게 <strong>요청</strong></td>
<td>모니터가 구독자에게 <strong>전송</strong></td>
</tr>
<tr>
<td>연결 수</td>
<td>1개만</td>
<td>여러 개 가능</td>
</tr>
<tr>
<td>메서드</td>
<td><code>get_next_item()</code> / <code>item_done()</code></td>
<td><code>write()</code></td>
</tr>
<tr>
<td>용도</td>
<td>시퀀스 실행</td>
<td>관찰 데이터 브로드캐스트</td>
</tr>
</tbody></table>
<h3 id="7-1-4-analysis-port-사용법">7.1.4 Analysis Port 사용법</h3>
<p><strong>보내는 쪽 (모니터)</strong>:</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-keyword">class</span> counter_monitor <span class="hljs-keyword">extends</span> uvm_monitor;
  <span class="hljs-comment">// ⭐ analysis port 선언</span>
  uvm_analysis_port <span class="hljs-variable">#(counter_seq_item)</span> ap;

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);
    ap = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;ap&quot;</span>, <span class="hljs-keyword">this</span>);  <span class="hljs-comment">// ⭐ 포트 생성</span>
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> run_phase(uvm_phase phase);
    <span class="hljs-keyword">forever</span> <span class="hljs-keyword">begin</span>
      counter_seq_item item = counter_seq_item::type_id::create(<span class="hljs-string">&quot;item&quot;</span>);
      <span class="hljs-comment">// ... 신호 관찰 후 item에 기록 ...</span>
      ap<span class="hljs-variable">.write</span>(item);  <span class="hljs-comment">// ⭐ 브로드캐스트!</span>
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>
</code></pre><p><strong>받는 쪽 (스코어보드)</strong> — Chapter 8에서 자세히 다루지만 구조를 미리 봅니다:</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-keyword">class</span> counter_scoreboard <span class="hljs-keyword">extends</span> uvm_scoreboard;
  <span class="hljs-comment">// ⭐ analysis implementation 선언</span>
  uvm_analysis_imp <span class="hljs-variable">#(counter_seq_item, counter_scoreboard)</span> ap_imp;

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);
    ap_imp = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;ap_imp&quot;</span>, <span class="hljs-keyword">this</span>);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-comment">// ⭐ write() 메서드 구현 — 모니터가 write() 호출하면 자동 실행</span>
  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> write(counter_seq_item item);
    `uvm_info(get_type_name(),
      <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;Received: %s&quot;</span>, item<span class="hljs-variable">.convert2string</span>()), UVM_HIGH)
    <span class="hljs-comment">// 검증 로직 (Ch.8에서 구현)</span>
  <span class="hljs-keyword">endfunction</span>
<span class="hljs-keyword">endclass</span>
</code></pre><p><strong>연결 (env의 connect_phase)</strong>:</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// env의 connect_phase</span>
<span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> connect_phase(uvm_phase phase);
  <span class="hljs-keyword">super</span><span class="hljs-variable">.connect_phase</span>(phase);
  agent<span class="hljs-variable">.mon</span><span class="hljs-variable">.ap</span><span class="hljs-variable">.connect</span>(scoreboard<span class="hljs-variable">.ap_imp</span>);  <span class="hljs-comment">// 모니터 → 스코어보드</span>
<span class="hljs-keyword">endfunction</span>
</code></pre><blockquote>
<p><strong>흐름 정리</strong>: 모니터가 <code>ap.write(item)</code>을 호출하면 → 연결된 모든 <code>uvm_analysis_imp</code>의 <code>write()</code> 메서드가 <strong>자동으로</strong> 호출됩니다. 사용자는 받는 쪽 클래스에 <code>write()</code> 함수를 구현하기만 하면 됩니다. UVM은 이 패턴을 더 간단하게 만든 <code>uvm_subscriber</code> 클래스도 제공합니다 — <code>analysis_export</code>가 내장되어 있어 <code>write()</code>만 구현하면 됩니다.</p>
</blockquote>
<blockquote>
<p><strong>면접 포인트</strong>: &quot;analysis port와 일반 TLM port의 차이는?&quot; — analysis port는 <strong>비블로킹(non-blocking)</strong> <code>write()</code> 메서드로 1:N 브로드캐스트하며, 연결이 없어도 에러가 아닙니다(0:N). 일반 TLM port는 1:1 연결이 필수입니다.</p>
</blockquote>
<hr>
<h2 id="7-2-clocking-block-amp-modport">7.2 Clocking Block &amp; Modport</h2>
<blockquote>
<p><strong>이 절의 목표</strong>: Chapter 5에서 사용한 <code>#1</code> 타이밍 해킹을 clocking block으로 개선하고, modport로 접근 권한을 제어합니다.</p>
</blockquote>
<h3>7.2.1 <code>#1</code> 해킹의 문제</h3>
<p>Chapter 5/6에서 모니터는 이렇게 작성했습니다:</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// Chapter 5/6 방식: #1 해킹</span>
<span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> run_phase(uvm_phase phase);
  <span class="hljs-keyword">forever</span> <span class="hljs-keyword">begin</span>
    @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>);
    #<span class="hljs-number">1</span>;  <span class="hljs-comment">// ← 이것! 왜 1ns를 기다릴까?</span>
    <span class="hljs-comment">// 신호 샘플링...</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endtask</span>
</code></pre><p><code>#1</code>은 클럭 에지 직후 <strong>1 타임 단위</strong>를 기다려서 신호가 안정화된 후 샘플링합니다. 동작은 하지만 문제가 있습니다:</p>
<table>
<thead>
<tr>
<th>문제</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>타임스케일 의존</td>
<td><code>1ns</code>인지 <code>1ps</code>인지에 따라 동작이 달라질 수 있음</td>
</tr>
<tr>
<td>표준이 아님</td>
<td>IEEE 1800에 정의된 방법이 아님</td>
</tr>
<tr>
<td>경쟁 조건(race)</td>
<td>복잡한 설계에서 <code>#1</code>이 충분하지 않을 수 있음</td>
</tr>
<tr>
<td>코드 리뷰</td>
<td>실무에서 <code>#1</code> 사용은 지적 사항</td>
</tr>
</tbody></table>
<h3 id="7-2-2-해결-clocking-block">7.2.2 해결: Clocking Block</h3>
<p><strong>Clocking block</strong>은 신호의 샘플링/구동 타이밍을 <strong>클럭 기준으로 명시적으로 정의</strong>하는 SystemVerilog 구문입니다:</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// 개선된 interface — clocking block과 modport 추가</span>
<span class="hljs-keyword">interface</span> counter_if(<span class="hljs-keyword">input</span> <span class="hljs-keyword">logic</span> clk);
  <span class="hljs-keyword">logic</span>       rst_n;
  <span class="hljs-keyword">logic</span>       enable;
  <span class="hljs-keyword">logic</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] count;

  <span class="hljs-comment">// ⭐ 드라이버용 clocking block</span>
  <span class="hljs-keyword">clocking</span> drv_cb @(<span class="hljs-keyword">posedge</span> clk);
    <span class="hljs-keyword">default</span> <span class="hljs-keyword">input</span> #<span class="hljs-number">1</span>step <span class="hljs-keyword">output</span> #<span class="hljs-number">0</span>;   <span class="hljs-comment">// 입력: 이전 타임슬롯, 출력: 즉시</span>
    <span class="hljs-keyword">output</span> rst_n;                     <span class="hljs-comment">// 드라이버가 구동하는 신호</span>
    <span class="hljs-keyword">output</span> enable;
  <span class="hljs-keyword">endclocking</span>

  <span class="hljs-comment">// ⭐ 모니터용 clocking block</span>
  <span class="hljs-keyword">clocking</span> mon_cb @(<span class="hljs-keyword">posedge</span> clk);
    <span class="hljs-keyword">default</span> <span class="hljs-keyword">input</span> #<span class="hljs-number">1</span>step;             <span class="hljs-comment">// 모든 신호를 이전 타임슬롯에서 샘플</span>
    <span class="hljs-keyword">input</span> rst_n;                      <span class="hljs-comment">// 모니터는 관찰만</span>
    <span class="hljs-keyword">input</span> enable;
    <span class="hljs-keyword">input</span> count;
  <span class="hljs-keyword">endclocking</span>

  <span class="hljs-comment">// ⭐ modport — 접근 권한 제어</span>
  <span class="hljs-keyword">modport</span> drv_mp (<span class="hljs-keyword">clocking</span> drv_cb, <span class="hljs-keyword">input</span> clk);   <span class="hljs-comment">// 드라이버: drv_cb만 접근</span>
  <span class="hljs-keyword">modport</span> mon_mp (<span class="hljs-keyword">clocking</span> mon_cb, <span class="hljs-keyword">input</span> clk);   <span class="hljs-comment">// 모니터: mon_cb만 접근</span>
<span class="hljs-keyword">endinterface</span>
</code></pre><p><strong>핵심 키워드 설명</strong>:</p>
<table>
<thead>
<tr>
<th>키워드</th>
<th>의미</th>
</tr>
</thead>
<tbody><tr>
<td><code>clocking drv_cb @(posedge clk)</code></td>
<td>클럭 양의 에지 기준 타이밍 블록</td>
</tr>
<tr>
<td><code>default input #1step</code></td>
<td>입력 신호를 <strong>이전 타임 슬롯</strong>(preponed region)에서 샘플</td>
</tr>
<tr>
<td><code>default output #0</code></td>
<td>출력 신호를 <strong>현재 클럭 에지에서 즉시</strong> 구동 (지연 없음)</td>
</tr>
<tr>
<td><code>output rst_n</code></td>
<td>이 clocking block에서 <code>rst_n</code>을 출력으로 사용</td>
</tr>
<tr>
<td><code>input count</code></td>
<td>이 clocking block에서 <code>count</code>를 입력으로 사용</td>
</tr>
</tbody></table>
<blockquote>
<p><strong><code>#1step</code>이 <code>#1</code>보다 나은 이유</strong>: <code>#1step</code>은 타임스케일에 관계없이 항상 <strong>이전 타임 슬롯</strong>에서 신호를 샘플합니다. IEEE 1800 표준에 정의된 방법으로, 경쟁 조건이 발생하지 않습니다.</p>
</blockquote>
<h3 id="7-2-3-modport-접근-권한-제어">7.2.3 Modport — 접근 권한 제어</h3>
<p>Modport는 interface 신호에 대한 **방향성(direction)**을 제한합니다:</p>

<div class="svg-diagram">
<svg viewBox="0 0 700 270" xmlns="http://www.w3.org/2000/svg" style="max-width:700px;width:100%">
  
  <style>
    .diagram-box { fill: #ffffff; stroke: #334155; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-accent { fill: #eff6ff; stroke: #2563eb; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-highlight { fill: #fef3c7; stroke: #f59e0b; stroke-width: 2.5; rx: 10; ry: 10; }
    .diagram-box-dark { fill: #1e293b; stroke: #1e293b; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-run { fill: #fef3c7; stroke: #f59e0b; stroke-width: 3; rx: 10; ry: 10; }
    .diagram-box-green { fill: #ecfdf5; stroke: #10b981; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-purple { fill: #f5f3ff; stroke: #7c3aed; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-red { fill: #fef2f2; stroke: #ef4444; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-gray { fill: #f8fafc; stroke: #94a3b8; stroke-width: 1.5; rx: 8; ry: 8; }
    .diagram-text { font-family: 'Noto Sans KR', sans-serif; fill: #1e293b; }
    .diagram-text-white { font-family: 'Noto Sans KR', sans-serif; fill: #ffffff; }
    .diagram-text-accent { font-family: 'Noto Sans KR', sans-serif; fill: #2563eb; }
    .diagram-text-small { font-family: 'Noto Sans KR', sans-serif; fill: #64748b; font-size: 12px; }
    .diagram-text-code { font-family: 'Fira Code', 'JetBrains Mono', monospace; fill: #1e293b; }
    .diagram-arrow { fill: none; stroke: #64748b; stroke-width: 1.5; }
    .diagram-arrow-accent { fill: none; stroke: #2563eb; stroke-width: 1.5; }
    .diagram-line { stroke: #cbd5e1; stroke-width: 1.5; stroke-dasharray: 6,3; }
  </style>
  <defs>
    <marker id="arrowhead" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#64748b" />
    </marker>
    <marker id="arrowhead-accent" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#2563eb" />
    </marker>
    <marker id="arrowhead-dark" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#1e293b" />
    </marker>
    <marker id="arrowhead-orange" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#f59e0b" />
    </marker>
    <filter id="shadow" x="-5%" y="-5%" width="115%" height="115%">
      <feDropShadow dx="0" dy="2" stdDeviation="3" flood-color="#000" flood-opacity="0.1"/>
    </filter>
  </defs>

  <!-- Title -->
  <text x="350" y="28" text-anchor="middle" class="diagram-text" font-size="15" font-weight="bold">Modport 접근 권한</text>
  <text x="350" y="50" text-anchor="middle" class="diagram-text-code" font-size="13">counter_if</text>

  <!-- Outer box -->
  <rect x="60" y="60" width="580" height="195" class="diagram-box" filter="url(#shadow)"/>

  <!-- Signal bar -->
  <rect x="70" y="65" width="560" height="30" rx="4" ry="4" fill="#f8fafc" stroke="#94a3b8" stroke-width="1"/>
  <text x="350" y="85" text-anchor="middle" class="diagram-text-code" font-size="11">신호: rst_n, enable, count</text>

  <!-- Divider -->
  <line x1="350" y1="100" x2="350" y2="248" stroke="#cbd5e1" stroke-width="2"/>

  <!-- Left: drv_mp -->
  <rect x="80" y="105" width="250" height="140" rx="6" ry="6" fill="#eff6ff" stroke="#2563eb" stroke-width="1.5"/>
  <text x="205" y="128" text-anchor="middle" class="diagram-text" font-size="13" font-weight="bold">drv_mp (drv_cb)</text>
  <text x="120" y="155" text-anchor="start" class="diagram-text-code" font-size="12">output rst_n</text>
  <text x="285" y="155" text-anchor="end" class="diagram-text-accent" font-size="14">→</text>
  <text x="120" y="178" text-anchor="start" class="diagram-text-code" font-size="12">output enable</text>
  <text x="285" y="178" text-anchor="end" class="diagram-text-accent" font-size="14">→</text>
  <text x="205" y="230" text-anchor="middle" class="diagram-text-small" font-size="12">(구동만 가능)</text>

  <!-- Right: mon_mp -->
  <rect x="370" y="105" width="250" height="140" rx="6" ry="6" fill="#ecfdf5" stroke="#10b981" stroke-width="1.5"/>
  <text x="495" y="128" text-anchor="middle" class="diagram-text" font-size="13" font-weight="bold">mon_mp (mon_cb)</text>
  <text x="415" y="155" text-anchor="start" class="diagram-text" font-size="14" fill="#10b981">←</text>
  <text x="435" y="155" text-anchor="start" class="diagram-text-code" font-size="12">input rst_n</text>
  <text x="415" y="178" text-anchor="start" class="diagram-text" font-size="14" fill="#10b981">←</text>
  <text x="435" y="178" text-anchor="start" class="diagram-text-code" font-size="12">input enable</text>
  <text x="415" y="201" text-anchor="start" class="diagram-text" font-size="14" fill="#10b981">←</text>
  <text x="435" y="201" text-anchor="start" class="diagram-text-code" font-size="12">input count</text>
  <text x="495" y="230" text-anchor="middle" class="diagram-text-small" font-size="12">(관찰만 가능)</text>
</svg>
</div><p>modport를 사용하면:</p>
<ul>
<li>드라이버가 실수로 <code>count</code>를 구동하는 것을 <strong>컴파일 타임에</strong> 방지</li>
<li>모니터가 실수로 <code>enable</code>을 구동하는 것을 방지</li>
<li>코드의 의도가 명확해짐</li>
</ul>
<h3 id="7-2-4-clocking-block-적용">7.2.4 Clocking Block 적용</h3>
<p>이제 드라이버와 모니터에 clocking block을 적용합니다:</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// 드라이버 — clocking block 사용</span>
<span class="hljs-keyword">class</span> counter_driver <span class="hljs-keyword">extends</span> uvm_driver <span class="hljs-variable">#(counter_seq_item)</span>;
  `uvm_component_utils(counter_driver)

  <span class="hljs-keyword">virtual</span> counter_if vif;

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);
    <span class="hljs-keyword">if</span> (!uvm_config_db<span class="hljs-variable">#(virtual counter_if)::get(this, &quot;&quot;, &quot;vif&quot;, vif))</span>
      `uvm_fatal(get_type_name(), <span class="hljs-string">&quot;Virtual interface not found!&quot;</span>)
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> run_phase(uvm_phase phase);
    counter_seq_item item;
    <span class="hljs-comment">// 초기화: 리셋 상태</span>
    vif<span class="hljs-variable">.drv_cb</span><span class="hljs-variable">.rst_n</span>  &lt;= <span class="hljs-number">0</span>;
    vif<span class="hljs-variable">.drv_cb</span><span class="hljs-variable">.enable</span> &lt;= <span class="hljs-number">0</span>;

    <span class="hljs-keyword">forever</span> <span class="hljs-keyword">begin</span>
      seq_item_port<span class="hljs-variable">.get_next_item</span>(item);
      drive_item(item);
      seq_item_port<span class="hljs-variable">.item_done</span>();
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">endtask</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> drive_item(counter_seq_item item);
    <span class="hljs-comment">// ⭐ clocking block을 통해 신호 구동</span>
    vif<span class="hljs-variable">.drv_cb</span><span class="hljs-variable">.rst_n</span>  &lt;= item<span class="hljs-variable">.rst_n</span>;
    vif<span class="hljs-variable">.drv_cb</span><span class="hljs-variable">.enable</span> &lt;= item<span class="hljs-variable">.enable</span>;
    <span class="hljs-keyword">repeat</span>(item<span class="hljs-variable">.cycles</span>) @(vif<span class="hljs-variable">.drv_cb</span>);  <span class="hljs-comment">// ⭐ clocking event 대기</span>
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>
</code></pre><pre><code class="hljs language-systemverilog"><span class="hljs-comment">// 모니터 — clocking block 사용</span>
<span class="hljs-keyword">class</span> counter_monitor <span class="hljs-keyword">extends</span> uvm_monitor;
  `uvm_component_utils(counter_monitor)

  <span class="hljs-keyword">virtual</span> counter_if vif;
  uvm_analysis_port <span class="hljs-variable">#(counter_seq_item)</span> ap;  <span class="hljs-comment">// ⭐ analysis port</span>

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);
    <span class="hljs-keyword">if</span> (!uvm_config_db<span class="hljs-variable">#(virtual counter_if)::get(this, &quot;&quot;, &quot;vif&quot;, vif))</span>
      `uvm_fatal(get_type_name(), <span class="hljs-string">&quot;Virtual interface not found!&quot;</span>)
    ap = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;ap&quot;</span>, <span class="hljs-keyword">this</span>);  <span class="hljs-comment">// ⭐ analysis port 생성</span>
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> run_phase(uvm_phase phase);
    <span class="hljs-keyword">forever</span> <span class="hljs-keyword">begin</span>
      counter_seq_item item;
      @(vif<span class="hljs-variable">.mon_cb</span>);  <span class="hljs-comment">// ⭐ clocking event 대기 (#1 해킹 불필요!)</span>

      item = counter_seq_item::type_id::create(<span class="hljs-string">&quot;item&quot;</span>);
      <span class="hljs-comment">// ⭐ clocking block을 통해 안정적으로 샘플링</span>
      item<span class="hljs-variable">.rst_n</span>  = vif<span class="hljs-variable">.mon_cb</span><span class="hljs-variable">.rst_n</span>;
      item<span class="hljs-variable">.enable</span> = vif<span class="hljs-variable">.mon_cb</span><span class="hljs-variable">.enable</span>;
      item<span class="hljs-variable">.count</span>  = vif<span class="hljs-variable">.mon_cb</span><span class="hljs-variable">.count</span>;

      ap<span class="hljs-variable">.write</span>(item);  <span class="hljs-comment">// ⭐ analysis port로 브로드캐스트</span>
      `uvm_info(get_type_name(), item<span class="hljs-variable">.convert2string</span>(), UVM_HIGH)
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>
</code></pre><p><strong>Before → After 비교</strong>:</p>
<table>
<thead>
<tr>
<th>항목</th>
<th>Chapter 5/6</th>
<th>Chapter 7</th>
</tr>
</thead>
<tbody><tr>
<td>드라이버 구동</td>
<td><code>vif.enable &lt;= 1</code></td>
<td><code>vif.drv_cb.enable &lt;= 1</code></td>
</tr>
<tr>
<td>클럭 대기</td>
<td><code>@(posedge vif.clk)</code></td>
<td><code>@(vif.drv_cb)</code></td>
</tr>
<tr>
<td>모니터 샘플</td>
<td><code>#1; vif.count</code></td>
<td><code>vif.mon_cb.count</code></td>
</tr>
<tr>
<td>타이밍 보장</td>
<td><code>#1</code> 해킹</td>
<td>IEEE 표준 <code>#1step</code></td>
</tr>
<tr>
<td>접근 제어</td>
<td>없음</td>
<td>modport로 방향 제한</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>참고</strong>: clocking block을 통해 출력 신호를 구동할 때는 항상 논블로킹 할당(<code>&lt;=</code>)을 사용합니다. <code>vif.drv_cb.enable &lt;= 1</code>처럼 쓰면 clocking block이 타이밍을 자동으로 관리합니다.</p>
</blockquote>
<blockquote>
<p><strong>안심하세요</strong>: clocking block 문법이 복잡해 보이지만, interface에 한 번 정의하면 드라이버/모니터에서는 <code>vif.drv_cb.신호명</code>, <code>vif.mon_cb.신호명</code>으로 쓰기만 하면 됩니다. 패턴은 동일합니다.</p>
</blockquote>
<hr>
<h2 id="7-3-드라이버-심화">7.3 드라이버 심화</h2>
<blockquote>
<p><strong>이 절의 목표</strong>: 실무에서 사용하는 드라이버 패턴을 배웁니다. 프로토콜 기반 구동과 에러 핸들링을 포함합니다.</p>
</blockquote>
<h3 id="7-3-1-드라이버의-역할-재정의">7.3.1 드라이버의 역할 재정의</h3>
<p>Chapter 6에서 드라이버는 &quot;How&quot;만 담당한다고 했습니다. 정확히 어떤 일을 하는지 정리합니다:</p>
<ol>
<li><strong>시퀀서에서 트랜잭션 받기</strong> (<code>get_next_item()</code>)</li>
<li><strong>트랜잭션을 DUT 신호로 변환</strong> (프로토콜 구동)</li>
<li><strong>완료 알림</strong> (<code>item_done()</code>)</li>
<li><strong>무한 반복</strong> (<code>forever</code>)</li>
</ol>
<h3 id="7-3-2-get-next-item-vs-try-next-item">7.3.2 get_next_item vs try_next_item</h3>
<p>두 가지 트랜잭션 요청 방법이 있습니다:</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// 방법 1: get_next_item() — 블로킹 (가장 일반적)</span>
<span class="hljs-keyword">forever</span> <span class="hljs-keyword">begin</span>
  seq_item_port<span class="hljs-variable">.get_next_item</span>(item);  <span class="hljs-comment">// 트랜잭션 올 때까지 대기</span>
  drive_item(item);
  seq_item_port<span class="hljs-variable">.item_done</span>();
<span class="hljs-keyword">end</span>

<span class="hljs-comment">// 방법 2: try_next_item() — 논블로킹 (아이들 동작 필요 시)</span>
<span class="hljs-keyword">forever</span> <span class="hljs-keyword">begin</span>
  seq_item_port<span class="hljs-variable">.try_next_item</span>(item);  <span class="hljs-comment">// 즉시 반환 (null일 수 있음)</span>
  <span class="hljs-keyword">if</span> (item != <span class="hljs-literal">null</span>) <span class="hljs-keyword">begin</span>
    drive_item(item);
    seq_item_port<span class="hljs-variable">.item_done</span>();
  <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
    drive_idle();  <span class="hljs-comment">// 트랜잭션이 없으면 아이들 구동</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre><table>
<thead>
<tr>
<th>메서드</th>
<th>동작</th>
<th>사용 시점</th>
</tr>
</thead>
<tbody><tr>
<td><code>get_next_item()</code></td>
<td>트랜잭션이 올 때까지 <strong>대기</strong></td>
<td>대부분의 경우</td>
</tr>
<tr>
<td><code>try_next_item()</code></td>
<td>즉시 반환, 없으면 <code>null</code></td>
<td>아이들 상태 구동이 필요한 프로토콜</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>면접 포인트</strong>: &quot;get_next_item과 try_next_item의 차이는?&quot; — <code>get_next_item()</code>은 블로킹으로 트랜잭션을 기다리고, <code>try_next_item()</code>은 논블로킹으로 즉시 반환합니다. 버스 프로토콜에서 아이들 사이클이 필요하면 <code>try_next_item()</code>을 사용합니다.</p>
</blockquote>
<h3 id="7-3-3-프로토콜-구동-패턴">7.3.3 프로토콜 구동 패턴</h3>
<p>실무 드라이버는 단순히 신호를 할당하는 것이 아니라, <strong>프로토콜 타이밍</strong>을 따릅니다. 4비트 카운터의 실무 수준 드라이버:</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// 실무 수준 드라이버</span>
<span class="hljs-keyword">class</span> counter_driver <span class="hljs-keyword">extends</span> uvm_driver <span class="hljs-variable">#(counter_seq_item)</span>;
  `uvm_component_utils(counter_driver)

  <span class="hljs-keyword">virtual</span> counter_if vif;

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);
    <span class="hljs-keyword">if</span> (!uvm_config_db<span class="hljs-variable">#(virtual counter_if)::get(this, &quot;&quot;, &quot;vif&quot;, vif))</span>
      `uvm_fatal(get_type_name(), <span class="hljs-string">&quot;Virtual interface not found!&quot;</span>)
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> run_phase(uvm_phase phase);
    counter_seq_item item;

    <span class="hljs-comment">// 초기화: DUT 리셋 상태로 시작</span>
    reset_signals();

    <span class="hljs-keyword">forever</span> <span class="hljs-keyword">begin</span>
      seq_item_port<span class="hljs-variable">.get_next_item</span>(item);
      `uvm_info(get_type_name(),
        <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;Driving: %s&quot;</span>, item<span class="hljs-variable">.convert2string</span>()), UVM_HIGH)
      drive_item(item);
      seq_item_port<span class="hljs-variable">.item_done</span>();
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">endtask</span>

  <span class="hljs-comment">// 신호 초기화</span>
  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> reset_signals();
    vif<span class="hljs-variable">.drv_cb</span><span class="hljs-variable">.rst_n</span>  &lt;= <span class="hljs-number">0</span>;
    vif<span class="hljs-variable">.drv_cb</span><span class="hljs-variable">.enable</span> &lt;= <span class="hljs-number">0</span>;
    @(vif<span class="hljs-variable">.drv_cb</span>);  <span class="hljs-comment">// 1 클럭 대기</span>
  <span class="hljs-keyword">endtask</span>

  <span class="hljs-comment">// 트랜잭션 → 신호 변환</span>
  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> drive_item(counter_seq_item item);
    vif<span class="hljs-variable">.drv_cb</span><span class="hljs-variable">.rst_n</span>  &lt;= item<span class="hljs-variable">.rst_n</span>;
    vif<span class="hljs-variable">.drv_cb</span><span class="hljs-variable">.enable</span> &lt;= item<span class="hljs-variable">.enable</span>;
    <span class="hljs-keyword">repeat</span>(item<span class="hljs-variable">.cycles</span>) @(vif<span class="hljs-variable">.drv_cb</span>);
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>
</code></pre><h3 id="7-3-4-response-처리-간단-소개">7.3.4 Response 처리 (간단 소개)</h3>
<p>드라이버가 DUT의 응답을 시퀀스에게 돌려보내야 할 때 <code>item_done(rsp)</code> 패턴을 사용합니다:</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// 드라이버에서 response 전달 (간단 예시)</span>
<span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> run_phase(uvm_phase phase);
  counter_seq_item req, rsp;

  <span class="hljs-keyword">forever</span> <span class="hljs-keyword">begin</span>
    seq_item_port<span class="hljs-variable">.get_next_item</span>(req);
    drive_item(req);

    <span class="hljs-comment">// response 생성 및 전달</span>
    rsp = counter_seq_item::type_id::create(<span class="hljs-string">&quot;rsp&quot;</span>);
    rsp<span class="hljs-variable">.set_id_info</span>(req);       <span class="hljs-comment">// 요청과 응답을 매칭</span>
    rsp<span class="hljs-variable">.count</span> = vif<span class="hljs-variable">.mon_cb</span><span class="hljs-variable">.count</span>;  <span class="hljs-comment">// DUT 출력 기록</span>
    seq_item_port<span class="hljs-variable">.item_done</span>(rsp);  <span class="hljs-comment">// ⭐ response 전달</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endtask</span>
</code></pre><blockquote>
<p><strong>참고</strong>: response 처리는 양방향 프로토콜(예: AXI 읽기)에서 주로 사용합니다. 카운터처럼 단순한 DUT에서는 필요하지 않은 경우가 많습니다.</p>
</blockquote>
<hr>
<h2 id="7-4-모니터-심화">7.4 모니터 심화</h2>
<blockquote>
<p><strong>이 절의 목표</strong>: 모니터의 핵심 역할인 트랜잭션 수집과 analysis port 브로드캐스트를 실무 수준으로 작성합니다.</p>
</blockquote>
<h3 id="7-4-1-모니터의-역할">7.4.1 모니터의 역할</h3>
<p>모니터는 DUT 신호를 <strong>관찰만</strong> 하고, 절대 <strong>구동하지 않습니다</strong>:</p>
<ol>
<li><strong>신호 관찰</strong> — clocking block으로 안정적 샘플링</li>
<li><strong>트랜잭션 조립</strong> — 개별 신호를 트랜잭션 객체로 변환</li>
<li><strong>브로드캐스트</strong> — analysis port로 모든 구독자에게 전송</li>
</ol>
<h3 id="7-4-2-실무-수준-모니터">7.4.2 실무 수준 모니터</h3>
<pre><code class="hljs language-systemverilog"><span class="hljs-keyword">class</span> counter_monitor <span class="hljs-keyword">extends</span> uvm_monitor;
  `uvm_component_utils(counter_monitor)

  <span class="hljs-keyword">virtual</span> counter_if vif;
  uvm_analysis_port <span class="hljs-variable">#(counter_seq_item)</span> ap;

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);
    <span class="hljs-keyword">if</span> (!uvm_config_db<span class="hljs-variable">#(virtual counter_if)::get(this, &quot;&quot;, &quot;vif&quot;, vif))</span>
      `uvm_fatal(get_type_name(), <span class="hljs-string">&quot;Virtual interface not found!&quot;</span>)
    ap = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;ap&quot;</span>, <span class="hljs-keyword">this</span>);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> run_phase(uvm_phase phase);
    <span class="hljs-keyword">forever</span> <span class="hljs-keyword">begin</span>
      collect_transaction();
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">endtask</span>

  <span class="hljs-comment">// 트랜잭션 수집 — 핵심 로직</span>
  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> collect_transaction();
    counter_seq_item item;

    @(vif<span class="hljs-variable">.mon_cb</span>);  <span class="hljs-comment">// 클럭 에지 대기</span>

    <span class="hljs-comment">// ① 트랜잭션 생성</span>
    item = counter_seq_item::type_id::create(<span class="hljs-string">&quot;item&quot;</span>);

    <span class="hljs-comment">// ② clocking block으로 안정적 샘플링</span>
    item<span class="hljs-variable">.rst_n</span>  = vif<span class="hljs-variable">.mon_cb</span><span class="hljs-variable">.rst_n</span>;
    item<span class="hljs-variable">.enable</span> = vif<span class="hljs-variable">.mon_cb</span><span class="hljs-variable">.enable</span>;
    item<span class="hljs-variable">.count</span>  = vif<span class="hljs-variable">.mon_cb</span><span class="hljs-variable">.count</span>;

    <span class="hljs-comment">// ③ analysis port로 브로드캐스트</span>
    ap<span class="hljs-variable">.write</span>(item);

    `uvm_info(get_type_name(),
      <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;Observed: %s&quot;</span>, item<span class="hljs-variable">.convert2string</span>()), UVM_HIGH)
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>
</code></pre><h3 id="7-4-3-모니터-설계-규칙">7.4.3 모니터 설계 규칙</h3>
<table>
<thead>
<tr>
<th>규칙</th>
<th>이유</th>
</tr>
</thead>
<tbody><tr>
<td>신호를 절대 구동하지 않는다</td>
<td>모니터는 관찰자 — DUT 동작에 영향을 주면 안 됨</td>
</tr>
<tr>
<td><code>is_active</code>에 관계없이 항상 존재</td>
<td>수동 에이전트도 모니터는 필요</td>
</tr>
<tr>
<td>analysis port로만 데이터 전달</td>
<td>느슨한 결합 유지 (구독자 변경 시 모니터 수정 불필요)</td>
</tr>
<tr>
<td>프로토콜 완전한 트랜잭션만 전송</td>
<td>불완전한 데이터는 검증 오류 유발</td>
</tr>
</tbody></table>
<hr>
<h2 id="7-5-agent-구성-is-active">7.5 Agent 구성 — is_active</h2>
<blockquote>
<p><strong>이 절의 목표</strong>: Agent의 <code>is_active</code> 플래그로 능동(Active)/수동(Passive) 에이전트를 구성하는 방법을 배웁니다.</p>
</blockquote>
<h3 id="7-5-1-능동-에이전트-vs-수동-에이전트">7.5.1 능동 에이전트 vs 수동 에이전트</h3>
<p>실무에서 에이전트는 두 가지 모드로 동작합니다:</p>

<div class="svg-diagram">
<svg viewBox="0 0 780 375" xmlns="http://www.w3.org/2000/svg" style="max-width:780px;width:100%">
  
  <style>
    .diagram-box { fill: #ffffff; stroke: #334155; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-accent { fill: #eff6ff; stroke: #2563eb; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-highlight { fill: #fef3c7; stroke: #f59e0b; stroke-width: 2.5; rx: 10; ry: 10; }
    .diagram-box-dark { fill: #1e293b; stroke: #1e293b; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-run { fill: #fef3c7; stroke: #f59e0b; stroke-width: 3; rx: 10; ry: 10; }
    .diagram-box-green { fill: #ecfdf5; stroke: #10b981; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-purple { fill: #f5f3ff; stroke: #7c3aed; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-red { fill: #fef2f2; stroke: #ef4444; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-gray { fill: #f8fafc; stroke: #94a3b8; stroke-width: 1.5; rx: 8; ry: 8; }
    .diagram-text { font-family: 'Noto Sans KR', sans-serif; fill: #1e293b; }
    .diagram-text-white { font-family: 'Noto Sans KR', sans-serif; fill: #ffffff; }
    .diagram-text-accent { font-family: 'Noto Sans KR', sans-serif; fill: #2563eb; }
    .diagram-text-small { font-family: 'Noto Sans KR', sans-serif; fill: #64748b; font-size: 12px; }
    .diagram-text-code { font-family: 'Fira Code', 'JetBrains Mono', monospace; fill: #1e293b; }
    .diagram-arrow { fill: none; stroke: #64748b; stroke-width: 1.5; }
    .diagram-arrow-accent { fill: none; stroke: #2563eb; stroke-width: 1.5; }
    .diagram-line { stroke: #cbd5e1; stroke-width: 1.5; stroke-dasharray: 6,3; }
  </style>
  <defs>
    <marker id="arrowhead" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#64748b" />
    </marker>
    <marker id="arrowhead-accent" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#2563eb" />
    </marker>
    <marker id="arrowhead-dark" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#1e293b" />
    </marker>
    <marker id="arrowhead-orange" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#f59e0b" />
    </marker>
    <filter id="shadow" x="-5%" y="-5%" width="115%" height="115%">
      <feDropShadow dx="0" dy="2" stdDeviation="3" flood-color="#000" flood-opacity="0.1"/>
    </filter>
  </defs>

  <!-- Dividing line -->
  <line x1="390" y1="10" x2="390" y2="365" stroke="#cbd5e1" stroke-width="2" stroke-dasharray="8,4"/>

  <!-- ===== LEFT: Active Agent ===== -->
  <text x="195" y="30" text-anchor="middle" class="diagram-text" font-size="14" font-weight="bold">Active Agent (UVM_ACTIVE)</text>

  <!-- Active outer box -->
  <rect x="40" y="44" width="310" height="290" class="diagram-box-accent" filter="url(#shadow)"/>
  <text x="195" y="68" text-anchor="middle" class="diagram-text" font-size="13" font-weight="bold">counter_agent</text>

  <!-- Sequencer -->
  <rect x="90" y="84" width="210" height="42" class="diagram-box-green" filter="url(#shadow)"/>
  <text x="195" y="110" text-anchor="middle" class="diagram-text" font-size="12" font-weight="bold">Sequencer</text>

  <!-- Arrow Sqr → Drv -->
  <line x1="195" y1="126" x2="195" y2="162" class="diagram-arrow" marker-end="url(#arrowhead)" stroke-width="1.5"/>

  <!-- Driver -->
  <rect x="90" y="168" width="210" height="42" class="diagram-box-highlight" filter="url(#shadow)"/>
  <text x="195" y="194" text-anchor="middle" class="diagram-text" font-size="12" font-weight="bold">Driver</text>

  <!-- Monitor -->
  <rect x="90" y="244" width="210" height="42" class="diagram-box-purple" filter="url(#shadow)"/>
  <text x="195" y="270" text-anchor="middle" class="diagram-text" font-size="12" font-weight="bold">Monitor</text>

  <!-- Label -->
  <text x="195" y="312" text-anchor="middle" class="diagram-text-small" font-size="11">DUT에 자극 인가 + 관찰</text>

  <!-- ===== RIGHT: Passive Agent ===== -->
  <text x="585" y="30" text-anchor="middle" class="diagram-text" font-size="14" font-weight="bold">Passive Agent (UVM_PASSIVE)</text>

  <!-- Passive outer box -->
  <rect x="430" y="44" width="310" height="290" class="diagram-box-gray" filter="url(#shadow)"/>
  <text x="585" y="68" text-anchor="middle" class="diagram-text" font-size="13" font-weight="bold">counter_agent</text>

  <!-- No Sequencer placeholder -->
  <rect x="480" y="84" width="210" height="42" rx="8" ry="8" fill="#f8fafc" stroke="#cbd5e1" stroke-width="1.5" stroke-dasharray="6,3"/>
  <text x="585" y="110" text-anchor="middle" class="diagram-text-small" font-size="11" fill="#94a3b8">(Sequencer 없음)</text>

  <!-- No Driver placeholder -->
  <rect x="480" y="168" width="210" height="42" rx="8" ry="8" fill="#f8fafc" stroke="#cbd5e1" stroke-width="1.5" stroke-dasharray="6,3"/>
  <text x="585" y="194" text-anchor="middle" class="diagram-text-small" font-size="11" fill="#94a3b8">(Driver 없음)</text>

  <!-- Monitor -->
  <rect x="480" y="244" width="210" height="42" class="diagram-box-purple" filter="url(#shadow)"/>
  <text x="585" y="270" text-anchor="middle" class="diagram-text" font-size="12" font-weight="bold">Monitor</text>

  <!-- Label -->
  <text x="585" y="312" text-anchor="middle" class="diagram-text-small" font-size="11">DUT 관찰만 (자극 없음)</text>
</svg>
</div><table>
<thead>
<tr>
<th>모드</th>
<th>구성</th>
<th>용도</th>
</tr>
</thead>
<tbody><tr>
<td>Active (<code>UVM_ACTIVE</code>)</td>
<td>Sequencer + Driver + Monitor</td>
<td>DUT에 자극을 인가하고 관찰</td>
</tr>
<tr>
<td>Passive (<code>UVM_PASSIVE</code>)</td>
<td>Monitor만</td>
<td>DUT 출력만 관찰 (자극 없음)</td>
</tr>
</tbody></table>
<h3 id="7-5-2-is-active-구현">7.5.2 is_active 구현</h3>
<pre><code class="hljs language-systemverilog"><span class="hljs-keyword">class</span> counter_agent <span class="hljs-keyword">extends</span> uvm_agent;
  `uvm_component_utils(counter_agent)

  counter_sequencer sqr;
  counter_driver    drv;
  counter_monitor   mon;

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);

    <span class="hljs-comment">// ⭐ 모니터는 항상 생성</span>
    mon = counter_monitor::type_id::create(<span class="hljs-string">&quot;mon&quot;</span>, <span class="hljs-keyword">this</span>);

    <span class="hljs-comment">// ⭐ Active일 때만 시퀀서와 드라이버 생성</span>
    <span class="hljs-keyword">if</span> (get_is_active() == UVM_ACTIVE) <span class="hljs-keyword">begin</span>
      sqr = counter_sequencer::type_id::create(<span class="hljs-string">&quot;sqr&quot;</span>, <span class="hljs-keyword">this</span>);
      drv = counter_driver::type_id::create(<span class="hljs-string">&quot;drv&quot;</span>, <span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> connect_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.connect_phase</span>(phase);

    <span class="hljs-comment">// ⭐ Active일 때만 연결</span>
    <span class="hljs-keyword">if</span> (get_is_active() == UVM_ACTIVE) <span class="hljs-keyword">begin</span>
      drv<span class="hljs-variable">.seq_item_port</span><span class="hljs-variable">.connect</span>(sqr<span class="hljs-variable">.seq_item_export</span>);
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">endfunction</span>
<span class="hljs-keyword">endclass</span>
</code></pre><p><strong>테스트에서 에이전트 모드 설정</strong>:</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// 방법 1: env의 build_phase에서 직접 설정</span>
<span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
  <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);
  agent = counter_agent::type_id::create(<span class="hljs-string">&quot;agent&quot;</span>, <span class="hljs-keyword">this</span>);
  agent<span class="hljs-variable">.is_active</span> = UVM_ACTIVE;   <span class="hljs-comment">// 또는 UVM_PASSIVE</span>
<span class="hljs-keyword">endfunction</span>

<span class="hljs-comment">// 방법 2: config_db로 설정</span>
<span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
  <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);
  uvm_config_db<span class="hljs-variable">#(uvm_active_passive_enum)</span>::set(
    <span class="hljs-keyword">this</span>, <span class="hljs-string">&quot;env.agent&quot;</span>, <span class="hljs-string">&quot;is_active&quot;</span>, UVM_PASSIVE);
<span class="hljs-keyword">endfunction</span>
</code></pre><h3 id="7-5-3-수동-에이전트-활용-예시">7.5.3 수동 에이전트 활용 예시</h3>
<p>수동 에이전트는 DUT의 출력 인터페이스를 모니터링할 때 유용합니다:</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// 환경에 두 개 에이전트 구성</span>
<span class="hljs-keyword">class</span> counter_env <span class="hljs-keyword">extends</span> uvm_env;
  `uvm_component_utils(counter_env)

  counter_agent input_agent;    <span class="hljs-comment">// Active: DUT 입력 구동</span>
  counter_agent output_agent;   <span class="hljs-comment">// Passive: DUT 출력 관찰만</span>

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);

    input_agent = counter_agent::type_id::create(<span class="hljs-string">&quot;input_agent&quot;</span>, <span class="hljs-keyword">this</span>);
    input_agent<span class="hljs-variable">.is_active</span> = UVM_ACTIVE;   <span class="hljs-comment">// ⭐ 자극 인가</span>

    output_agent = counter_agent::type_id::create(<span class="hljs-string">&quot;output_agent&quot;</span>, <span class="hljs-keyword">this</span>);
    output_agent<span class="hljs-variable">.is_active</span> = UVM_PASSIVE;  <span class="hljs-comment">// ⭐ 관찰만</span>
  <span class="hljs-keyword">endfunction</span>
<span class="hljs-keyword">endclass</span>
</code></pre><blockquote>
<p><strong>면접 포인트</strong>: &quot;Active Agent와 Passive Agent의 차이는?&quot; — Active Agent는 Sequencer + Driver + Monitor로 DUT에 자극을 인가하고 관찰합니다. Passive Agent는 Monitor만 있어 DUT 신호를 관찰만 합니다. <code>is_active</code> 플래그로 build_phase에서 조건부 생성합니다.</p>
</blockquote>
<hr>
<h2 id="7-6-종합-실무-수준-테스트벤치">7.6 종합: 실무 수준 테스트벤치</h2>
<blockquote>
<p><strong>이 절의 목표</strong>: 이 챕터에서 배운 TLM, clocking block, analysis port를 모두 적용한 완전한 테스트벤치를 작성합니다.</p>
</blockquote>
<p><strong>[예제 7-1] 실무 수준 UVM 테스트벤치</strong></p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// ================================================================</span>
<span class="hljs-comment">// [예제 7-1] 실무 수준 UVM 테스트벤치</span>
<span class="hljs-comment">// 파일: counter_adv_tb.sv</span>
<span class="hljs-comment">// Chapter 5/6 대비 개선: clocking block, analysis port, is_active</span>
<span class="hljs-comment">// ================================================================</span>

<span class="hljs-comment">// ---- Step 1: 개선된 Interface ----</span>
<span class="hljs-keyword">interface</span> counter_if(<span class="hljs-keyword">input</span> <span class="hljs-keyword">logic</span> clk);
  <span class="hljs-keyword">logic</span>       rst_n;
  <span class="hljs-keyword">logic</span>       enable;
  <span class="hljs-keyword">logic</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] count;

  <span class="hljs-comment">// 드라이버용 clocking block</span>
  <span class="hljs-keyword">clocking</span> drv_cb @(<span class="hljs-keyword">posedge</span> clk);
    <span class="hljs-keyword">default</span> <span class="hljs-keyword">input</span> #<span class="hljs-number">1</span>step <span class="hljs-keyword">output</span> #<span class="hljs-number">0</span>;
    <span class="hljs-keyword">output</span> rst_n;
    <span class="hljs-keyword">output</span> enable;
  <span class="hljs-keyword">endclocking</span>

  <span class="hljs-comment">// 모니터용 clocking block</span>
  <span class="hljs-keyword">clocking</span> mon_cb @(<span class="hljs-keyword">posedge</span> clk);
    <span class="hljs-keyword">default</span> <span class="hljs-keyword">input</span> #<span class="hljs-number">1</span>step;
    <span class="hljs-keyword">input</span> rst_n;
    <span class="hljs-keyword">input</span> enable;
    <span class="hljs-keyword">input</span> count;
  <span class="hljs-keyword">endclocking</span>

  <span class="hljs-keyword">modport</span> drv_mp (<span class="hljs-keyword">clocking</span> drv_cb, <span class="hljs-keyword">input</span> clk);
  <span class="hljs-keyword">modport</span> mon_mp (<span class="hljs-keyword">clocking</span> mon_cb, <span class="hljs-keyword">input</span> clk);
<span class="hljs-keyword">endinterface</span>

<span class="hljs-comment">// ---- Step 2: DUT (변경 없음) ----</span>
<span class="hljs-keyword">module</span> counter (
  <span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span>       clk,
  <span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span>       rst_n,
  <span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span>       enable,
  <span class="hljs-keyword">output</span> <span class="hljs-keyword">logic</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] count
);
  <span class="hljs-keyword">always_ff</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> rst_n) <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (!rst_n)
      count &lt;= <span class="hljs-number">4&#x27;b0</span>;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (enable)
      count &lt;= count + <span class="hljs-number">1</span>;
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>

<span class="hljs-comment">// ---- Step 3: 트랜잭션 (Ch.6과 동일) ----</span>
<span class="hljs-keyword">class</span> counter_seq_item <span class="hljs-keyword">extends</span> uvm_sequence_item;
  <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span>       rst_n;
  <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span>       enable;
  <span class="hljs-keyword">rand</span> <span class="hljs-keyword">int</span>       cycles;
  <span class="hljs-keyword">logic</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>]    count;

  <span class="hljs-keyword">constraint</span> c_cycles { cycles <span class="hljs-keyword">inside</span> {[<span class="hljs-number">1</span>:<span class="hljs-number">20</span>]}; }

  `uvm_object_utils_begin(counter_seq_item)
    `uvm_field_int(rst_n,  UVM_ALL_ON)
    `uvm_field_int(enable, UVM_ALL_ON)
    `uvm_field_int(cycles, UVM_ALL_ON)
    `uvm_field_int(count,  UVM_ALL_ON)
  `uvm_object_utils_end

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;counter_seq_item&quot;</span>);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">string</span> convert2string();
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;rst_n=%0b enable=%0b cycles=%0d count=%0h&quot;</span>,
                     rst_n, enable, cycles, count);
  <span class="hljs-keyword">endfunction</span>
<span class="hljs-keyword">endclass</span>

<span class="hljs-comment">// ---- Step 4: 시퀀스 (Ch.6과 동일) ----</span>
<span class="hljs-keyword">class</span> counter_reset_seq <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(counter_seq_item)</span>;
  `uvm_object_utils(counter_reset_seq)
  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;counter_reset_seq&quot;</span>);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);
  <span class="hljs-keyword">endfunction</span>
  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();
    counter_seq_item item;
    item = counter_seq_item::type_id::create(<span class="hljs-string">&quot;item&quot;</span>);
    start_item(item);
    item<span class="hljs-variable">.rst_n</span> = <span class="hljs-number">0</span>; item<span class="hljs-variable">.enable</span> = <span class="hljs-number">0</span>; item<span class="hljs-variable">.cycles</span> = <span class="hljs-number">2</span>;
    finish_item(item);
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>

<span class="hljs-keyword">class</span> counter_count_seq <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(counter_seq_item)</span>;
  `uvm_object_utils(counter_count_seq)
  <span class="hljs-keyword">rand</span> <span class="hljs-keyword">int</span> num_transactions;
  <span class="hljs-keyword">constraint</span> c_num { num_transactions <span class="hljs-keyword">inside</span> {[<span class="hljs-number">3</span>:<span class="hljs-number">10</span>]}; }
  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;counter_count_seq&quot;</span>);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);
  <span class="hljs-keyword">endfunction</span>
  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();
    counter_seq_item item;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num_transactions; i++) <span class="hljs-keyword">begin</span>
      item = counter_seq_item::type_id::create(<span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;item_%0d&quot;</span>, i));
      start_item(item);
      <span class="hljs-keyword">if</span> (!item<span class="hljs-variable">.randomize</span>() <span class="hljs-keyword">with</span> { rst_n == <span class="hljs-number">1</span>; enable == <span class="hljs-number">1</span>; cycles <span class="hljs-keyword">inside</span> {[<span class="hljs-number">1</span>:<span class="hljs-number">5</span>]}; })
        `uvm_fatal(get_type_name(), <span class="hljs-string">&quot;Randomization failed!&quot;</span>)
      finish_item(item);
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>

<span class="hljs-comment">// ---- Step 5: 시퀀서 (Ch.6과 동일) ----</span>
<span class="hljs-keyword">class</span> counter_sequencer <span class="hljs-keyword">extends</span> uvm_sequencer <span class="hljs-variable">#(counter_seq_item)</span>;
  `uvm_component_utils(counter_sequencer)
  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>
<span class="hljs-keyword">endclass</span>

<span class="hljs-comment">// ---- Step 6: 드라이버 (⭐ clocking block 적용) ----</span>
<span class="hljs-keyword">class</span> counter_driver <span class="hljs-keyword">extends</span> uvm_driver <span class="hljs-variable">#(counter_seq_item)</span>;
  `uvm_component_utils(counter_driver)

  <span class="hljs-keyword">virtual</span> counter_if vif;

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);
    <span class="hljs-keyword">if</span> (!uvm_config_db<span class="hljs-variable">#(virtual counter_if)::get(this, &quot;&quot;, &quot;vif&quot;, vif))</span>
      `uvm_fatal(get_type_name(), <span class="hljs-string">&quot;Virtual interface not found!&quot;</span>)
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> run_phase(uvm_phase phase);
    counter_seq_item item;
    vif<span class="hljs-variable">.drv_cb</span><span class="hljs-variable">.rst_n</span>  &lt;= <span class="hljs-number">0</span>;
    vif<span class="hljs-variable">.drv_cb</span><span class="hljs-variable">.enable</span> &lt;= <span class="hljs-number">0</span>;
    <span class="hljs-keyword">forever</span> <span class="hljs-keyword">begin</span>
      seq_item_port<span class="hljs-variable">.get_next_item</span>(item);
      drive_item(item);
      seq_item_port<span class="hljs-variable">.item_done</span>();
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">endtask</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> drive_item(counter_seq_item item);
    vif<span class="hljs-variable">.drv_cb</span><span class="hljs-variable">.rst_n</span>  &lt;= item<span class="hljs-variable">.rst_n</span>;
    vif<span class="hljs-variable">.drv_cb</span><span class="hljs-variable">.enable</span> &lt;= item<span class="hljs-variable">.enable</span>;
    <span class="hljs-keyword">repeat</span>(item<span class="hljs-variable">.cycles</span>) @(vif<span class="hljs-variable">.drv_cb</span>);
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>

<span class="hljs-comment">// ---- Step 7: 모니터 (⭐ clocking block + analysis port) ----</span>
<span class="hljs-keyword">class</span> counter_monitor <span class="hljs-keyword">extends</span> uvm_monitor;
  `uvm_component_utils(counter_monitor)

  <span class="hljs-keyword">virtual</span> counter_if vif;
  uvm_analysis_port <span class="hljs-variable">#(counter_seq_item)</span> ap;  <span class="hljs-comment">// ⭐</span>

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);
    <span class="hljs-keyword">if</span> (!uvm_config_db<span class="hljs-variable">#(virtual counter_if)::get(this, &quot;&quot;, &quot;vif&quot;, vif))</span>
      `uvm_fatal(get_type_name(), <span class="hljs-string">&quot;Virtual interface not found!&quot;</span>)
    ap = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;ap&quot;</span>, <span class="hljs-keyword">this</span>);  <span class="hljs-comment">// ⭐</span>
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> run_phase(uvm_phase phase);
    <span class="hljs-keyword">forever</span> <span class="hljs-keyword">begin</span>
      counter_seq_item item;
      @(vif<span class="hljs-variable">.mon_cb</span>);  <span class="hljs-comment">// ⭐ #1 대신 clocking event</span>
      item = counter_seq_item::type_id::create(<span class="hljs-string">&quot;item&quot;</span>);
      item<span class="hljs-variable">.rst_n</span>  = vif<span class="hljs-variable">.mon_cb</span><span class="hljs-variable">.rst_n</span>;
      item<span class="hljs-variable">.enable</span> = vif<span class="hljs-variable">.mon_cb</span><span class="hljs-variable">.enable</span>;
      item<span class="hljs-variable">.count</span>  = vif<span class="hljs-variable">.mon_cb</span><span class="hljs-variable">.count</span>;
      ap<span class="hljs-variable">.write</span>(item);  <span class="hljs-comment">// ⭐ 브로드캐스트</span>
      `uvm_info(get_type_name(), item<span class="hljs-variable">.convert2string</span>(), UVM_HIGH)
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>

<span class="hljs-comment">// ---- Step 8: 에이전트 (⭐ is_active 적용) ----</span>
<span class="hljs-keyword">class</span> counter_agent <span class="hljs-keyword">extends</span> uvm_agent;
  `uvm_component_utils(counter_agent)

  counter_sequencer sqr;
  counter_driver    drv;
  counter_monitor   mon;

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);
    mon = counter_monitor::type_id::create(<span class="hljs-string">&quot;mon&quot;</span>, <span class="hljs-keyword">this</span>);  <span class="hljs-comment">// 항상 생성</span>
    <span class="hljs-keyword">if</span> (get_is_active() == UVM_ACTIVE) <span class="hljs-keyword">begin</span>  <span class="hljs-comment">// ⭐</span>
      sqr = counter_sequencer::type_id::create(<span class="hljs-string">&quot;sqr&quot;</span>, <span class="hljs-keyword">this</span>);
      drv = counter_driver::type_id::create(<span class="hljs-string">&quot;drv&quot;</span>, <span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> connect_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.connect_phase</span>(phase);
    <span class="hljs-keyword">if</span> (get_is_active() == UVM_ACTIVE) <span class="hljs-keyword">begin</span>  <span class="hljs-comment">// ⭐</span>
      drv<span class="hljs-variable">.seq_item_port</span><span class="hljs-variable">.connect</span>(sqr<span class="hljs-variable">.seq_item_export</span>);
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">endfunction</span>
<span class="hljs-keyword">endclass</span>

<span class="hljs-comment">// ---- Step 9: 환경 ----</span>
<span class="hljs-keyword">class</span> counter_env <span class="hljs-keyword">extends</span> uvm_env;
  `uvm_component_utils(counter_env)

  counter_agent agent;

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);
    agent = counter_agent::type_id::create(<span class="hljs-string">&quot;agent&quot;</span>, <span class="hljs-keyword">this</span>);
  <span class="hljs-keyword">endfunction</span>
<span class="hljs-keyword">endclass</span>

<span class="hljs-comment">// ---- Step 10: 테스트 ----</span>
<span class="hljs-keyword">class</span> counter_test <span class="hljs-keyword">extends</span> uvm_test;
  `uvm_component_utils(counter_test)

  counter_env env;

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);
    env = counter_env::type_id::create(<span class="hljs-string">&quot;env&quot;</span>, <span class="hljs-keyword">this</span>);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> run_phase(uvm_phase phase);
    counter_reset_seq reset_seq;
    counter_count_seq count_seq;

    phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);

    reset_seq = counter_reset_seq::type_id::create(<span class="hljs-string">&quot;reset_seq&quot;</span>);
    reset_seq<span class="hljs-variable">.start</span>(env<span class="hljs-variable">.agent</span><span class="hljs-variable">.sqr</span>);

    count_seq = counter_count_seq::type_id::create(<span class="hljs-string">&quot;count_seq&quot;</span>);
    count_seq<span class="hljs-variable">.num_transactions</span> = <span class="hljs-number">5</span>;
    count_seq<span class="hljs-variable">.start</span>(env<span class="hljs-variable">.agent</span><span class="hljs-variable">.sqr</span>);

    #<span class="hljs-number">100</span>;
    phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>

<span class="hljs-comment">// ---- Step 11: Top 모듈 ----</span>
<span class="hljs-keyword">module</span> top;
  <span class="hljs-keyword">logic</span> clk;
  <span class="hljs-keyword">initial</span> clk = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">always</span> #<span class="hljs-number">5</span> clk = ~clk;

  counter_if vif(clk);
  counter dut(
    <span class="hljs-variable">.clk</span>(clk), <span class="hljs-variable">.rst_n</span>(vif<span class="hljs-variable">.rst_n</span>),
    <span class="hljs-variable">.enable</span>(vif<span class="hljs-variable">.enable</span>), <span class="hljs-variable">.count</span>(vif<span class="hljs-variable">.count</span>)
  );

  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span>
    uvm_config_db<span class="hljs-variable">#(virtual counter_if)::set(null, &quot;*&quot;, &quot;vif&quot;, vif)</span>;
    run_test(<span class="hljs-string">&quot;counter_test&quot;</span>);
  <span class="hljs-keyword">end</span>

  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span>
    <span class="hljs-built_in">$dumpfile</span>(<span class="hljs-string">&quot;counter_adv.vcd&quot;</span>);
    <span class="hljs-built_in">$dumpvars</span>(<span class="hljs-number">0</span>, top);
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</code></pre><h3 id="7-6-1-ch-5-6-대비-진화-정리">7.6.1 Ch.5/6 대비 진화 정리</h3>
<table>
<thead>
<tr>
<th>항목</th>
<th>Ch.5</th>
<th>Ch.6</th>
<th>Ch.7</th>
</tr>
</thead>
<tbody><tr>
<td>시나리오</td>
<td>드라이버에 하드코딩</td>
<td>시퀀스로 분리</td>
<td>시퀀스 (동일)</td>
</tr>
<tr>
<td>타이밍</td>
<td><code>#1</code> 해킹</td>
<td><code>#1</code> 해킹</td>
<td><strong>clocking block</strong></td>
</tr>
<tr>
<td>접근 제어</td>
<td>없음</td>
<td>없음</td>
<td><strong>modport</strong></td>
</tr>
<tr>
<td>데이터 전달</td>
<td>직접 신호</td>
<td>seq_item_port</td>
<td>seq_item_port (동일)</td>
</tr>
<tr>
<td>모니터 출력</td>
<td><code>uvm_info</code>만</td>
<td><code>uvm_info</code>만</td>
<td><strong>analysis port</strong></td>
</tr>
<tr>
<td>Agent 모드</td>
<td>고정</td>
<td>고정</td>
<td><strong>is_active</strong></td>
</tr>
</tbody></table>
<blockquote>
<p><strong>성취감 포인트</strong>: 이제 작성한 테스트벤치는 실무에서 사용하는 것과 <strong>거의 동일한 구조</strong>입니다! 남은 것은 스코어보드(Ch.8), 커버리지(Ch.8), 그리고 고급 시나리오(Ch.9)뿐입니다.</p>
</blockquote>
<hr>
<h2 id="7-7-체크포인트">7.7 체크포인트</h2>
<h3 id="셀프-체크">셀프 체크</h3>
<p><strong>1. TLM port와 analysis port의 차이는?</strong> (7.1)</p>
<details>
<summary>정답 확인</summary>
TLM port(seq_item_port)는 1:1 연결로 드라이버가 시퀀서에게 트랜잭션을 요청합니다. Analysis port는 1:N 브로드캐스트로 모니터가 여러 구독자(스코어보드, 커버리지 등)에게 동시에 데이터를 전송합니다.
</details>

<p><strong>2. clocking block의 <code>#1step</code>이 <code>#1</code>보다 나은 이유는?</strong> (7.2)</p>
<details>
<summary>정답 확인</summary>
`#1step`은 타임스케일에 관계없이 항상 이전 타임 슬롯(preponed region)에서 신호를 샘플합니다. IEEE 1800 표준 방법으로 경쟁 조건이 발생하지 않습니다. `#1`은 타임스케일에 의존하고 표준이 아닙니다.
</details>

<p><strong>3. modport를 사용하는 이유는?</strong> (7.2)</p>
<details>
<summary>정답 확인</summary>
드라이버는 output 신호만, 모니터는 input 신호만 접근하도록 방향성을 제한합니다. 실수로 모니터가 신호를 구동하거나 드라이버가 출력을 읽는 것을 컴파일 타임에 방지합니다.
</details>

<p><strong>4. get_next_item()과 try_next_item()의 차이는?</strong> (7.3)</p>
<details>
<summary>정답 확인</summary>
get_next_item()은 블로킹으로 트랜잭션이 올 때까지 대기합니다. try_next_item()은 논블로킹으로 즉시 반환하며 없으면 null입니다. 아이들 상태 구동이 필요한 버스 프로토콜에서 try_next_item()을 사용합니다.
</details>

<p><strong>5. 모니터에서 analysis port의 write()를 호출하면 무슨 일이 일어나나?</strong> (7.4)</p>
<details>
<summary>정답 확인</summary>
연결된 모든 구독자(스코어보드, 커버리지 수집기 등)의 write() 메서드가 자동으로 호출됩니다. 구독자가 없어도 에러가 아닙니다(0:N 가능). 비블로킹으로 실행됩니다.
</details>

<p><strong>6. Active Agent와 Passive Agent의 차이는?</strong> (7.5)</p>
<details>
<summary>정답 확인</summary>
Active Agent(UVM_ACTIVE)는 Sequencer + Driver + Monitor를 모두 가지고 DUT에 자극을 인가합니다. Passive Agent(UVM_PASSIVE)는 Monitor만 가지고 DUT 신호를 관찰만 합니다. is_active 플래그로 build_phase에서 조건부 생성합니다.
</details>

<hr>
<h3 id="연습문제">연습문제</h3>
<p><strong>[실습 7-1] Clocking block 마이그레이션 (쉬움)</strong> — 약 10분</p>
<p>Chapter 6의 예제 6-1 드라이버에서 <code>vif.rst_n</code>, <code>vif.enable</code>을 clocking block 방식(<code>vif.drv_cb.rst_n</code>, <code>vif.drv_cb.enable</code>)으로 변경하세요. 모니터도 <code>vif.mon_cb</code>를 사용하도록 수정하세요.</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// 변경 전 (Ch.6 방식)</span>
<span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> drive_item(counter_seq_item item);
  vif<span class="hljs-variable">.rst_n</span>  &lt;= item<span class="hljs-variable">.rst_n</span>;       <span class="hljs-comment">// 직접 접근</span>
  vif<span class="hljs-variable">.enable</span> &lt;= item<span class="hljs-variable">.enable</span>;
  <span class="hljs-keyword">repeat</span>(item<span class="hljs-variable">.cycles</span>) @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>);
<span class="hljs-keyword">endtask</span>

<span class="hljs-comment">// 변경 후 (Ch.7 방식) — 여기를 채우세요</span>
<span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> drive_item(counter_seq_item item);
  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> clocking block 사용으로 변경</span>
<span class="hljs-keyword">endtask</span>
</code></pre><details>
<summary>정답 확인</summary>

<pre><code class="hljs language-systemverilog"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> drive_item(counter_seq_item item);
  vif<span class="hljs-variable">.drv_cb</span><span class="hljs-variable">.rst_n</span>  &lt;= item<span class="hljs-variable">.rst_n</span>;
  vif<span class="hljs-variable">.drv_cb</span><span class="hljs-variable">.enable</span> &lt;= item<span class="hljs-variable">.enable</span>;
  <span class="hljs-keyword">repeat</span>(item<span class="hljs-variable">.cycles</span>) @(vif<span class="hljs-variable">.drv_cb</span>);
<span class="hljs-keyword">endtask</span>
</code></pre></details>

<hr>
<p><strong>[실습 7-2] Analysis port 연결 (보통)</strong> — 약 15분</p>
<p>모니터의 analysis port를 간단한 subscriber에 연결하세요. subscriber는 트랜잭션을 받을 때마다 카운트를 증가시키고 최종 개수를 출력합니다:</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// 요구사항:</span>
<span class="hljs-comment">// 1. uvm_subscriber를 상속받는 counter_subscriber 작성</span>
<span class="hljs-comment">// 2. write() 메서드에서 수신 횟수 카운트</span>
<span class="hljs-comment">// 3. report_phase()에서 총 수신 트랜잭션 수 출력</span>
<span class="hljs-comment">// 4. env의 connect_phase에서 monitor.ap → subscriber 연결</span>

<span class="hljs-keyword">class</span> counter_subscriber <span class="hljs-keyword">extends</span> uvm_subscriber <span class="hljs-variable">#(counter_seq_item)</span>;
  `uvm_component_utils(counter_subscriber)

  <span class="hljs-keyword">int</span> tx_count = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> write() 구현</span>
  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> report_phase() 구현</span>
<span class="hljs-keyword">endclass</span>
</code></pre><details>
<summary>정답 확인</summary>

<pre><code class="hljs language-systemverilog"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> write(counter_seq_item t);
  tx_count++;
  `uvm_info(get_type_name(),
    <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;[%0d] %s&quot;</span>, tx_count, t<span class="hljs-variable">.convert2string</span>()), UVM_HIGH)
<span class="hljs-keyword">endfunction</span>

<span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> report_phase(uvm_phase phase);
  <span class="hljs-keyword">super</span><span class="hljs-variable">.report_phase</span>(phase);
  `uvm_info(get_type_name(),
    <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;Total transactions observed: %0d&quot;</span>, tx_count), UVM_MEDIUM)
<span class="hljs-keyword">endfunction</span>
</code></pre><p>env의 connect_phase:</p>
<pre><code class="hljs language-systemverilog">agent<span class="hljs-variable">.mon</span><span class="hljs-variable">.ap</span><span class="hljs-variable">.connect</span>(subscriber<span class="hljs-variable">.analysis_export</span>);
</code></pre></details>

<hr>
<p><strong>[실습 7-3] Passive Agent 테스트 (도전)</strong> — 약 20분</p>
<p>환경에 두 개의 에이전트를 추가하세요: Active agent (DUT 입력 구동)와 Passive agent (DUT 출력 관찰). Passive agent의 모니터에 subscriber를 연결하여 출력 트랜잭션 수를 세세요.</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// 요구사항:</span>
<span class="hljs-comment">// 1. counter_env에 input_agent(ACTIVE)와 output_agent(PASSIVE) 추가</span>
<span class="hljs-comment">// 2. output_agent.mon.ap에 counter_subscriber 연결</span>
<span class="hljs-comment">// 3. 테스트 실행 후 subscriber의 report에서 총 트랜잭션 수 확인</span>
</code></pre><details>
<summary>정답 확인</summary>

<pre><code class="hljs language-systemverilog"><span class="hljs-keyword">class</span> counter_env <span class="hljs-keyword">extends</span> uvm_env;
  `uvm_component_utils(counter_env)

  counter_agent input_agent;
  counter_agent output_agent;
  counter_subscriber sub;

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);
    input_agent = counter_agent::type_id::create(<span class="hljs-string">&quot;input_agent&quot;</span>, <span class="hljs-keyword">this</span>);
    input_agent<span class="hljs-variable">.is_active</span> = UVM_ACTIVE;

    output_agent = counter_agent::type_id::create(<span class="hljs-string">&quot;output_agent&quot;</span>, <span class="hljs-keyword">this</span>);
    output_agent<span class="hljs-variable">.is_active</span> = UVM_PASSIVE;

    sub = counter_subscriber::type_id::create(<span class="hljs-string">&quot;sub&quot;</span>, <span class="hljs-keyword">this</span>);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> connect_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.connect_phase</span>(phase);
    output_agent<span class="hljs-variable">.mon</span><span class="hljs-variable">.ap</span><span class="hljs-variable">.connect</span>(sub<span class="hljs-variable">.analysis_export</span>);
  <span class="hljs-keyword">endfunction</span>
<span class="hljs-keyword">endclass</span>
</code></pre></details>

<hr>
<h3 id="흔한-에러와-해결">흔한 에러와 해결</h3>
<table>
<thead>
<tr>
<th>에러 메시지</th>
<th>원인</th>
<th>해결</th>
</tr>
</thead>
<tbody><tr>
<td><code>Cannot drive net</code></td>
<td>모니터에서 output 신호를 구동 시도</td>
<td>modport 확인, 모니터는 input만 접근</td>
</tr>
<tr>
<td><code>Port not connected</code></td>
<td>connect_phase 누락</td>
<td><code>drv.seq_item_port.connect(sqr.seq_item_export)</code> 확인</td>
</tr>
<tr>
<td><code>No write() found</code></td>
<td>analysis_imp에 write() 미구현</td>
<td>받는 쪽 클래스에 <code>write()</code> 함수 구현</td>
</tr>
<tr>
<td><code>Null object at drv</code></td>
<td>Passive agent에서 드라이버 접근</td>
<td><code>get_is_active()</code> 확인 후 조건부 접근</td>
</tr>
<tr>
<td><code>Clocking block event</code></td>
<td><code>@(posedge vif.clk)</code> 대신 <code>@(vif.drv_cb)</code> 미사용</td>
<td>clocking event로 변경</td>
</tr>
</tbody></table>
<h3 id="용어-정리">용어 정리</h3>
<table>
<thead>
<tr>
<th>용어</th>
<th>영어</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>TLM</td>
<td>Transaction Level Modeling</td>
<td>컴포넌트 간 트랜잭션 통신 표준</td>
</tr>
<tr>
<td>포트</td>
<td>Port</td>
<td>데이터를 보내는 쪽의 연결점</td>
</tr>
<tr>
<td>익스포트</td>
<td>Export</td>
<td>데이터를 받는 쪽의 연결점</td>
</tr>
<tr>
<td>분석 포트</td>
<td>Analysis Port</td>
<td>1:N 브로드캐스트용 포트</td>
</tr>
<tr>
<td>클럭킹 블록</td>
<td>Clocking Block</td>
<td>타이밍 안정적 신호 샘플/구동</td>
</tr>
<tr>
<td>모드포트</td>
<td>Modport</td>
<td>Interface 신호 접근 방향 제한</td>
</tr>
<tr>
<td>능동 에이전트</td>
<td>Active Agent</td>
<td>Sequencer + Driver + Monitor 구성</td>
</tr>
<tr>
<td>수동 에이전트</td>
<td>Passive Agent</td>
<td>Monitor만 구성</td>
</tr>
</tbody></table>
<h3 id="다음-챕터-예고">다음 챕터 예고</h3>
<p>Chapter 8에서는 이 챕터에서 소개한 analysis port의 <strong>활용</strong>을 본격적으로 다룹니다. **스코어보드(Scoreboard)**로 자동 검증을, <strong>Functional Coverage</strong>로 검증 완전성을 측정합니다.</p>

    <nav class="chapter-nav"><a href="chapter-06-final.html" class="nav-prev">
      <span class="nav-label">이전 챕터</span>
      <span class="nav-title">Ch.6 시퀀스 & 시퀀서</span>
    </a><a href="chapter-08-final.html" class="nav-next">
      <span class="nav-label">다음 챕터</span>
      <span class="nav-title">Ch.8 스코어보드 & 커버리지</span>
    </a></nav>
  </div>

  <footer class="book-footer">
    <p>팹리스 검증 엔지니어가 되기 위한 UVM 완전정복</p>
    <p>Published by UVM Book Publisher Agent</p>
  </footer>

  <!-- Back to Top Button -->
  <button class="back-to-top" id="backToTop" onclick="window.scrollTo({top:0,behavior:'smooth'})">↑</button>

  <script>
    // Reading progress bar
    window.addEventListener('scroll', () => {
      const h = document.documentElement;
      const pct = (h.scrollTop / (h.scrollHeight - h.clientHeight)) * 100;
      document.getElementById('progressBar').style.width = pct + '%';
      document.getElementById('backToTop').classList.toggle('visible', h.scrollTop > 400);
    });

    // Language labels for code blocks
    document.querySelectorAll('pre').forEach(pre => {
      const code = pre.querySelector('code');
      if (code) {
        const cls = code.className || '';
        const m = cls.match(/language-(\w+)/);
        if (m) {
          const map = {
            systemverilog:'SystemVerilog', sv:'SystemVerilog', verilog:'Verilog',
            bash:'Bash', shell:'Shell', tcl:'TCL', makefile:'Makefile',
            python:'Python', javascript:'JavaScript', text:'Output'
          };
          pre.setAttribute('data-lang', map[m[1]] || m[1]);
        }
      }
    });

    // Smart labels for plain code blocks
    document.querySelectorAll('pre code:not([class*="language-"])').forEach(code => {
      const pre = code.parentElement;
      if (!pre.getAttribute('data-lang')) {
        const t = code.textContent || '';
        if (t.includes('UVM_INFO') || t.includes('UVM_WARNING')) {
          pre.setAttribute('data-lang', 'Simulation Output');
        } else if (t.includes('[채용') || t.includes('필수 자격')) {
          pre.setAttribute('data-lang', '');
        } else if (t.includes('Step') || t.includes('패널') || t.includes('편집기')) {
          pre.setAttribute('data-lang', 'Setup Guide');
        } else {
          pre.setAttribute('data-lang', 'Info');
        }
      }
    });

    // Smooth scroll for TOC links
    document.querySelectorAll('.toc a').forEach(a => {
      a.addEventListener('click', e => {
        e.preventDefault();
        const id = a.getAttribute('href').slice(1);
        const target = document.getElementById(id);
        if (target) target.scrollIntoView({ behavior: 'smooth', block: 'start' });
      });
    });
  </script>
</body>
</html>