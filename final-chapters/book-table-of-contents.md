# 팹리스 검증 엔지니어가 되기 위한 UVM 완전정복

## 전체 상세 목차 (Table of Contents)

> **총 15개 챕터 · 3개 파트 · 18,035줄 · 66개 SVG 다이어그램**
>
> 이론 30% : 실습 70% | 초보자부터 취업까지 완전정복

---

## 책 구성 요약

| Part | 챕터 | 주제 | 분량 (줄) | SVG |
|------|-------|------|-----------|-----|
| **Part 1: 시작하기** | Ch.1 ~ Ch.5 | UVM 기초와 첫 테스트벤치 | 5,395 | 35 |
| **Part 2: 깊이 파기** | Ch.6 ~ Ch.10 | 컴포넌트 심화와 검증 기법 | 5,971 | 21 |
| **Part 3: 완성하기** | Ch.11 ~ Ch.15 | 실무 프로토콜과 취업 준비 | 6,669 | 10 |

---

## Part 1: 시작하기

> UVM의 기초 개념을 이해하고, 첫 번째 UVM 테스트벤치를 직접 작성합니다.

---

### Chapter 1: UVM 소개
**944줄 · SVG 8개 · 키워드: UVM, Testbench, Verification Methodology**

- **1.1 UVM이란 무엇인가?**
  - 1.1.1 검증이 왜 필요한가?
  - 1.1.2 전통적 검증 vs UVM 검증
  - 1.1.3 UVM의 등장
  - 1.1.4 UVM 테스트벤치(Testbench) 구조 한눈에 보기
- **1.2 왜 UVM을 배워야 하는가?**
  - 1.2.1 취업 시장에서의 UVM
  - 1.2.2 UVM을 배우면 얻는 것
  - 1.2.3 이 책의 학습 로드맵
- **1.3 실습 환경 구성**
  - 1.3.1 필요한 도구들
  - 1.3.2 EDA Playground 시작하기
  - 1.3.3 로컬 환경 설정 (선택사항)
- **1.4 첫 번째 UVM 예제**
  - 1.4.1 "Hello UVM!" — 가장 간단한 UVM 프로그램
  - 1.4.2 코드 분석: 한 줄 한 줄 이해하기
  - 1.4.3 실행 결과
  - 1.4.4 실습: 직접 해보기!
  - 1.4.5 예제 심화: 간단한 트랜잭션(Transaction) 맛보기
- **1.5 Chapter 1 정리**
  - 핵심 요약 / 용어 정리 / 셀프 체크 / 다음 Chapter 미리보기

---

### Chapter 2: 환경 설정
**828줄 · SVG 6개 · 키워드: EDA Playground, Simulator, Questa, UVM Library**

- **2.1 시뮬레이터란 무엇인가?**
  - 2.1.1 시뮬레이터의 역할
  - 2.1.2 주요 상용 시뮬레이터
  - 2.1.3 무료 실습 환경 선택지
- **2.2 EDA Playground로 바로 시작하기**
  - 2.2.1 EDA Playground란?
  - 2.2.2 EDA Playground 설정 확인
  - 2.2.3 첫 UVM 코드 실행하기 (10분)
  - 2.2.4 출력 결과 해석하기
  - 2.2.5 자주 발생하는 에러와 해결법
    - 에러 1: UVM 라이브러리를 못 찾는 경우
    - 에러 2: 팩토리(Factory) 등록 누락
    - 에러 3: 시뮬레이션이 바로 끝나는 경우
- **2.3 UVM 코드 구조 이해하기**
  - 2.3.1 UVM 프로그램의 기본 뼈대
  - 2.3.2 `include`와 `import`의 차이
  - 2.3.3 `uvm_info` vs `$display` 비교
- **2.4 실습: UVM 코드 수정해보기**
  - 2.4.1 실습 1: 메시지 바꿔보기 (쉬움)
  - 2.4.2 실습 2: 여러 페이즈(Phase) 체험하기 (보통)
  - 2.4.3 실습 3: 반복 테스트 만들기 (보통)
- **2.5 로컬 환경 설정 (선택 사항)**
  - 2.5.1 왜 로컬 환경이 필요할까?
  - 2.5.2 운영체제 준비
  - 2.5.3 Questa (Intel FPGA Edition) 설치
  - 2.5.4 UVM 라이브러리 설정
  - 2.5.5 첫 로컬 컴파일 테스트
- **2.6 UVM 프로젝트 디렉토리 구조**
  - 2.6.1 실무 표준 디렉토리 구조
  - 2.6.2 각 디렉토리의 역할
  - 2.6.3 간단한 Makefile 맛보기
- **2.7 체크포인트**
  - 셀프 체크 / 연습문제 / 다음 챕터 미리보기

---

### Chapter 3: SystemVerilog 핵심
**1,220줄 · SVG 10개 · 키워드: Class, Inheritance, Polymorphism, Randomization**

- **3.1 왜 SystemVerilog를 배워야 하는가?**
  - 3.1.1 Verilog의 한계
  - 3.1.2 이 챕터에서 배울 것
- **3.2 클래스(Class)와 객체(Object)**
  - 3.2.1 module과 class의 차이
  - 3.2.2 첫 번째 클래스 만들기
  - 3.2.3 클래스 vs 객체: 붕어빵 비유
  - 3.2.4 핸들(Handle) — 클래스 변수의 정체
  - 3.2.5 null 참조 에러 — 가장 흔한 실수
- **3.3 상속(Inheritance)과 다형성(Polymorphism)**
  - 3.3.1 상속이란?
  - 3.3.2 상속 실습
  - 3.3.3 다형성(Polymorphism) — 왜 virtual이 중요한가?
  - 3.3.4 virtual 없이 실행하면?
- **3.4 인터페이스(Interface)**
  - 3.4.1 인터페이스가 필요한 이유
  - 3.4.2 인터페이스 정의와 사용
  - 3.4.3 인터페이스의 핵심 요소
- **3.5 랜덤화(Randomization)와 제약 조건(Constraint)**
  - 3.5.1 왜 랜덤 테스트가 필요한가?
  - 3.5.2 rand와 constraint 기본
  - 3.5.3 중간 정리 — 랜덤화 핵심 키워드
  - 3.5.4 자주 쓰는 제약 조건 패턴
  - 3.5.5 inline constraint (with절)
  - 3.5.6 randomize() 실패 처리
- **3.6 열거형(Enum), 구조체(Struct), 타입 정의(Typedef)**
  - 3.6.1 열거형(Enum)
  - 3.6.2 구조체(Struct)와 타입 정의(Typedef)
  - 3.6.3 종합 실습: 모든 개념 활용
- **3.7 체크포인트**
  - 셀프 체크 / 연습문제 / 흔한 컴파일 에러 / 용어 정리 / 다음 챕터 미리보기

---

### Chapter 4: UVM 기본 컴포넌트
**1,257줄 · SVG 7개 · 키워드: uvm_object, uvm_component, Factory, Phase**

- **4.1 UVM 클래스 계층 구조**
  - 4.1.1 UVM은 거대한 클래스 라이브러리
  - 4.1.2 uvm_object와 uvm_component의 차이
  - 4.1.3 생성자의 차이 — parent가 핵심
  - 4.1.4 실습: uvm_component 기본 예제
- **4.2 Factory 패턴 — new() 대신 create()를 쓰는 이유**
  - 4.2.1 먼저 new()로 만들어보면?
  - 4.2.2 new()의 문제 — 교체가 안 된다
  - 4.2.3 Factory의 해결책 — 코드 수정 없이 교체
  - 4.2.4 Factory 사용법 3단계
  - 4.2.5 Factory 매크로가 하는 일
  - 4.2.6 흔한 실수: 매크로를 빠뜨리면?
  - 4.2.7 Factory 실습 예제
- **4.3 Phase 메커니즘 — 시뮬레이션의 순서 관리**
  - 4.3.1 Phase가 필요한 이유
  - 4.3.2 핵심 Phase 3가지
  - 4.3.3 Phase의 실행 순서 상세
  - 4.3.4 build_phase의 실행 순서 — 위에서 아래로
  - 4.3.5 Phase에서 하면 안 되는 것
  - 4.3.6 run_phase와 objection — 시뮬레이션 종료 조건
  - 4.3.7 Phase 실습: 실행 순서 확인
- **4.4 종합: UVM 컴포넌트 작성 패턴**
  - 4.4.1 UVM 컴포넌트 작성 템플릿
  - 4.4.2 uvm_object 작성 템플릿
  - 4.4.3 종합 실습: 미니 검증 환경
- **4.5 체크포인트**
  - 셀프 체크 / 연습문제 / 흔한 에러와 해결법 / 용어 정리 / 다음 챕터 미리보기

---

### Chapter 5: 첫 UVM 테스트벤치
**1,146줄 · SVG 4개 · 키워드: Virtual Interface, config_db, Driver, Monitor, Agent**

- **5.1 DUT 소개 — 4비트 업카운터**
  - 5.1.1 검증할 대상: 4비트 카운터
  - 5.1.2 Interface 정의
- **5.2 Virtual Interface — 왜 필요한가**
  - 5.2.1 문제: class에서 interface에 접근할 수 없다
  - 5.2.2 해결: virtual interface
  - 5.2.3 virtual interface 선언과 사용
  - 5.2.4 흔한 실수: virtual interface를 연결 안 하면?
- **5.3 uvm_config_db — 설정값 전달 메커니즘**
  - 5.3.1 config_db가 필요한 이유
  - 5.3.2 config_db 사용법: set()과 get()
  - 5.3.3 set/get 패턴 정리
  - 5.3.4 흔한 실수: config_db get 실패
  - 5.3.5 실습: config_db로 virtual interface 전달
- **5.4 드라이버와 모니터 기초**
  - 5.4.1 드라이버 = 신호를 보내는 역할
  - 5.4.2 모니터 = 신호를 관찰하는 역할
  - 5.4.3 에이전트 = 드라이버 + 모니터 묶음
- **5.5 종합: 첫 완전한 UVM 테스트벤치**
  - 5.5.1 전체 구조 한눈에 보기
  - 5.5.2 단계별 빌드업
  - 5.5.3 코드 구조 정리
- **5.6 체크포인트**
  - 셀프 체크 / 연습문제 / 흔한 에러와 해결법 / 용어 정리 / 다음 챕터 미리보기

---

## Part 2: 깊이 파기

> 각 UVM 컴포넌트를 심화 학습하고, 자동 검증/디버깅 기법을 익힙니다.

---

### Chapter 6: 시퀀스 & 시퀀서
**1,274줄 · SVG 6개 · 키워드: uvm_sequence, uvm_sequencer, uvm_sequence_item, start()**

- **6.1 왜 시퀀스가 필요한가**
  - 6.1.1 Chapter 5 방식의 한계
  - 6.1.2 해결: What과 How의 분리
  - 6.1.3 Sequence-Sequencer-Driver 흐름
- **6.2 트랜잭션 정의 — uvm_sequence_item**
  - 6.2.1 트랜잭션이란?
  - 6.2.2 uvm_sequence_item 작성
  - 6.2.3 주요 설계 원칙
- **6.3 시퀀스 작성 — uvm_sequence**
  - 6.3.1 시퀀스란?
  - 6.3.2 첫 번째 시퀀스: 리셋 시퀀스
  - 6.3.3 두 번째 시퀀스: 카운트 시퀀스
  - 6.3.4 \`uvm_do 매크로 — 간편 표기
  - 6.3.5 시퀀스 조합: 마스터 시퀀스
- **6.4 시퀀서와 드라이버 연결**
  - 6.4.1 시퀀서 (uvm_sequencer)
  - 6.4.2 드라이버 리팩토링: get_next_item()/item_done()
  - 6.4.3 seq_item_port — 드라이버와 시퀀서의 연결
  - 6.4.4 시퀀스 실행: test에서 start() 호출
- **6.5 종합: 시퀀스 기반 테스트벤치**
  - 6.5.1 Before → After 비교
  - 6.5.2 완전한 코드
  - 6.5.3 Ch.5 대비 변경 사항 정리
  - 6.5.4 다양한 테스트 만들기
  - 6.5.5 시뮬레이션 실행
- **6.6 체크포인트**
  - 셀프 체크 / 연습문제 / 흔한 에러와 해결 / 용어 정리 / 다음 챕터 예고

---

### Chapter 7: 드라이버 & 모니터 심화
**1,182줄 · SVG 4개 · 키워드: TLM Port, Analysis Port, Clocking Block, Modport, is_active**

- **7.1 TLM 포트 이해**
  - 7.1.1 TLM이란?
  - 7.1.2 Sequencer-Driver TLM 연결
  - 7.1.3 Analysis Port — 1:N 브로드캐스트
  - 7.1.4 Analysis Port 사용법
- **7.2 Clocking Block & Modport**
  - 7.2.1 `#1` 해킹의 문제
  - 7.2.2 해결: Clocking Block
  - 7.2.3 Modport — 접근 권한 제어
  - 7.2.4 Clocking Block 적용
- **7.3 드라이버 심화**
  - 7.3.1 드라이버의 역할 재정의
  - 7.3.2 get_next_item vs try_next_item
  - 7.3.3 프로토콜 구동 패턴
  - 7.3.4 Response 처리 (간단 소개)
- **7.4 모니터 심화**
  - 7.4.1 모니터의 역할
  - 7.4.2 실무 수준 모니터
  - 7.4.3 모니터 설계 규칙
- **7.5 Agent 구성 — is_active**
  - 7.5.1 능동 에이전트 vs 수동 에이전트
  - 7.5.2 is_active 구현
  - 7.5.3 수동 에이전트 활용 예시
- **7.6 종합: 실무 수준 테스트벤치**
  - 7.6.1 Ch.5/6 대비 진화 정리
- **7.7 체크포인트**
  - 셀프 체크 / 연습문제 / 흔한 에러와 해결 / 용어 정리 / 다음 챕터 예고

---

### Chapter 8: 스코어보드 & 커버리지
**1,190줄 · SVG 7개 · 키워드: uvm_scoreboard, Analysis Port, covergroup, CDV**

- **8.1 왜 자동 검증이 필요한가**
  - 8.1.1 수동 검증의 한계 — 눈으로 확인하는 검증
  - 8.1.2 스코어보드 — 자동 채점기
  - 8.1.3 커버리지 — 시험 범위 체크리스트
  - 8.1.4 검증 자동화 전체 구조
- **8.2 스코어보드 기초**
  - 8.2.1 Reference Model — 정답지 만들기
  - 8.2.2 uvm_scoreboard 와 uvm_analysis_imp
  - 8.2.3 write() 메서드 — 트랜잭션이 도착하면
  - 8.2.4 기본 스코어보드 구현 — 예제 8-1
- **8.3 스코어보드 심화**
  - 8.3.1 uvm_subscriber — 더 간단한 대안
  - 8.3.2 예측-비교 분리 패턴
  - 8.3.3 멀티포트 스코어보드
  - 8.3.4 report_phase()로 최종 결과 요약
- **8.4 기능 커버리지 기초**
  - 8.4.1 코드 커버리지 vs 기능 커버리지
  - 8.4.2 covergroup, coverpoint, bins
  - 8.4.3 cross coverage
  - 8.4.4 기본 커버리지 수집기 — 예제 8-2
- **8.5 커버리지 기반 검증 (CDV)**
  - 8.5.1 CDV 워크플로우
  - 8.5.2 커버리지 리포트 읽기
  - 8.5.3 커버리지 100%의 함정
- **8.6 종합: 자동 검증 테스트벤치**
  - 8.6.1 전체 구조
  - 8.6.2 완성 코드 — 예제 8-3
  - 8.6.3 실행 결과
  - 8.6.4 Ch.5 → Ch.8 진화 정리
- **8.7 체크포인트**
  - 셀프 체크 / 연습문제 / 다음 장 미리보기

---

### Chapter 9: 테스트 시나리오
**1,048줄 · SVG 3개 · 키워드: Targeted Sequence, Constrained Random, Error Injection, Regression**

- **9.1 왜 시나리오 설계가 중요한가**
  - 9.1.1 Ch.8 커버리지 갭 분석 — 87.5%의 원인
  - 9.1.2 시나리오 유형 3가지
  - 9.1.3 시나리오 설계 전략
- **9.2 타겟 시퀀스 — 빈틈 메우기**
  - 9.2.1 커버리지 갭에서 시퀀스로 — 역추적 사고법
  - 9.2.2 리셋 중 enable 시퀀스
  - 9.2.3 최대값 정지 시퀀스
  - 9.2.4 타겟 시퀀스 실행 결과
- **9.3 Constrained Random — 넓게 쓸기**
  - 9.3.1 왜 랜덤인가
  - 9.3.2 constraint 활용법 복습
  - 9.3.3 랜덤 시퀀스 구현
  - 9.3.4 Seed 관리와 재현성
- **9.4 에러 주입 시퀀스 — 견고함 검증**
  - 9.4.1 에러 주입이란
  - 9.4.2 코너 케이스 시퀀스
  - 9.4.3 경계값 시퀀스
  - 9.4.4 스코어보드와의 협력
- **9.5 테스트 클래스 관리**
  - 9.5.1 uvm_test 상속 패턴
  - 9.5.2 +UVM_TESTNAME으로 테스트 선택
  - 9.5.3 테스트 라이브러리와 Regression
  - 9.5.4 테스트별 커버리지 누적
- **9.6 종합: 커버리지 95% 달성**
  - 9.6.1 전체 시나리오 구성
  - 9.6.2 완성 코드 — 예제 9-1
  - 9.6.3 실행 결과 — 87.5% → 97.2%
  - 9.6.4 Ch.5 → Ch.9 진화 정리
- **9.7 체크포인트**
  - 셀프 체크 / 연습문제 / 다음 장 미리보기

---

### Chapter 10: 디버깅 기법
**1,277줄 · SVG 1개 · 키워드: UVM Message, Verbosity, Waveform, Factory Override, Error Analysis**

- **10.1 왜 체계적 디버깅인가**
  - 10.1.1 "파형만 보면 되지?" — 실무의 현실
  - 10.1.2 UVM 디버깅 도구 전체 맵
  - 10.1.3 디버깅 워크플로우
- **10.2 UVM 메시지 시스템**
  - 10.2.1 4가지 심각도 — UVM_INFO / WARNING / ERROR / FATAL
  - 10.2.2 Verbosity 레벨 — LOW / MEDIUM / HIGH / DEBUG
  - 10.2.3 명령줄 Verbosity 제어 (+UVM_VERBOSITY)
  - 10.2.4 컴포넌트별 Verbosity 제어
  - 10.2.5 메시지 필터링 실전 예제
- **10.3 파형 분석**
  - 10.3.1 VCD/FSDB 파일 생성
  - 10.3.2 파형 뷰어 — DVE, Verdi, GTKWave
  - 10.3.3 RTL 신호와 UVM 로그 타임스탬프 연결
  - 10.3.4 실전: MISMATCH 시점 파형 확인
- **10.4 Factory Override 디버깅**
  - 10.4.1 디버그 드라이버 교체 — 상세 로깅 버전
  - 10.4.2 런타임 컴포넌트 교환 패턴
  - 10.4.3 실전: 드라이버 vs 모니터 문제 분리
- **10.5 흔한 UVM 에러 메시지 해석**
  - 10.5.1 연결 에러 — "port is not connected"
  - 10.5.2 Factory 에러 — "create failed"
  - 10.5.3 Phase 에러 — "objection raised but not dropped"
  - 10.5.4 Randomization 에러 — "randomize() failed"
  - 10.5.5 Config DB 에러 — "config_db::get failed"
  - 10.5.6 에러 메시지 빠른 참조 표
- **10.6 실전: MISMATCH 원인 찾기**
  - 10.6.1 시나리오 — 의도적 버그 주입
  - 10.6.2 단계별 디버깅 프로세스
  - 10.6.3 원인 발견 및 수정
  - 10.6.4 수정 검증 — regression 확인
- **10.7 체크포인트**
  - 10.7.1 셀프 체크
  - 10.7.2 연습문제
  - 10.7.3 Part 2 마무리 & Part 3 미리보기

---

## Part 3: 완성하기

> 실무 프로토콜(APB) 기반 검증 환경을 구축하고, 면접/취업까지 준비합니다.

---

### Chapter 11: 인터페이스와 BFM
**1,207줄 · SVG 0개 · 키워드: APB Protocol, Clocking Block, Modport, BFM, Agent Assembly**

- **11.1 4비트 카운터를 졸업하며**
  - 11.1.1 Part 2에서 배운 것 — 구조는 같다
  - 11.1.2 실무 프로토콜이란? — APB 소개
  - 11.1.3 APB 프로토콜 기본 동작
- **11.2 SystemVerilog 인터페이스 심화**
  - 11.2.1 Clocking Block — 타이밍 안전한 신호 접근
  - 11.2.2 Modport — 드라이버/모니터 접근 제어
  - 11.2.3 APB 인터페이스 설계 (apb_if)
  - 11.2.4 counter_if vs apb_if 비교
- **11.3 APB Slave DUT**
  - 11.3.1 APB Slave Memory RTL
  - 11.3.2 APB 트랜잭션 정의 (apb_seq_item)
  - 11.3.3 tb_top — DUT와 인터페이스 연결
- **11.4 Bus Functional Model (BFM) 패턴**
  - 11.4.1 BFM이란? — 프로토콜 행위를 캡슐화
  - 11.4.2 APB Master Driver — Write/Read 프로토콜 구현
  - 11.4.3 APB Monitor — 프로토콜 관찰과 트랜잭션 추출
  - 11.4.4 counter_driver vs apb_driver 비교
- **11.5 APB 에이전트 조립**
  - 11.5.1 apb_agent — 드라이버, 모니터, 시퀀서 통합
  - 11.5.2 apb_env와 apb_base_test
  - 11.5.3 첫 APB 시뮬레이션 — Write & Read 테스트
- **11.6 실전: APB Write/Read 검증**
  - 11.6.1 APB 시퀀스 — 다양한 시나리오
  - 11.6.2 APB 스코어보드 — 메모리 모델 기반 비교
  - 11.6.3 실행 결과와 커버리지 확인
  - 11.6.4 Part 2 → Part 3 구조 비교표
- **11.7 체크포인트**
  - 11.7.1 셀프 체크
  - 11.7.2 연습문제
  - 11.7.3 이 챕터에서 배운 것
  - 11.7.4 다음 장 미리보기

---

### Chapter 12: 레지스터 모델 (RAL)
**1,194줄 · SVG 0개 · 키워드: uvm_reg, uvm_reg_block, Adapter, Predictor, Frontdoor, Backdoor**

- **12.1 왜 레지스터 모델이 필요한가**
  - 12.1.1 Ch.11 방식의 한계 — 수동 검증
  - 12.1.2 RAL이란? — 레지스터 추상화 계층
  - 12.1.3 RAL 아키텍처
- **12.2 RAL 구성 요소**
  - 12.2.1 uvm_reg_field — 비트 필드 정의
  - 12.2.2 uvm_reg — 레지스터 정의
  - 12.2.3 uvm_reg_block과 uvm_reg_map — 주소 매핑
  - 12.2.4 계층 구조 요약
- **12.3 APB Slave Memory 레지스터 모델**
  - 12.3.1 레지스터 사양 정의
  - 12.3.2 레지스터 클래스 구현
  - 12.3.3 레지스터 블록 구현
- **12.4 RAL과 APB 에이전트 연결**
  - 12.4.1 Adapter — 트랜잭션 변환기
  - 12.4.2 Predictor — 자동 미러링
  - 12.4.3 환경에 RAL 통합
- **12.5 RAL 기본 동작**
  - 12.5.1 Frontdoor 읽기/쓰기
  - 12.5.2 RAL 시퀀스 작성
  - 12.5.3 첫 RAL 시뮬레이션
- **12.6 내장 시퀀스와 백도어**
  - 12.6.1 uvm_reg_hw_reset_seq — 리셋 값 검증
  - 12.6.2 uvm_reg_bit_bash_seq — 비트 접근 검증
  - 12.6.3 Backdoor 접근 — DUT 직접 읽기/쓰기
  - 12.6.4 Ch.11 수동 검증 vs RAL 자동 검증 비교
  - 12.6.5 RAL 자주 하는 실수 Top 5
- **12.7 체크포인트**
  - 12.7.1 셀프 체크
  - 12.7.2 연습문제
  - 12.7.3 이 챕터에서 배운 것
  - 12.7.4 다음 장 미리보기

---

### Chapter 13: 고급 시퀀스
**1,471줄 · SVG 0개 · 키워드: Virtual Sequencer, Virtual Sequence, Sequence Library, Layered Sequence**

- **13.1 왜 고급 시퀀스가 필요한가**
  - 13.1.1 Ch.6 방식의 한계 — 단일 에이전트
  - 13.1.2 실무 SoC 검증 — 다중 에이전트 문제
  - 13.1.3 고급 시퀀스 로드맵
- **13.2 가상 시퀀서 (Virtual Sequencer)**
  - 13.2.1 가상 시퀀서란 — 오케스트라 지휘자
  - 13.2.2 가상 시퀀서 구현
  - 13.2.3 환경에 가상 시퀀서 통합
- **13.3 가상 시퀀스 (Virtual Sequence)**
  - 13.3.1 가상 시퀀스란 — 악보
  - 13.3.2 가상 시퀀스 구현
  - 13.3.3 p_sequencer로 시퀀서 접근
  - 13.3.4 첫 가상 시퀀스 시뮬레이션
- **13.4 시퀀스 라이브러리 (Sequence Library)**
  - 13.4.1 왜 시퀀스 라이브러리가 필요한가
  - 13.4.2 uvm_sequence_library 구현
  - 13.4.3 시퀀스 선택 모드
- **13.5 고급 시퀀스 패턴**
  - 13.5.1 계층적 시퀀스 (Layered Sequences)
  - 13.5.2 시퀀스와 config_db 연동
  - 13.5.3 시퀀스에서 RAL 사용
- **13.6 실전 통합: APB + RAL 가상 시퀀스**
  - 13.6.1 통합 환경 구성
  - 13.6.2 APB + RAL 조합 시나리오
  - 13.6.3 Ch.6 기본 시퀀스 vs Ch.13 고급 시퀀스 비교
  - 13.6.4 실무 시퀀스 전략 가이드
- **13.7 체크포인트**
  - 13.7.1 셀프 체크
  - 13.7.2 연습문제
  - 13.7.3 이 챕터에서 배운 것
  - 13.7.4 다음 장 미리보기

---

### Chapter 14: 검증 자동화
**1,211줄 · SVG 4개 · 키워드: Functional Coverage, SVA, Assertion, Coverage Closure**

- **14.1 왜 검증 자동화가 필요한가**
  - 14.1.1 "검증이 충분한가?" — 커버리지의 필요성
  - 14.1.2 "프로토콜을 위반했는가?" — 어서션의 필요성
  - 14.1.3 검증 자동화 아키텍처
- **14.2 기능 커버리지 기초**
  - 14.2.1 covergroup과 coverpoint
  - 14.2.2 bins — 값 분류하기
  - 14.2.3 cross — 교차 커버리지
  - 14.2.4 커버리지 옵션과 리포트
- **14.3 APB 커버리지 모델**
  - 14.3.1 APB 트랜잭션 커버리지 설계
  - 14.3.2 UVM 커버리지 컬렉터 구현
  - 14.3.3 환경에 커버리지 컬렉터 통합
- **14.4 SystemVerilog 어서션 (SVA)**
  - 14.4.1 즉시 어서션 (Immediate Assertion)
  - 14.4.2 동시 어서션 (Concurrent Assertion)
  - 14.4.3 시퀀스와 프로퍼티
- **14.5 APB 프로토콜 어서션**
  - 14.5.1 APB 프로토콜 규칙 정리
  - 14.5.2 어서션 모듈 구현
  - 14.5.3 어서션과 환경 연결
- **14.6 커버리지 클로저 전략**
  - 14.6.1 커버리지 리포트 분석
  - 14.6.2 커버리지 기반 테스트 전략
  - 14.6.3 Ch.11~14 검증 인프라 종합
  - 14.6.4 실무 커버리지/어서션 가이드
- **14.7 체크포인트**
  - 14.7.1 셀프 체크
  - 14.7.2 연습문제
  - 14.7.3 이 챕터에서 배운 것
  - 14.7.4 다음 장 미리보기

---

### Chapter 15: 면접 준비 & 포트폴리오
**1,586줄 · SVG 6개 · 키워드: 면접 질문, 코드 리뷰, GitHub 포트폴리오, 이력서, 취업 전략**

- **15.1 팹리스 검증 엔지니어 취업 로드맵**
  - 15.1.1 팹리스 검증팀의 하루
  - 15.1.2 채용 프로세스 이해하기
  - 15.1.3 신입 vs 경력의 기대치 차이
- **15.2 UVM 면접 빈출 질문 Top 30**
  - 15.2.1 기초 개념 (10문항)
  - 15.2.2 컴포넌트 & 아키텍처 (10문항)
  - 15.2.3 고급 주제 & 실무 (10문항)
- **15.3 코드 리뷰 면접 대비**
  - 15.3.1 "이 코드의 문제를 찾아라" 유형
  - 15.3.2 "이 환경을 개선해라" 유형
  - 15.3.3 라이브 코딩 팁
- **15.4 포트폴리오 프로젝트 구성**
  - 15.4.1 Ch.11~14 APB 프로젝트를 포트폴리오로
  - 15.4.2 GitHub 저장소 구조와 README
  - 15.4.3 문서화와 시연 가이드
- **15.5 이력서 & 자기소개서 전략**
  - 15.5.1 검증 엔지니어 이력서 작성법
  - 15.5.2 기술 키워드와 성과 표현
  - 15.5.3 자기소개서에서 UVM 경험 어필
- **15.6 실전 면접 시뮬레이션**
  - 15.6.1 1차 기술 면접 시뮬레이션
  - 15.6.2 2차 심층 면접 시뮬레이션
  - 15.6.3 면접 후 팔로업
- **15.7 체크포인트**
  - 15.7.1 셀프 체크
  - 15.7.2 연습문제
  - 15.7.3 이 챕터에서 배운 것
  - 15.7.4 전체 책 마무리 — Ch.1~15 학습 로드맵

---

## 부록: 전체 통계

| 항목 | 수치 |
|------|------|
| 총 챕터 수 | 15개 (3 Parts) |
| 총 분량 (Markdown) | 18,035줄 · 718.5 KB |
| 총 HTML 출력 | 1,828.7 KB |
| SVG 다이어그램 | 66개 |
| h2 섹션 (절) | 114개 |
| h3 서브섹션 (항) | 370개 |

### 챕터별 분량 상세

| 챕터 | 제목 | 줄 수 | MD (KB) | HTML (KB) | SVG |
|------|------|-------|---------|-----------|-----|
| Ch.1 | UVM 소개 | 944 | 39.4 | 116.0 | 8 |
| Ch.2 | 환경 설정 | 828 | 34.5 | 100.3 | 6 |
| Ch.3 | SystemVerilog 핵심 | 1,220 | 45.3 | 141.2 | 10 |
| Ch.4 | UVM 기본 컴포넌트 | 1,257 | 48.0 | 137.3 | 7 |
| Ch.5 | 첫 UVM 테스트벤치 | 1,146 | 44.3 | 109.4 | 4 |
| Ch.6 | 시퀀스 & 시퀀서 | 1,274 | 46.9 | 126.5 | 6 |
| Ch.7 | 드라이버 & 모니터 심화 | 1,182 | 41.6 | 111.9 | 4 |
| Ch.8 | 스코어보드 & 커버리지 | 1,190 | 50.2 | 115.0 | 7 |
| Ch.9 | 테스트 시나리오 | 1,048 | 39.4 | 91.0 | 3 |
| Ch.10 | 디버깅 기법 | 1,277 | 53.9 | 132.4 | 1 |
| Ch.11 | 인터페이스와 BFM | 1,207 | 48.2 | 116.5 | 0 |
| Ch.12 | 레지스터 모델 (RAL) | 1,194 | 52.4 | 115.8 | 0 |
| Ch.13 | 고급 시퀀스 | 1,471 | 58.9 | 137.2 | 0 |
| Ch.14 | 검증 자동화 | 1,211 | 49.5 | 126.6 | 4 |
| Ch.15 | 면접 준비 & 포트폴리오 | 1,586 | 66.1 | 151.5 | 6 |

### 학습 경로 가이드

```
[입문] Ch.1 → Ch.2 → Ch.3
         ↓
[기초] Ch.4 → Ch.5
         ↓
[심화] Ch.6 → Ch.7 → Ch.8 → Ch.9 → Ch.10
         ↓
[실무] Ch.11 → Ch.12 → Ch.13 → Ch.14
         ↓
[취업] Ch.15
```
