<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chapter 9: 테스트 시나리오 | 팹리스 검증 엔지니어가 되기 위한 UVM 완전정복</title>
  <style>
    /* =============================================
       UVM Book Publisher - Stylesheet
       Generated by Publisher Agent
       ============================================= */

    @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;600;700&display=swap');

    :root {
      --bg: #ffffff;
      --text: #1a1a2e;
      --accent: #10b981;
      --accent-light: #10b98118;
      --code-bg: #1e1e2e;
      --code-text: #cdd6f4;
      --border: #e2e8f0;
      --blockquote-bg: #f0f9ff;
      --blockquote-border: #3b82f6;
      --table-header: #1e293b;
      --table-stripe: #f8fafc;
      --warning-bg: #fef3c7;
      --warning-border: #f59e0b;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: 'Noto Sans KR', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      line-height: 1.85;
      color: var(--text);
      background: var(--bg);
      font-size: 16px;
    }

    /* === Reading Progress Bar === */
    .progress-bar {
      position: fixed;
      top: 0;
      left: 0;
      width: 0%;
      height: 3px;
      background: linear-gradient(90deg, var(--accent), #10b981cc);
      z-index: 9999;
      transition: width 0.1s;
    }

    /* === Cover Header === */
    .cover-header {
      background: linear-gradient(135deg, #10b98108, #10b98115);
      border-bottom: 3px solid var(--accent);
      padding: 32px 24px 24px;
      text-align: center;
      margin-bottom: 0;
    }
    .cover-part {
      display: inline-block;
      background: var(--accent);
      color: white;
      padding: 4px 16px;
      border-radius: 20px;
      font-size: 0.85em;
      font-weight: 600;
      letter-spacing: 0.5px;
      margin-bottom: 12px;
    }
    .cover-chapter-num {
      font-size: 2em;
      font-weight: 300;
      color: var(--accent);
      letter-spacing: 2px;
      opacity: 0.6;
    }

    /* === Main Content === */
    .content {
      max-width: 860px;
      margin: 0 auto;
      padding: 32px 24px 60px;
    }

    /* === TOC === */
    .toc {
      background: #f8fafc;
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 20px 28px;
      margin: 24px 0 32px;
    }
    .toc-title {
      font-size: 1.1em;
      color: var(--accent);
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 2px solid var(--border);
    }
    .toc ul { list-style: none; padding: 0; }
    .toc li { margin: 6px 0; }
    .toc li a {
      color: var(--text);
      text-decoration: none;
      font-weight: 500;
      font-size: 0.95em;
      padding: 4px 8px;
      border-radius: 4px;
      display: inline-block;
      transition: background 0.15s;
    }
    .toc li a:hover {
      background: var(--accent-light);
      color: var(--accent);
    }
    .toc li.toc-sub { padding-left: 24px; }
    .toc li.toc-sub a {
      font-weight: 400;
      font-size: 0.9em;
      color: #475569;
    }

    /* === Headings === */
    h1 {
      font-size: 2em;
      border-bottom: 3px solid var(--accent);
      padding-bottom: 12px;
      margin: 40px 0 20px;
      color: var(--text);
    }
    h1:first-child { margin-top: 0; }
    h2 {
      font-size: 1.5em;
      color: var(--accent);
      margin: 40px 0 16px;
      padding-bottom: 8px;
      border-bottom: 2px solid var(--border);
      scroll-margin-top: 16px;
    }
    h3 {
      font-size: 1.25em;
      margin: 28px 0 12px;
      color: #334155;
      scroll-margin-top: 16px;
    }
    h4 { font-size: 1.05em; margin: 20px 0 8px; color: #475569; }
    p { margin: 12px 0; }
    a { color: var(--accent); text-decoration: none; }
    a:hover { text-decoration: underline; }
    hr { border: none; border-top: 2px solid var(--border); margin: 32px 0; }
    strong { color: #1e293b; }
    img { max-width: 100%; border-radius: 8px; margin: 16px 0; }

    /* === Code Blocks === */
    pre {
      position: relative;
      background: var(--code-bg);
      border-radius: 12px;
      padding: 0;
      margin: 20px 0;
      overflow: hidden;
      box-shadow: 0 4px 16px rgba(0,0,0,0.12), 0 1px 4px rgba(0,0,0,0.08);
      border: 1px solid #313244;
    }
    pre::before {
      content: attr(data-lang);
      display: block;
      background: #313244;
      color: #a6adc8;
      padding: 8px 16px;
      font-size: 0.8em;
      font-family: 'Fira Code','JetBrains Mono',monospace;
      letter-spacing: 0.5px;
      border-bottom: 1px solid #45475a;
    }
    pre code {
      display: block;
      padding: 16px 20px;
      overflow-x: auto;
      font-family: 'Fira Code','JetBrains Mono','Cascadia Code','D2Coding',monospace;
      font-size: 0.88em;
      line-height: 1.75;
      tab-size: 4;
      color: var(--code-text);
    }
    pre code::-webkit-scrollbar { height: 6px; }
    pre code::-webkit-scrollbar-track { background: #1e1e2e; }
    pre code::-webkit-scrollbar-thumb { background: #45475a; border-radius: 3px; }

    code:not(pre code) {
      background: #f1f5f9;
      color: #be185d;
      padding: 2px 7px;
      border-radius: 5px;
      font-family: 'Fira Code','JetBrains Mono','D2Coding',monospace;
      font-size: 0.86em;
      border: 1px solid #e2e8f0;
    }

    /* Highlight.js Catppuccin */
    .hljs { background: transparent; color: #cdd6f4; }
    .hljs-keyword { color: #cba6f7; font-weight: bold; }
    .hljs-type { color: #f9e2af; }
    .hljs-string { color: #a6e3a1; }
    .hljs-number { color: #fab387; }
    .hljs-comment { color: #6c7086; font-style: italic; }
    .hljs-function, .hljs-title { color: #89b4fa; }
    .hljs-built_in { color: #f38ba8; }
    .hljs-variable { color: #cdd6f4; }
    .hljs-attr { color: #89dceb; }
    .hljs-meta { color: #f5c2e7; }
    .hljs-literal { color: #fab387; }

    /* === SVG Diagrams === */
    .svg-diagram {
      margin: 24px 0;
      padding: 20px;
      background: #fafbfc;
      border: 1px solid var(--border);
      border-radius: 12px;
      text-align: center;
      overflow-x: auto;
    }
    .svg-diagram svg { display: inline-block; }

    /* === Blockquotes === */
    blockquote {
      background: var(--blockquote-bg);
      border-left: 4px solid var(--blockquote-border);
      padding: 16px 20px;
      margin: 16px 0;
      border-radius: 0 8px 8px 0;
    }
    blockquote p:first-child { margin-top: 0; }
    blockquote p:last-child { margin-bottom: 0; }
    blockquote:has(strong:first-child) {
      background: var(--warning-bg);
      border-left-color: var(--warning-border);
    }

    /* === Tables === */
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 1px 4px rgba(0,0,0,0.06);
      border: 1px solid var(--border);
      font-size: 0.95em;
    }
    thead th {
      background: var(--table-header);
      color: white;
      padding: 12px 16px;
      text-align: left;
      font-weight: 600;
      font-size: 0.9em;
    }
    tbody td {
      padding: 10px 16px;
      border-bottom: 1px solid var(--border);
    }
    tbody tr:nth-child(even) { background: var(--table-stripe); }
    tbody tr:hover { background: var(--accent-light); }

    /* === Lists === */
    ul, ol { padding-left: 28px; margin: 12px 0; }
    li { margin: 6px 0; }
    li > ul, li > ol { margin: 4px 0; }

    /* === Details/Summary === */
    details {
      background: #f8fafc;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px 16px;
      margin: 12px 0;
    }
    details summary {
      cursor: pointer;
      font-weight: 600;
      color: var(--accent);
    }
    details[open] summary { margin-bottom: 8px; }

    /* === Plain code blocks === */
    pre:has(code:not(.hljs)) {
      background: #fafbfc;
      border: 2px solid var(--border);
      box-shadow: none;
    }
    pre:has(code:not(.hljs))::before {
      background: #f1f5f9;
      color: #64748b;
      border-bottom-color: var(--border);
    }
    pre:has(code:not(.hljs)) code { color: #334155; }

    /* === Chapter Navigation === */
    .chapter-nav {
      display: flex;
      justify-content: space-between;
      gap: 16px;
      margin: 40px 0 20px;
      padding-top: 24px;
      border-top: 2px solid var(--border);
    }
    .chapter-nav a {
      display: flex;
      flex-direction: column;
      padding: 14px 20px;
      border: 1px solid var(--border);
      border-radius: 10px;
      text-decoration: none;
      transition: all 0.2s;
      min-width: 200px;
    }
    .chapter-nav a:hover {
      border-color: var(--accent);
      background: var(--accent-light);
      text-decoration: none;
    }
    .nav-prev { align-items: flex-start; }
    .nav-next { align-items: flex-end; }
    .nav-label {
      font-size: 0.8em;
      color: #94a3b8;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .nav-title { font-weight: 600; color: var(--accent); margin-top: 2px; }

    /* === Footer === */
    .book-footer {
      text-align: center;
      padding: 20px;
      margin-top: 40px;
      border-top: 1px solid var(--border);
      color: #94a3b8;
      font-size: 0.85em;
    }

    /* === Back to Top === */
    .back-to-top {
      position: fixed;
      bottom: 24px;
      right: 24px;
      width: 44px;
      height: 44px;
      background: var(--accent);
      color: white;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      font-size: 20px;
      display: none;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      transition: opacity 0.3s;
      z-index: 100;
    }
    .back-to-top.visible { display: flex; }

    /* === Print === */
    @media print {
      .progress-bar, .back-to-top, .chapter-nav, .toc { display: none !important; }
      body { font-size: 11pt; }
      .content { max-width: 100%; padding: 0; }
      .cover-header { break-after: page; }
      pre { box-shadow: none; border: 2px solid #ccc; break-inside: avoid; }
      .svg-diagram { break-inside: avoid; border: 1px solid #ccc; }
      table { break-inside: avoid; }
      h2, h3 { break-after: avoid; }
    }

    /* === Responsive === */
    @media (max-width: 640px) {
      .content { padding: 16px 12px 40px; font-size: 15px; }
      h1 { font-size: 1.5em; }
      h2 { font-size: 1.25em; }
      pre code { font-size: 0.8em; padding: 12px; }
      thead th, tbody td { padding: 8px 10px; font-size: 0.88em; }
      .svg-diagram { padding: 10px; }
      .toc { padding: 14px 18px; }
      .chapter-nav { flex-direction: column; }
      .chapter-nav a { min-width: unset; }
      .nav-next { align-items: flex-start; }
      .cover-chapter-num { font-size: 1.5em; }
    }
  </style>
</head>
<body>
  <!-- Reading Progress Bar -->
  <div class="progress-bar" id="progressBar"></div>

  
<header class="cover-header">
  <div class="cover-part" style="--part-color: #10b981">
    <span class="cover-part-label">Part 2: 깊이 파기</span>
  </div>
  <div class="cover-chapter-num">Chapter 09</div>
</header>

  <div class="content">
    <nav class="toc">
<h2 class="toc-title">목차</h2>
<ul>
<li><a href="#9-1-왜-시나리오-설계가-중요한가">9.1 왜 시나리오 설계가 중요한가</a></li>
  <li class="toc-sub"><a href="#9-1-1-ch-8-커버리지-갭-분석-87-5-의-원인">9.1.1 Ch.8 커버리지 갭 분석 — 87.5%의 원인</a></li>
  <li class="toc-sub"><a href="#9-1-2-시나리오-유형-3가지">9.1.2 시나리오 유형 3가지</a></li>
  <li class="toc-sub"><a href="#9-1-3-시나리오-설계-전략">9.1.3 시나리오 설계 전략</a></li>
<li><a href="#9-2-타겟-시퀀스-빈틈-메우기">9.2 타겟 시퀀스 — 빈틈 메우기</a></li>
  <li class="toc-sub"><a href="#9-2-1-커버리지-갭에서-시퀀스로-역추적-사고법">9.2.1 커버리지 갭에서 시퀀스로 — 역추적 사고법</a></li>
  <li class="toc-sub"><a href="#9-2-2-리셋-중-enable-시퀀스">9.2.2 리셋 중 enable 시퀀스</a></li>
  <li class="toc-sub"><a href="#9-2-3-최대값-정지-시퀀스">9.2.3 최대값 정지 시퀀스</a></li>
  <li class="toc-sub"><a href="#9-2-4-타겟-시퀀스-실행-결과">9.2.4 타겟 시퀀스 실행 결과</a></li>
<li><a href="#9-3-constrained-random-넓게-쓸기">9.3 Constrained Random — 넓게 쓸기</a></li>
  <li class="toc-sub"><a href="#9-3-1-왜-랜덤인가">9.3.1 왜 랜덤인가</a></li>
  <li class="toc-sub"><a href="#9-3-2-constraint-활용법-복습">9.3.2 constraint 활용법 복습</a></li>
  <li class="toc-sub"><a href="#9-3-3-랜덤-시퀀스-구현">9.3.3 랜덤 시퀀스 구현</a></li>
  <li class="toc-sub"><a href="#9-3-4-seed-관리와-재현성">9.3.4 Seed 관리와 재현성</a></li>
<li><a href="#9-4-에러-주입-시퀀스-견고함-검증">9.4 에러 주입 시퀀스 — 견고함 검증</a></li>
  <li class="toc-sub"><a href="#9-4-1-에러-주입이란">9.4.1 에러 주입이란</a></li>
  <li class="toc-sub"><a href="#9-4-2-코너-케이스-시퀀스">9.4.2 코너 케이스 시퀀스</a></li>
  <li class="toc-sub"><a href="#9-4-3-경계값-시퀀스">9.4.3 경계값 시퀀스</a></li>
  <li class="toc-sub"><a href="#9-4-4-스코어보드와의-협력">9.4.4 스코어보드와의 협력</a></li>
<li><a href="#9-5-테스트-클래스-관리">9.5 테스트 클래스 관리</a></li>
  <li class="toc-sub"><a href="#9-5-1-uvm-test-상속-패턴">9.5.1 uvm_test 상속 패턴</a></li>
  <li class="toc-sub"><a href="#9-5-2-uvm-testname으로-테스트-선택">9.5.2 +UVM_TESTNAME으로 테스트 선택</a></li>
  <li class="toc-sub"><a href="#9-5-3-테스트-라이브러리와-regression">9.5.3 테스트 라이브러리와 Regression</a></li>
  <li class="toc-sub"><a href="#9-5-4-테스트별-커버리지-누적">9.5.4 테스트별 커버리지 누적</a></li>
<li><a href="#9-6-종합-커버리지-95-달성">9.6 종합: 커버리지 95% 달성</a></li>
  <li class="toc-sub"><a href="#9-6-1-전체-시나리오-구성">9.6.1 전체 시나리오 구성</a></li>
  <li class="toc-sub"><a href="#9-6-2-완성-코드-예제-9-1">9.6.2 완성 코드 — 예제 9-1</a></li>
  <li class="toc-sub"><a href="#9-6-3-실행-결과-87-5-97-2">9.6.3 실행 결과 — 87.5% → 97.2%</a></li>
  <li class="toc-sub"><a href="#9-6-4-ch-5-ch-9-진화-정리">9.6.4 Ch.5 → Ch.9 진화 정리</a></li>
<li><a href="#9-7-체크포인트">9.7 체크포인트</a></li>
  <li class="toc-sub"><a href="#셀프-체크">셀프 체크</a></li>
  <li class="toc-sub"><a href="#연습문제">연습문제</a></li>
  <li class="toc-sub"><a href="#다음-장-미리보기">다음 장 미리보기</a></li>
</ul>
</nav>
    <h1>Chapter 9: 테스트 시나리오</h1>
<blockquote>
<p><strong>이 챕터의 목표</strong>: Ch.8에서 87.5%에 머물렀던 커버리지를 <strong>타겟 시퀀스, 랜덤 시퀀스, 에러 주입 시퀀스</strong>로 95% 이상 달성합니다. CDV(Coverage-Driven Verification)의 실전을 체험합니다.</p>
</blockquote>
<blockquote>
<p><strong>선수 지식</strong>: Chapter 8 (스코어보드, 기능 커버리지, CDV 워크플로우)</p>
</blockquote>
<hr>
<h2 id="9-1-왜-시나리오-설계가-중요한가">9.1 왜 시나리오 설계가 중요한가</h2>
<blockquote>
<p><strong>이 절의 목표</strong>: Ch.8의 커버리지 갭을 분석하고, 시나리오 설계 전략을 이해합니다.</p>
</blockquote>
<h3 id="9-1-1-ch-8-커버리지-갭-분석-87-5-의-원인">9.1.1 Ch.8 커버리지 갭 분석 — 87.5%의 원인</h3>
<p>Ch.8에서 우리는 스코어보드와 커버리지를 구축하고 시뮬레이션을 실행했습니다. 결과는:</p>
<pre><code>Overall: 87.5%
  rst_n : 100.0%    ✅ 개별 bin 모두 hit
  enable: 100.0%    ✅ 개별 bin 모두 hit
  count : 100.0%    ✅ 0/low/high/max 모두 hit
  cross(rst,en)   : 75.0%  ❌ rst_n=0,en=1 미달
  cross(en,count) : 75.0%  ❌ en=0,count=max 미달
</code></pre><p><strong>왜 87.5%인가?</strong> 개별 coverpoint는 100%지만 **조합(cross)**이 부족합니다.</p>
<table>
<thead>
<tr>
<th>미달 조합</th>
<th>의미</th>
<th>왜 놓쳤나?</th>
</tr>
</thead>
<tbody><tr>
<td><code>rst_n=0, enable=1</code></td>
<td>리셋 중에 enable 활성화</td>
<td>리셋 시퀀스에서 항상 enable=0으로 고정</td>
</tr>
<tr>
<td><code>enable=0, count=15</code></td>
<td>최대값에서 카운터 정지</td>
<td>오버플로우 시퀀스에서 항상 enable=1로 고정</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>핵심 교훈</strong>: 커버리지 갭은 <strong>시나리오 부족</strong>입니다. 개별 기능을 테스트했지만, 기능 간 <strong>조합</strong>을 테스트하지 못했습니다.</p>
</blockquote>
<h3 id="9-1-2-시나리오-유형-3가지">9.1.2 시나리오 유형 3가지</h3>
<p>시나리오를 체계적으로 설계하기 위해 3가지 유형으로 분류합니다:</p>
<table>
<thead>
<tr>
<th>유형</th>
<th>목적</th>
<th>비유</th>
<th>커버리지 역할</th>
</tr>
</thead>
<tbody><tr>
<td><strong>타겟 시퀀스</strong></td>
<td>특정 미달 bin 해결</td>
<td>빈틈 메우기</td>
<td>cross 갭 해소</td>
</tr>
<tr>
<td><strong>랜덤 시퀀스</strong></td>
<td>넓은 범위 자동 탐색</td>
<td>넓게 쓸기</td>
<td>전체 bin 고르게 hit</td>
</tr>
<tr>
<td><strong>에러 주입</strong></td>
<td>비정상 입력 검증</td>
<td>견고함 검증</td>
<td>경계값/코너 케이스</td>
</tr>
</tbody></table>
<h3 id="9-1-3-시나리오-설계-전략">9.1.3 시나리오 설계 전략</h3>

<div class="svg-diagram">
<svg viewBox="0 0 620 380" xmlns="http://www.w3.org/2000/svg" style="max-width:620px;width:100%">
  <defs>
    <marker id="ah" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto"><polygon points="0 0, 8 2.8, 0 5.6" fill="#64748b"/></marker>
    <marker id="ah-accent" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto"><polygon points="0 0, 8 2.8, 0 5.6" fill="#2563eb"/></marker>
    <marker id="ah-green" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto"><polygon points="0 0, 8 2.8, 0 5.6" fill="#10b981"/></marker>
    <filter id="sh" x="-5%" y="-5%" width="115%" height="115%"><feDropShadow dx="0" dy="2" stdDeviation="3" flood-color="#000" flood-opacity="0.1"/></filter>
  </defs>

  <!-- Title -->
  <text x="310" y="28" text-anchor="middle" font-family="'Noto Sans KR',sans-serif" font-size="17" font-weight="bold" fill="#2563eb">시나리오 설계 전략</text>

  <!-- Step 1: 커버리지 갭 분석 -->
  <rect x="170" y="48" width="280" height="52" rx="10" fill="#fef2f2" stroke="#ef4444" stroke-width="2" filter="url(#sh)"/>
  <text x="310" y="70" text-anchor="middle" font-family="'Noto Sans KR',sans-serif" font-size="13" font-weight="bold" fill="#ef4444">커버리지 갭 분석</text>
  <text x="310" y="88" text-anchor="middle" font-family="'Noto Sans KR',sans-serif" font-size="11" fill="#64748b">87.5% — 미달 bin 확인</text>

  <line x1="310" y1="100" x2="310" y2="128" stroke="#64748b" stroke-width="1.5" marker-end="url(#ah)"/>

  <!-- Step 2: 시퀀스 설계 (outer box) -->
  <rect x="40" y="130" width="540" height="130" rx="12" fill="#f8fafc" stroke="#94a3b8" stroke-width="2"/>
  <text x="310" y="155" text-anchor="middle" font-family="'Noto Sans KR',sans-serif" font-size="14" font-weight="bold" fill="#1e293b">시퀀스 설계</text>

  <!-- 3 sequence types -->
  <rect x="65" y="170" width="150" height="72" rx="10" fill="#eff6ff" stroke="#2563eb" stroke-width="2" filter="url(#sh)"/>
  <text x="140" y="197" text-anchor="middle" font-family="'Noto Sans KR',sans-serif" font-size="13" font-weight="bold" fill="#2563eb">타겟</text>
  <text x="140" y="218" text-anchor="middle" font-family="'Noto Sans KR',sans-serif" font-size="11" fill="#64748b">(빈틈 메우기)</text>

  <rect x="235" y="170" width="150" height="72" rx="10" fill="#ecfdf5" stroke="#10b981" stroke-width="2" filter="url(#sh)"/>
  <text x="310" y="197" text-anchor="middle" font-family="'Noto Sans KR',sans-serif" font-size="13" font-weight="bold" fill="#10b981">랜덤</text>
  <text x="310" y="218" text-anchor="middle" font-family="'Noto Sans KR',sans-serif" font-size="11" fill="#64748b">(넓게 쓸기)</text>

  <rect x="405" y="170" width="150" height="72" rx="10" fill="#f5f3ff" stroke="#7c3aed" stroke-width="2" filter="url(#sh)"/>
  <text x="480" y="197" text-anchor="middle" font-family="'Noto Sans KR',sans-serif" font-size="13" font-weight="bold" fill="#7c3aed">에러 주입</text>
  <text x="480" y="218" text-anchor="middle" font-family="'Noto Sans KR',sans-serif" font-size="11" fill="#64748b">(견고함 검증)</text>

  <line x1="310" y1="260" x2="310" y2="290" stroke="#64748b" stroke-width="1.5" marker-end="url(#ah)"/>

  <!-- Step 3: 결과 -->
  <rect x="120" y="293" width="380" height="56" rx="25" fill="#ecfdf5" stroke="#10b981" stroke-width="3" filter="url(#sh)"/>
  <text x="310" y="318" text-anchor="middle" font-family="'Fira Code',monospace" font-size="13" font-weight="bold" fill="#065f46">Scoreboard: PASS</text>
  <text x="310" y="338" text-anchor="middle" font-family="'Fira Code',monospace" font-size="13" font-weight="bold" fill="#065f46">Coverage: 97%+</text>
</svg>
</div><hr>
<h2 id="9-2-타겟-시퀀스-빈틈-메우기">9.2 타겟 시퀀스 — 빈틈 메우기</h2>
<blockquote>
<p><strong>이 절의 목표</strong>: 커버리지 리포트에서 미달 bin을 찾고, 해당 bin을 정확히 hit하는 타겟 시퀀스를 작성합니다.</p>
</blockquote>
<h3 id="9-2-1-커버리지-갭에서-시퀀스로-역추적-사고법">9.2.1 커버리지 갭에서 시퀀스로 — 역추적 사고법</h3>
<p>타겟 시퀀스 설계는 <strong>역추적(Backward Tracing)</strong> 사고법입니다:</p>
<pre><code>미달 bin 확인 → 어떤 입력이 필요한가? → 시퀀스로 구현
</code></pre><p><strong>예시: <code>rst_n=0, enable=1</code> 미달</strong></p>
<ol>
<li><strong>bin</strong>: cross(rst_n, enable)에서 <code>rst_n=0, enable=1</code> 조합</li>
<li><strong>필요 입력</strong>: rst_n=0이면서 동시에 enable=1인 트랜잭션</li>
<li><strong>시퀀스</strong>: 리셋 중에 enable을 1로 설정하는 시퀀스</li>
</ol>
<blockquote>
<p><strong>실무 이야기</strong>: 팹리스에서 커버리지 클로저(Coverage Closure) 미팅을 하면, 미달 bin 목록을 놓고 &quot;이 bin을 hit하려면 어떤 시나리오가 필요한가?&quot;를 역추적합니다. 이것이 검증 엔지니어의 핵심 역량입니다.</p>
</blockquote>
<h3 id="9-2-2-리셋-중-enable-시퀀스">9.2.2 리셋 중 enable 시퀀스</h3>
<p>첫 번째 미달: <code>rst_n=0, enable=1</code> 조합</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// ===== 타겟 시퀀스 1: 리셋 중 enable 활성화 =====</span>
<span class="hljs-keyword">class</span> counter_rst_with_en_seq <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(counter_seq_item)</span>;
  `uvm_object_utils(counter_rst_with_en_seq)

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;counter_rst_with_en_seq&quot;</span>);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();
    counter_seq_item item;

    `uvm_info(get_type_name(), <span class="hljs-string">&quot;=== Target: rst_n=0, enable=1 ===&quot;</span>, UVM_LOW)

    <span class="hljs-comment">// ⭐ 핵심: 리셋 활성화 상태에서 enable=1</span>
    <span class="hljs-keyword">repeat</span> (<span class="hljs-number">5</span>) <span class="hljs-keyword">begin</span>
      item = counter_seq_item::type_id::create(<span class="hljs-string">&quot;item&quot;</span>);
      start_item(item);
      item<span class="hljs-variable">.rst_n</span>  = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 리셋 활성화</span>
      item<span class="hljs-variable">.enable</span> = <span class="hljs-number">1</span>;    <span class="hljs-comment">// ⭐ enable도 동시 활성화!</span>
      finish_item(item);
    <span class="hljs-keyword">end</span>

    <span class="hljs-comment">// 리셋 해제 후 정상 동작 확인</span>
    <span class="hljs-keyword">repeat</span> (<span class="hljs-number">3</span>) <span class="hljs-keyword">begin</span>
      item = counter_seq_item::type_id::create(<span class="hljs-string">&quot;item&quot;</span>);
      start_item(item);
      item<span class="hljs-variable">.rst_n</span>  = <span class="hljs-number">1</span>;
      item<span class="hljs-variable">.enable</span> = <span class="hljs-number">1</span>;
      finish_item(item);
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>
</code></pre><p><strong>이 시퀀스가 해결하는 것:</strong></p>
<ul>
<li><code>cross(rst_n=0, enable=1)</code> bin → <strong>hit!</strong></li>
<li>DUT가 리셋 중에 enable이 들어와도 count=0을 유지하는지 검증</li>
</ul>
<h3 id="9-2-3-최대값-정지-시퀀스">9.2.3 최대값 정지 시퀀스</h3>
<p>두 번째 미달: <code>enable=0, count=15</code> 조합</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// ===== 타겟 시퀀스 2: count=15에서 enable 비활성화 =====</span>
<span class="hljs-keyword">class</span> counter_max_hold_seq <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(counter_seq_item)</span>;
  `uvm_object_utils(counter_max_hold_seq)

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;counter_max_hold_seq&quot;</span>);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();
    counter_seq_item item;

    `uvm_info(get_type_name(), <span class="hljs-string">&quot;=== Target: enable=0 at count=15 ===&quot;</span>, UVM_LOW)

    <span class="hljs-comment">// Step 1: 리셋</span>
    <span class="hljs-keyword">repeat</span> (<span class="hljs-number">2</span>) <span class="hljs-keyword">begin</span>
      item = counter_seq_item::type_id::create(<span class="hljs-string">&quot;item&quot;</span>);
      start_item(item);
      item<span class="hljs-variable">.rst_n</span>  = <span class="hljs-number">0</span>;
      item<span class="hljs-variable">.enable</span> = <span class="hljs-number">0</span>;
      finish_item(item);
    <span class="hljs-keyword">end</span>

    <span class="hljs-comment">// Step 2: 카운터를 15까지 증가 (15 클럭 필요)</span>
    <span class="hljs-keyword">repeat</span> (<span class="hljs-number">16</span>) <span class="hljs-keyword">begin</span>
      item = counter_seq_item::type_id::create(<span class="hljs-string">&quot;item&quot;</span>);
      start_item(item);
      item<span class="hljs-variable">.rst_n</span>  = <span class="hljs-number">1</span>;
      item<span class="hljs-variable">.enable</span> = <span class="hljs-number">1</span>;    <span class="hljs-comment">// 계속 카운트</span>
      finish_item(item);
    <span class="hljs-keyword">end</span>

    <span class="hljs-comment">// ⭐ Step 3: count=15 상태에서 enable 비활성화</span>
    <span class="hljs-keyword">repeat</span> (<span class="hljs-number">3</span>) <span class="hljs-keyword">begin</span>
      item = counter_seq_item::type_id::create(<span class="hljs-string">&quot;item&quot;</span>);
      start_item(item);
      item<span class="hljs-variable">.rst_n</span>  = <span class="hljs-number">1</span>;
      item<span class="hljs-variable">.enable</span> = <span class="hljs-number">0</span>;    <span class="hljs-comment">// ⭐ 정지! count=15 유지</span>
      finish_item(item);
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>
</code></pre><p><strong>이 시퀀스가 해결하는 것:</strong></p>
<ul>
<li><code>cross(enable=0, count=max)</code> bin → <strong>hit!</strong></li>
<li>카운터가 최대값에서 정지 상태를 올바르게 유지하는지 검증</li>
</ul>
<h3 id="9-2-4-타겟-시퀀스-실행-결과">9.2.4 타겟 시퀀스 실행 결과</h3>
<p>타겟 시퀀스 2개를 추가하고 실행하면:</p>
<pre><code>Before (Ch.8):
  cross(rst,en)   : 75.0%   ← rst_n=0,en=1 미달
  cross(en,count) : 75.0%   ← en=0,count=max 미달
  Overall         : 87.5%

After (타겟 시퀀스 추가):
  cross(rst,en)   : 100.0%  ✅ rst_n=0,en=1 hit!
  cross(en,count) : 100.0%  ✅ en=0,count=max hit!
  Overall         : 95.8%   ✅ 목표 달성!
</code></pre><blockquote>
<p><strong>핵심</strong>: 타겟 시퀀스 <strong>2개</strong>만으로 커버리지가 87.5% → 95.8%로 급등했습니다. 이것이 CDV 역추적 사고법의 위력입니다.</p>
</blockquote>
<hr>
<h2 id="9-3-constrained-random-넓게-쓸기">9.3 Constrained Random — 넓게 쓸기</h2>
<blockquote>
<p><strong>이 절의 목표</strong>: Constrained Random 검증으로 사람이 생각하지 못하는 시나리오를 자동으로 탐색합니다.</p>
</blockquote>
<h3 id="9-3-1-왜-랜덤인가">9.3.1 왜 랜덤인가</h3>
<p>타겟 시퀀스는 <strong>알려진 빈틈</strong>을 메웁니다. 하지만 <strong>모르는 빈틈</strong>은?</p>
<table>
<thead>
<tr>
<th>검증 방법</th>
<th>장점</th>
<th>한계</th>
</tr>
</thead>
<tbody><tr>
<td>타겟 시퀀스</td>
<td>정확한 bin hit</td>
<td>사람이 빈틈을 찾아야 함</td>
</tr>
<tr>
<td><strong>랜덤 시퀀스</strong></td>
<td><strong>자동으로 다양한 조합 탐색</strong></td>
<td>특정 bin에 집중 불가</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>실무 규칙</strong>: 팹리스 검증에서는 타겟 시퀀스(30%)와 랜덤 시퀀스(70%)를 조합합니다. 랜덤이 기본, 미달은 타겟으로 보완합니다.</p>
</blockquote>
<h3 id="9-3-2-constraint-활용법-복습">9.3.2 constraint 활용법 복습</h3>
<p>Ch.3에서 배운 constraint 문법을 실전에 적용합니다:</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-keyword">class</span> counter_seq_item <span class="hljs-keyword">extends</span> uvm_sequence_item;
  <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span>       rst_n;
  <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span>       enable;
  <span class="hljs-keyword">logic</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>]    count;

  <span class="hljs-comment">// ⭐ 기본 제약 — 리셋 빈도 낮게, enable 빈도 높게</span>
  <span class="hljs-keyword">constraint</span> c_default {
    rst_n <span class="hljs-keyword">dist</span> {<span class="hljs-number">0</span> := <span class="hljs-number">10</span>, <span class="hljs-number">1</span> := <span class="hljs-number">90</span>};   <span class="hljs-comment">// 리셋 10%, 정상 90%</span>
    enable <span class="hljs-keyword">dist</span> {<span class="hljs-number">0</span> := <span class="hljs-number">20</span>, <span class="hljs-number">1</span> := <span class="hljs-number">80</span>};  <span class="hljs-comment">// 비활성 20%, 활성 80%</span>
  }
<span class="hljs-keyword">endclass</span>
</code></pre><p><strong>주요 constraint 문법:</strong></p>
<table>
<thead>
<tr>
<th>문법</th>
<th>용도</th>
<th>예시</th>
</tr>
</thead>
<tbody><tr>
<td><code>dist</code></td>
<td>값 분포 제어</td>
<td><code>rst_n dist {0 := 10, 1 := 90}</code></td>
</tr>
<tr>
<td><code>inside</code></td>
<td>범위 지정</td>
<td><code>value inside {[0:15]}</code></td>
</tr>
<tr>
<td><code>if-else</code></td>
<td>조건부 제약</td>
<td><code>if (mode == 1) enable == 1</code></td>
</tr>
<tr>
<td><code>solve...before</code></td>
<td>순서 제어</td>
<td><code>solve rst_n before enable</code></td>
</tr>
</tbody></table>
<h3 id="9-3-3-랜덤-시퀀스-구현">9.3.3 랜덤 시퀀스 구현</h3>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// ===== 랜덤 시퀀스: 다양한 조합 자동 탐색 =====</span>
<span class="hljs-keyword">class</span> counter_random_seq <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(counter_seq_item)</span>;
  `uvm_object_utils(counter_random_seq)

  <span class="hljs-keyword">int</span> num_transactions = <span class="hljs-number">100</span>;

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;counter_random_seq&quot;</span>);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();
    counter_seq_item item;

    `uvm_info(get_type_name(),
      <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;=== Random: %0d transactions ===&quot;</span>, num_transactions), UVM_LOW)

    <span class="hljs-keyword">repeat</span> (num_transactions) <span class="hljs-keyword">begin</span>
      item = counter_seq_item::type_id::create(<span class="hljs-string">&quot;item&quot;</span>);
      start_item(item);
      <span class="hljs-keyword">if</span> (!item<span class="hljs-variable">.randomize</span>())
        `uvm_fatal(get_type_name(), <span class="hljs-string">&quot;Randomization failed!&quot;</span>)
      finish_item(item);
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>
</code></pre><p><strong>inline constraint로 분포 조절:</strong></p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// 리셋 빈도를 높인 랜덤 시퀀스</span>
<span class="hljs-keyword">class</span> counter_random_rst_heavy_seq <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(counter_seq_item)</span>;
  `uvm_object_utils(counter_random_rst_heavy_seq)

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;counter_random_rst_heavy_seq&quot;</span>);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();
    counter_seq_item item;

    <span class="hljs-keyword">repeat</span> (<span class="hljs-number">50</span>) <span class="hljs-keyword">begin</span>
      item = counter_seq_item::type_id::create(<span class="hljs-string">&quot;item&quot;</span>);
      start_item(item);
      <span class="hljs-comment">// ⭐ inline constraint — 리셋 빈도 50%로 증가</span>
      <span class="hljs-keyword">if</span> (!item<span class="hljs-variable">.randomize</span>() <span class="hljs-keyword">with</span> {
        rst_n <span class="hljs-keyword">dist</span> {<span class="hljs-number">0</span> := <span class="hljs-number">50</span>, <span class="hljs-number">1</span> := <span class="hljs-number">50</span>};
      })
        `uvm_fatal(get_type_name(), <span class="hljs-string">&quot;Randomization failed!&quot;</span>)
      finish_item(item);
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>
</code></pre><blockquote>
<p><strong><code>with</code> 절</strong>: <code>randomize() with { ... }</code>는 트랜잭션의 기본 constraint를 <strong>오버라이드</strong>하지 않고 <strong>추가</strong> 제약을 겁니다. 기존 제약과 충돌하면 <code>randomize()</code>가 실패합니다.</p>
</blockquote>
<blockquote>
<p><strong>실무 팁</strong>: 실무에서 랜덤 시퀀스는 두 가지로 구분합니다:</p>
<ul>
<li><strong>리셋 제외 랜덤</strong>: <code>rst_n = 1</code> 고정, enable만 랜덤 → 정상 동작 범위 탐색 (가장 많이 사용)</li>
<li><strong>완전 랜덤</strong>: rst_n도 enable도 모두 랜덤 → 리셋 포함 코너 케이스 탐색</li>
</ul>
<p>보통 리셋 제외 랜덤을 기본으로 하고, 리셋 관련 커버리지 갭은 타겟 시퀀스로 메웁니다.</p>
</blockquote>
<h3 id="9-3-4-seed-관리와-재현성">9.3.4 Seed 관리와 재현성</h3>
<p>랜덤 시뮬레이션의 핵심: <strong>같은 Seed → 같은 결과</strong></p>
<pre><code class="hljs language-bash"><span class="hljs-comment"># 기본 실행 (랜덤 seed)</span>
simv +UVM_TESTNAME=counter_random_test

<span class="hljs-comment"># 특정 seed로 재현</span>
simv +UVM_TESTNAME=counter_random_test +ntb_random_seed=12345

<span class="hljs-comment"># EDA Playground에서는</span>
<span class="hljs-comment"># Run Options에 +ntb_random_seed=12345 추가</span>
</code></pre><table>
<thead>
<tr>
<th>시뮬레이터</th>
<th>Seed 옵션</th>
</tr>
</thead>
<tbody><tr>
<td>VCS</td>
<td><code>+ntb_random_seed=값</code></td>
</tr>
<tr>
<td>Questa</td>
<td><code>-sv_seed 값</code></td>
</tr>
<tr>
<td>Xcelium</td>
<td><code>-svseed 값</code></td>
</tr>
</tbody></table>
<blockquote>
<p><strong>실무 규칙</strong>: 실패한 테스트의 seed를 반드시 기록합니다. 버그 수정 후 같은 seed로 재실행하여 수정을 검증합니다. 이를 <strong>regression</strong>이라 합니다.</p>
</blockquote>
<p><strong>시뮬레이션 로그에서 seed 찾기:</strong></p>
<pre><code># VCS 로그 예시
Chronologic VCS simulator...
random seed = 1708012345
</code></pre><hr>
<h2 id="9-4-에러-주입-시퀀스-견고함-검증">9.4 에러 주입 시퀀스 — 견고함 검증</h2>
<blockquote>
<p><strong>이 절의 목표</strong>: 비정상 입력으로 DUT의 견고함을 검증하고, 스코어보드와 협력하여 에러 상황을 올바르게 처리합니다.</p>
</blockquote>
<h3 id="9-4-1-에러-주입이란">9.4.1 에러 주입이란</h3>
<p>정상적인 사용법만 테스트하면 충분할까? 실제 칩은 예상치 못한 상황에 놓입니다:</p>
<table>
<thead>
<tr>
<th>상황</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>빠른 리셋 전환</td>
<td>리셋을 1~2 클럭만 넣었다 빼기</td>
</tr>
<tr>
<td>동시 전환</td>
<td>rst_n과 enable이 같은 클럭에 변경</td>
</tr>
<tr>
<td>연속 리셋</td>
<td>리셋 해제 없이 계속 리셋</td>
</tr>
<tr>
<td>경계값 반복</td>
<td>count=15 ↔ 0 경계를 빠르게 오가기</td>
</tr>
</tbody></table>
<h3 id="9-4-2-코너-케이스-시퀀스">9.4.2 코너 케이스 시퀀스</h3>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// ===== 에러 주입 1: 빠른 리셋 토글 =====</span>
<span class="hljs-keyword">class</span> counter_rapid_reset_seq <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(counter_seq_item)</span>;
  `uvm_object_utils(counter_rapid_reset_seq)

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;counter_rapid_reset_seq&quot;</span>);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();
    counter_seq_item item;

    `uvm_info(get_type_name(), <span class="hljs-string">&quot;=== Error Injection: Rapid Reset Toggle ===&quot;</span>, UVM_LOW)

    <span class="hljs-comment">// 빠른 리셋 토글 (1클럭 리셋 → 1클럭 해제 → 반복)</span>
    <span class="hljs-keyword">repeat</span> (<span class="hljs-number">10</span>) <span class="hljs-keyword">begin</span>
      <span class="hljs-comment">// 리셋 활성화 (1 클럭)</span>
      item = counter_seq_item::type_id::create(<span class="hljs-string">&quot;item&quot;</span>);
      start_item(item);
      item<span class="hljs-variable">.rst_n</span>  = <span class="hljs-number">0</span>;
      item<span class="hljs-variable">.enable</span> = <span class="hljs-number">1</span>;
      finish_item(item);

      <span class="hljs-comment">// 리셋 해제 (1 클럭)</span>
      item = counter_seq_item::type_id::create(<span class="hljs-string">&quot;item&quot;</span>);
      start_item(item);
      item<span class="hljs-variable">.rst_n</span>  = <span class="hljs-number">1</span>;
      item<span class="hljs-variable">.enable</span> = <span class="hljs-number">1</span>;
      finish_item(item);
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>
</code></pre><h3 id="9-4-3-경계값-시퀀스">9.4.3 경계값 시퀀스</h3>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// ===== 에러 주입 2: 오버플로우 경계 반복 =====</span>
<span class="hljs-keyword">class</span> counter_boundary_seq <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(counter_seq_item)</span>;
  `uvm_object_utils(counter_boundary_seq)

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;counter_boundary_seq&quot;</span>);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();
    counter_seq_item item;

    `uvm_info(get_type_name(), <span class="hljs-string">&quot;=== Error Injection: Boundary Stress ===&quot;</span>, UVM_LOW)

    <span class="hljs-comment">// 3회 오버플로우 반복</span>
    <span class="hljs-keyword">repeat</span> (<span class="hljs-number">3</span>) <span class="hljs-keyword">begin</span>
      <span class="hljs-comment">// 리셋으로 초기화</span>
      item = counter_seq_item::type_id::create(<span class="hljs-string">&quot;item&quot;</span>);
      start_item(item);
      item<span class="hljs-variable">.rst_n</span> = <span class="hljs-number">0</span>;  item<span class="hljs-variable">.enable</span> = <span class="hljs-number">0</span>;
      finish_item(item);

      <span class="hljs-comment">// 0 → 15 → 0 (17 클럭으로 1회 오버플로우)</span>
      <span class="hljs-keyword">repeat</span> (<span class="hljs-number">17</span>) <span class="hljs-keyword">begin</span>
        item = counter_seq_item::type_id::create(<span class="hljs-string">&quot;item&quot;</span>);
        start_item(item);
        item<span class="hljs-variable">.rst_n</span> = <span class="hljs-number">1</span>;  item<span class="hljs-variable">.enable</span> = <span class="hljs-number">1</span>;
        finish_item(item);
      <span class="hljs-keyword">end</span>

      <span class="hljs-comment">// ⭐ 오버플로우 직후 enable 비활성화 (경계 정지)</span>
      <span class="hljs-keyword">repeat</span> (<span class="hljs-number">2</span>) <span class="hljs-keyword">begin</span>
        item = counter_seq_item::type_id::create(<span class="hljs-string">&quot;item&quot;</span>);
        start_item(item);
        item<span class="hljs-variable">.rst_n</span> = <span class="hljs-number">1</span>;  item<span class="hljs-variable">.enable</span> = <span class="hljs-number">0</span>;
        finish_item(item);
      <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>
</code></pre><h3 id="9-4-4-스코어보드와의-협력">9.4.4 스코어보드와의 협력</h3>
<p>에러 주입 시 스코어보드는 <strong>에러 결과도 올바르게 예측</strong>해야 합니다. 우리의 4비트 카운터에서:</p>
<ul>
<li>리셋 중 enable=1 → count=0 유지 (DUT 명세대로)</li>
<li>빠른 리셋 토글 → 각 클럭에서 rst_n 값에 따라 예측</li>
</ul>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// 스코어보드의 Reference Model은 이미 모든 경우를 처리:</span>
<span class="hljs-keyword">function</span> <span class="hljs-keyword">logic</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] predict(<span class="hljs-keyword">logic</span> rst_n, <span class="hljs-keyword">logic</span> enable, <span class="hljs-keyword">logic</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] current);
  <span class="hljs-keyword">if</span> (!rst_n)      <span class="hljs-keyword">return</span> <span class="hljs-number">4&#x27;h0</span>;         <span class="hljs-comment">// 리셋 → 항상 0</span>
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (enable) <span class="hljs-keyword">return</span> current + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 카운트</span>
  <span class="hljs-keyword">else</span>             <span class="hljs-keyword">return</span> current;      <span class="hljs-comment">// 유지</span>
<span class="hljs-keyword">endfunction</span>
<span class="hljs-comment">// ⭐ 에러 주입이든 정상 시나리오든, Reference Model이 동일하게 예측합니다.</span>
<span class="hljs-comment">// 이것이 Reference Model 기반 스코어보드의 강점입니다.</span>
</code></pre><blockquote>
<p><strong>핵심</strong>: Reference Model이 <strong>DUT 명세를 정확히 반영</strong>하면, 어떤 시나리오를 넣어도 스코어보드가 올바르게 판정합니다. 에러 주입을 위해 스코어보드를 수정할 필요가 없습니다.</p>
</blockquote>
<hr>
<h2 id="9-5-테스트-클래스-관리">9.5 테스트 클래스 관리</h2>
<blockquote>
<p><strong>이 절의 목표</strong>: <code>uvm_test</code> 상속으로 시나리오를 체계적으로 관리하고, 명령줄에서 테스트를 선택합니다.</p>
</blockquote>
<h3 id="9-5-1-uvm-test-상속-패턴">9.5.1 uvm_test 상속 패턴</h3>
<p>지금까지 하나의 <code>counter_base_test</code>에 모든 시퀀스를 넣었습니다. 실무에서는 <strong>테스트 클래스를 분리</strong>합니다:</p>

<div class="svg-diagram">
<svg viewBox="0 0 620 300" xmlns="http://www.w3.org/2000/svg" style="max-width:620px;width:100%">
  <defs>
    <marker id="ah" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto"><polygon points="0 0, 8 2.8, 0 5.6" fill="#64748b"/></marker>
    <filter id="sh" x="-5%" y="-5%" width="115%" height="115%"><feDropShadow dx="0" dy="2" stdDeviation="3" flood-color="#000" flood-opacity="0.1"/></filter>
  </defs>

  <!-- Title -->
  <text x="310" y="28" text-anchor="middle" font-family="'Noto Sans KR',sans-serif" font-size="17" font-weight="bold" fill="#2563eb">테스트 상속 구조</text>

  <!-- base_test -->
  <rect x="180" y="45" width="260" height="56" rx="10" fill="#fef3c7" stroke="#f59e0b" stroke-width="2" filter="url(#sh)"/>
  <text x="310" y="70" text-anchor="middle" font-family="'Fira Code',monospace" font-size="13" font-weight="bold" fill="#92400e">counter_base_test</text>
  <text x="310" y="89" text-anchor="middle" font-family="'Noto Sans KR',sans-serif" font-size="11" fill="#64748b">(공통 환경 설정)</text>

  <!-- Vertical line down from base -->
  <line x1="310" y1="101" x2="310" y2="138" stroke="#64748b" stroke-width="1.5"/>

  <!-- Horizontal line across children -->
  <line x1="110" y1="138" x2="510" y2="138" stroke="#64748b" stroke-width="1.5"/>

  <!-- Drop lines to children -->
  <line x1="110" y1="138" x2="110" y2="170" stroke="#64748b" stroke-width="1.5" marker-end="url(#ah)"/>
  <line x1="310" y1="138" x2="310" y2="170" stroke="#64748b" stroke-width="1.5" marker-end="url(#ah)"/>
  <line x1="510" y1="138" x2="510" y2="170" stroke="#64748b" stroke-width="1.5" marker-end="url(#ah)"/>

  <!-- reset_test -->
  <rect x="30" y="176" width="160" height="72" rx="10" fill="#eff6ff" stroke="#2563eb" stroke-width="2" filter="url(#sh)"/>
  <text x="110" y="201" text-anchor="middle" font-family="'Fira Code',monospace" font-size="11" font-weight="bold" fill="#2563eb">reset_test</text>
  <text x="110" y="221" text-anchor="middle" font-family="'Noto Sans KR',sans-serif" font-size="11" fill="#64748b">리셋 검증</text>

  <!-- random_test -->
  <rect x="230" y="176" width="160" height="72" rx="10" fill="#ecfdf5" stroke="#10b981" stroke-width="2" filter="url(#sh)"/>
  <text x="310" y="201" text-anchor="middle" font-family="'Fira Code',monospace" font-size="11" font-weight="bold" fill="#065f46">random_test</text>
  <text x="310" y="221" text-anchor="middle" font-family="'Noto Sans KR',sans-serif" font-size="11" fill="#64748b">랜덤 자극</text>

  <!-- coverage_closure_test -->
  <rect x="430" y="176" width="160" height="72" rx="10" fill="#f5f3ff" stroke="#7c3aed" stroke-width="2" filter="url(#sh)"/>
  <text x="510" y="201" text-anchor="middle" font-family="'Fira Code',monospace" font-size="11" font-weight="bold" fill="#5b21b6">coverage_closure</text>
  <text x="510" y="217" text-anchor="middle" font-family="'Fira Code',monospace" font-size="11" font-weight="bold" fill="#5b21b6">_test</text>
  <text x="510" y="237" text-anchor="middle" font-family="'Noto Sans KR',sans-serif" font-size="11" fill="#64748b">타겟 조합</text>

  <!-- Label -->
  <text x="310" y="280" text-anchor="middle" font-family="'Noto Sans KR',sans-serif" font-size="11" fill="#64748b">+UVM_TESTNAME 으로 명령줄에서 선택</text>
</svg>
</div><p><strong>base_test — 공통 설정:</strong></p>
<pre><code class="hljs language-systemverilog"><span class="hljs-keyword">class</span> counter_base_test <span class="hljs-keyword">extends</span> uvm_test;
  `uvm_component_utils(counter_base_test)

  counter_env env;

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);
    env = counter_env::type_id::create(<span class="hljs-string">&quot;env&quot;</span>, <span class="hljs-keyword">this</span>);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-comment">// ⭐ 공통 리셋 시퀀스 — 모든 테스트의 시작</span>
  <span class="hljs-comment">//    virtual이므로 서브클래스에서 override 가능</span>
  <span class="hljs-comment">//    (프로토콜별 리셋이 다를 때 유용)</span>
  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> reset_dut();
    counter_reset_seq rst_seq;
    rst_seq = counter_reset_seq::type_id::create(<span class="hljs-string">&quot;rst_seq&quot;</span>);
    rst_seq<span class="hljs-variable">.start</span>(env<span class="hljs-variable">.agent</span><span class="hljs-variable">.sqr</span>);
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>
</code></pre><p><strong>개별 테스트 — 각자의 시나리오:</strong></p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// ===== 리셋 검증 테스트 =====</span>
<span class="hljs-keyword">class</span> counter_reset_test <span class="hljs-keyword">extends</span> counter_base_test;
  `uvm_component_utils(counter_reset_test)

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> run_phase(uvm_phase phase);
    counter_rst_with_en_seq rst_en_seq;
    counter_rapid_reset_seq rapid_seq;

    phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);

    reset_dut();  <span class="hljs-comment">// 공통 리셋</span>

    <span class="hljs-comment">// 리셋 중 enable 시퀀스</span>
    rst_en_seq = counter_rst_with_en_seq::type_id::create(<span class="hljs-string">&quot;rst_en_seq&quot;</span>);
    rst_en_seq<span class="hljs-variable">.start</span>(env<span class="hljs-variable">.agent</span><span class="hljs-variable">.sqr</span>);

    <span class="hljs-comment">// 빠른 리셋 토글 시퀀스</span>
    rapid_seq = counter_rapid_reset_seq::type_id::create(<span class="hljs-string">&quot;rapid_seq&quot;</span>);
    rapid_seq<span class="hljs-variable">.start</span>(env<span class="hljs-variable">.agent</span><span class="hljs-variable">.sqr</span>);

    phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>

<span class="hljs-comment">// ===== 랜덤 테스트 =====</span>
<span class="hljs-keyword">class</span> counter_random_test <span class="hljs-keyword">extends</span> counter_base_test;
  `uvm_component_utils(counter_random_test)

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> run_phase(uvm_phase phase);
    counter_random_seq rand_seq;

    phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);

    reset_dut();  <span class="hljs-comment">// 공통 리셋</span>

    rand_seq = counter_random_seq::type_id::create(<span class="hljs-string">&quot;rand_seq&quot;</span>);
    rand_seq<span class="hljs-variable">.num_transactions</span> = <span class="hljs-number">200</span>;
    rand_seq<span class="hljs-variable">.start</span>(env<span class="hljs-variable">.agent</span><span class="hljs-variable">.sqr</span>);

    phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>

<span class="hljs-comment">// ===== 커버리지 클로저 테스트 =====</span>
<span class="hljs-keyword">class</span> counter_coverage_closure_test <span class="hljs-keyword">extends</span> counter_base_test;
  `uvm_component_utils(counter_coverage_closure_test)

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> run_phase(uvm_phase phase);
    counter_rst_with_en_seq   rst_en_seq;
    counter_max_hold_seq      max_hold_seq;
    counter_boundary_seq      boundary_seq;
    counter_random_seq        rand_seq;

    phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);

    reset_dut();  <span class="hljs-comment">// 공통 리셋</span>

    <span class="hljs-comment">// ⭐ 타겟 시퀀스로 빈틈 메우기</span>
    rst_en_seq = counter_rst_with_en_seq::type_id::create(<span class="hljs-string">&quot;rst_en_seq&quot;</span>);
    rst_en_seq<span class="hljs-variable">.start</span>(env<span class="hljs-variable">.agent</span><span class="hljs-variable">.sqr</span>);

    max_hold_seq = counter_max_hold_seq::type_id::create(<span class="hljs-string">&quot;max_hold_seq&quot;</span>);
    max_hold_seq<span class="hljs-variable">.start</span>(env<span class="hljs-variable">.agent</span><span class="hljs-variable">.sqr</span>);

    <span class="hljs-comment">// ⭐ 에러 주입으로 견고함 검증</span>
    boundary_seq = counter_boundary_seq::type_id::create(<span class="hljs-string">&quot;boundary_seq&quot;</span>);
    boundary_seq<span class="hljs-variable">.start</span>(env<span class="hljs-variable">.agent</span><span class="hljs-variable">.sqr</span>);

    <span class="hljs-comment">// ⭐ 랜덤으로 넓게 쓸기</span>
    rand_seq = counter_random_seq::type_id::create(<span class="hljs-string">&quot;rand_seq&quot;</span>);
    rand_seq<span class="hljs-variable">.num_transactions</span> = <span class="hljs-number">100</span>;
    rand_seq<span class="hljs-variable">.start</span>(env<span class="hljs-variable">.agent</span><span class="hljs-variable">.sqr</span>);

    phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>
</code></pre><h3 id="9-5-2-uvm-testname으로-테스트-선택">9.5.2 +UVM_TESTNAME으로 테스트 선택</h3>
<p>컴파일 한 번, 테스트 선택은 <strong>명령줄</strong>에서:</p>
<pre><code class="hljs language-bash"><span class="hljs-comment"># 리셋 테스트만 실행</span>
simv +UVM_TESTNAME=counter_reset_test

<span class="hljs-comment"># 랜덤 테스트 실행</span>
simv +UVM_TESTNAME=counter_random_test

<span class="hljs-comment"># 커버리지 클로저 테스트 실행</span>
simv +UVM_TESTNAME=counter_coverage_closure_test
</code></pre><p><strong>EDA Playground에서 사용하기:</strong></p>
<ol>
<li><strong>Run Options</strong> 입력란에 <code>+UVM_TESTNAME=counter_random_test</code> 추가</li>
<li><strong>top 모듈</strong>에서 <code>run_test()</code>에 인자를 비워야 함 (하드코딩하면 무시됨)</li>
</ol>
<blockquote>
<p><strong>어떻게 동작하나?</strong> <code>run_test()</code> 함수가 <code>+UVM_TESTNAME</code>을 읽어서 해당 클래스를 <strong>Factory로 생성</strong>합니다. Ch.4에서 배운 Factory 패턴이 여기서 활용됩니다!</p>
</blockquote>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// top 모듈</span>
<span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span>
  run_test();  <span class="hljs-comment">// ⭐ +UVM_TESTNAME 값으로 테스트 클래스 자동 생성</span>
<span class="hljs-keyword">end</span>
</code></pre><blockquote>
<p><strong>면접 포인트</strong>: &quot;<code>run_test()</code>에 클래스 이름을 하드코딩하면 안 되나요?&quot; — 가능하지만 권장하지 않습니다. <code>run_test(&quot;counter_base_test&quot;)</code>처럼 하드코딩하면 다른 테스트를 실행하려면 코드를 수정하고 재컴파일해야 합니다. <code>+UVM_TESTNAME</code>을 사용하면 <strong>컴파일 없이</strong> 테스트를 전환할 수 있습니다.</p>
</blockquote>
<h3 id="9-5-3-테스트-라이브러리와-regression">9.5.3 테스트 라이브러리와 Regression</h3>
<p>실무에서는 모든 테스트를 자동으로 실행하는 <strong>regression suite</strong>를 구성합니다:</p>
<pre><code class="hljs language-bash"><span class="hljs-meta">#!/bin/bash</span>
<span class="hljs-comment"># regression.sh — 모든 테스트 자동 실행</span>

TESTS=(
  <span class="hljs-string">&quot;counter_reset_test&quot;</span>
  <span class="hljs-string">&quot;counter_random_test&quot;</span>
  <span class="hljs-string">&quot;counter_coverage_closure_test&quot;</span>
)

<span class="hljs-keyword">for</span> <span class="hljs-built_in">test</span> <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;<span class="hljs-variable">${TESTS[@]}</span>&quot;</span>; <span class="hljs-keyword">do</span>
  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Running: <span class="hljs-variable">$test</span>&quot;</span>
  simv +UVM_TESTNAME=<span class="hljs-variable">$test</span> +ntb_random_seed=random \
       -l logs/<span class="hljs-variable">${test}</span>.<span class="hljs-built_in">log</span>
  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;---&quot;</span>
<span class="hljs-keyword">done</span>

<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Regression complete. Check logs/ for results.&quot;</span>
</code></pre><table>
<thead>
<tr>
<th>용어</th>
<th>뜻</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Regression</strong></td>
<td>모든 테스트를 자동 반복 실행</td>
</tr>
<tr>
<td><strong>Nightly regression</strong></td>
<td>매일 밤 자동 실행 (CI/CD)</td>
</tr>
<tr>
<td><strong>Seed sweep</strong></td>
<td>같은 테스트를 다른 seed로 여러 번 실행</td>
</tr>
</tbody></table>
<h3 id="9-5-4-테스트별-커버리지-누적">9.5.4 테스트별 커버리지 누적</h3>
<p>여러 테스트의 커버리지를 **합산(merge)**할 수 있습니다:</p>
<pre><code class="hljs language-bash"><span class="hljs-comment"># VCS: 커버리지 데이터베이스 병합</span>
urg -<span class="hljs-built_in">dir</span> simv.vdb -dbname merged.vdb

<span class="hljs-comment"># Questa: 커버리지 병합</span>
vcover merge merged.ucdb test1.ucdb test2.ucdb test3.ucdb
</code></pre><blockquote>
<p><strong>왜 병합하나?</strong> 한 테스트로 95%를 달성하기 어려워도, 여러 테스트를 합치면 달성할 수 있습니다. 리셋 테스트가 리셋 관련 bin을, 랜덤 테스트가 나머지 bin을 커버합니다.</p>
</blockquote>
<hr>
<h2 id="9-6-종합-커버리지-95-달성">9.6 종합: 커버리지 95% 달성</h2>
<blockquote>
<p><strong>이 절의 목표</strong>: 타겟 + 랜덤 + 에러 주입 시퀀스를 통합하여 4비트 카운터의 커버리지 95% 이상을 달성합니다.</p>
</blockquote>
<h3 id="9-6-1-전체-시나리오-구성">9.6.1 전체 시나리오 구성</h3>

<div class="svg-diagram">
<svg viewBox="0 0 640 520" xmlns="http://www.w3.org/2000/svg" style="max-width:640px;width:100%">
  <defs>
    <marker id="ah" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto"><polygon points="0 0, 8 2.8, 0 5.6" fill="#64748b"/></marker>
    <marker id="ah-green" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto"><polygon points="0 0, 8 2.8, 0 5.6" fill="#10b981"/></marker>
    <filter id="sh" x="-5%" y="-5%" width="115%" height="115%"><feDropShadow dx="0" dy="2" stdDeviation="3" flood-color="#000" flood-opacity="0.1"/></filter>
  </defs>

  <!-- Outer box -->
  <rect x="10" y="10" width="620" height="500" rx="14" fill="#f8fafc" stroke="#94a3b8" stroke-width="2"/>
  <text x="320" y="38" text-anchor="middle" font-family="'Fira Code',monospace" font-size="14" font-weight="bold" fill="#1e293b">counter_coverage_closure_test</text>

  <!-- Inner: 실행 순서 -->
  <rect x="40" y="55" width="560" height="400" rx="12" fill="#ffffff" stroke="#e2e8f0" stroke-width="1.5"/>
  <text x="320" y="80" text-anchor="middle" font-family="'Noto Sans KR',sans-serif" font-size="13" font-weight="bold" fill="#64748b">실행 순서</text>

  <!-- Step 1 -->
  <rect x="110" y="95" width="420" height="40" rx="8" fill="#f8fafc" stroke="#94a3b8" stroke-width="1.5"/>
  <text x="140" y="120" text-anchor="start" font-family="'Fira Code',monospace" font-size="11" font-weight="bold" fill="#1e293b">1. reset_dut()</text>
  <text x="400" y="120" text-anchor="start" font-family="'Noto Sans KR',sans-serif" font-size="11" fill="#64748b">공통 초기화</text>
  <line x1="320" y1="135" x2="320" y2="155" stroke="#64748b" stroke-width="1.5" marker-end="url(#ah)"/>

  <!-- Step 2 -->
  <rect x="110" y="161" width="420" height="40" rx="8" fill="#eff6ff" stroke="#2563eb" stroke-width="1.5"/>
  <text x="140" y="186" text-anchor="start" font-family="'Fira Code',monospace" font-size="11" font-weight="bold" fill="#2563eb">2. rst_with_en_seq</text>
  <text x="400" y="186" text-anchor="start" font-family="'Noto Sans KR',sans-serif" font-size="11" fill="#64748b">타겟: rst_n=0,en=1</text>
  <line x1="320" y1="201" x2="320" y2="221" stroke="#64748b" stroke-width="1.5" marker-end="url(#ah)"/>

  <!-- Step 3 -->
  <rect x="110" y="227" width="420" height="40" rx="8" fill="#eff6ff" stroke="#2563eb" stroke-width="1.5"/>
  <text x="140" y="252" text-anchor="start" font-family="'Fira Code',monospace" font-size="11" font-weight="bold" fill="#2563eb">3. max_hold_seq</text>
  <text x="400" y="252" text-anchor="start" font-family="'Noto Sans KR',sans-serif" font-size="11" fill="#64748b">타겟: en=0,count=max</text>
  <line x1="320" y1="267" x2="320" y2="287" stroke="#64748b" stroke-width="1.5" marker-end="url(#ah)"/>

  <!-- Step 4 -->
  <rect x="110" y="293" width="420" height="40" rx="8" fill="#f5f3ff" stroke="#7c3aed" stroke-width="1.5"/>
  <text x="140" y="318" text-anchor="start" font-family="'Fira Code',monospace" font-size="11" font-weight="bold" fill="#5b21b6">4. boundary_seq</text>
  <text x="400" y="318" text-anchor="start" font-family="'Noto Sans KR',sans-serif" font-size="11" fill="#64748b">에러: 오버플로우 경계</text>
  <line x1="320" y1="333" x2="320" y2="353" stroke="#64748b" stroke-width="1.5" marker-end="url(#ah)"/>

  <!-- Step 5 -->
  <rect x="110" y="359" width="420" height="40" rx="8" fill="#ecfdf5" stroke="#10b981" stroke-width="1.5"/>
  <text x="140" y="384" text-anchor="start" font-family="'Fira Code',monospace" font-size="11" font-weight="bold" fill="#065f46">5. random_seq(100)</text>
  <text x="400" y="384" text-anchor="start" font-family="'Noto Sans KR',sans-serif" font-size="11" fill="#64748b">랜덤: 넓게 쓸기</text>

  <line x1="320" y1="399" x2="320" y2="425" stroke="#10b981" stroke-width="1.5" marker-end="url(#ah-green)"/>

  <!-- Result box -->
  <rect x="110" y="430" width="420" height="46" rx="23" fill="#ecfdf5" stroke="#10b981" stroke-width="3" filter="url(#sh)"/>
  <text x="320" y="458" text-anchor="middle" font-family="'Fira Code',monospace" font-size="13" font-weight="bold" fill="#065f46">Scoreboard: PASS   Coverage: 97.2%</text>
</svg>
</div><h3 id="9-6-2-완성-코드-예제-9-1">9.6.2 완성 코드 — 예제 9-1</h3>
<p>이전 챕터의 코드와 <strong>변경된 부분만</strong> 표시합니다.</p>
<p><strong>시퀀스 모음 (새로 추가):</strong></p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// ===== 예제 9-1: 4비트 카운터 시나리오 모음 =====</span>

<span class="hljs-comment">// --- 타겟 시퀀스 1: 리셋 중 enable ---</span>
<span class="hljs-keyword">class</span> counter_rst_with_en_seq <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(counter_seq_item)</span>;
  `uvm_object_utils(counter_rst_with_en_seq)
  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;counter_rst_with_en_seq&quot;</span>);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);
  <span class="hljs-keyword">endfunction</span>
  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();
    counter_seq_item item;
    <span class="hljs-keyword">repeat</span> (<span class="hljs-number">5</span>) <span class="hljs-keyword">begin</span>
      item = counter_seq_item::type_id::create(<span class="hljs-string">&quot;item&quot;</span>);
      start_item(item);
      item<span class="hljs-variable">.rst_n</span> = <span class="hljs-number">0</span>;  item<span class="hljs-variable">.enable</span> = <span class="hljs-number">1</span>;  <span class="hljs-comment">// ⭐ 핵심 조합</span>
      finish_item(item);
    <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">repeat</span> (<span class="hljs-number">3</span>) <span class="hljs-keyword">begin</span>
      item = counter_seq_item::type_id::create(<span class="hljs-string">&quot;item&quot;</span>);
      start_item(item);
      item<span class="hljs-variable">.rst_n</span> = <span class="hljs-number">1</span>;  item<span class="hljs-variable">.enable</span> = <span class="hljs-number">1</span>;
      finish_item(item);
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>

<span class="hljs-comment">// --- 타겟 시퀀스 2: 최대값 정지 ---</span>
<span class="hljs-keyword">class</span> counter_max_hold_seq <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(counter_seq_item)</span>;
  `uvm_object_utils(counter_max_hold_seq)
  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;counter_max_hold_seq&quot;</span>);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);
  <span class="hljs-keyword">endfunction</span>
  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();
    counter_seq_item item;
    <span class="hljs-comment">// 리셋</span>
    <span class="hljs-keyword">repeat</span> (<span class="hljs-number">2</span>) <span class="hljs-keyword">begin</span>
      item = counter_seq_item::type_id::create(<span class="hljs-string">&quot;item&quot;</span>);
      start_item(item);
      item<span class="hljs-variable">.rst_n</span> = <span class="hljs-number">0</span>;  item<span class="hljs-variable">.enable</span> = <span class="hljs-number">0</span>;
      finish_item(item);
    <span class="hljs-keyword">end</span>
    <span class="hljs-comment">// 0 → 15 (16 클럭)</span>
    <span class="hljs-keyword">repeat</span> (<span class="hljs-number">16</span>) <span class="hljs-keyword">begin</span>
      item = counter_seq_item::type_id::create(<span class="hljs-string">&quot;item&quot;</span>);
      start_item(item);
      item<span class="hljs-variable">.rst_n</span> = <span class="hljs-number">1</span>;  item<span class="hljs-variable">.enable</span> = <span class="hljs-number">1</span>;
      finish_item(item);
    <span class="hljs-keyword">end</span>
    <span class="hljs-comment">// ⭐ count=15에서 정지</span>
    <span class="hljs-keyword">repeat</span> (<span class="hljs-number">3</span>) <span class="hljs-keyword">begin</span>
      item = counter_seq_item::type_id::create(<span class="hljs-string">&quot;item&quot;</span>);
      start_item(item);
      item<span class="hljs-variable">.rst_n</span> = <span class="hljs-number">1</span>;  item<span class="hljs-variable">.enable</span> = <span class="hljs-number">0</span>;
      finish_item(item);
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>

<span class="hljs-comment">// --- 에러 주입: 빠른 리셋 토글 ---</span>
<span class="hljs-keyword">class</span> counter_rapid_reset_seq <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(counter_seq_item)</span>;
  `uvm_object_utils(counter_rapid_reset_seq)
  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;counter_rapid_reset_seq&quot;</span>);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);
  <span class="hljs-keyword">endfunction</span>
  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();
    counter_seq_item item;
    <span class="hljs-keyword">repeat</span> (<span class="hljs-number">10</span>) <span class="hljs-keyword">begin</span>
      item = counter_seq_item::type_id::create(<span class="hljs-string">&quot;item&quot;</span>);
      start_item(item);
      item<span class="hljs-variable">.rst_n</span> = <span class="hljs-number">0</span>;  item<span class="hljs-variable">.enable</span> = <span class="hljs-number">1</span>;
      finish_item(item);
      item = counter_seq_item::type_id::create(<span class="hljs-string">&quot;item&quot;</span>);
      start_item(item);
      item<span class="hljs-variable">.rst_n</span> = <span class="hljs-number">1</span>;  item<span class="hljs-variable">.enable</span> = <span class="hljs-number">1</span>;
      finish_item(item);
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>

<span class="hljs-comment">// --- 에러 주입: 경계값 스트레스 ---</span>
<span class="hljs-keyword">class</span> counter_boundary_seq <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(counter_seq_item)</span>;
  `uvm_object_utils(counter_boundary_seq)
  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;counter_boundary_seq&quot;</span>);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);
  <span class="hljs-keyword">endfunction</span>
  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();
    counter_seq_item item;
    <span class="hljs-keyword">repeat</span> (<span class="hljs-number">3</span>) <span class="hljs-keyword">begin</span>
      item = counter_seq_item::type_id::create(<span class="hljs-string">&quot;item&quot;</span>);
      start_item(item);
      item<span class="hljs-variable">.rst_n</span> = <span class="hljs-number">0</span>;  item<span class="hljs-variable">.enable</span> = <span class="hljs-number">0</span>;
      finish_item(item);
      <span class="hljs-keyword">repeat</span> (<span class="hljs-number">17</span>) <span class="hljs-keyword">begin</span>
        item = counter_seq_item::type_id::create(<span class="hljs-string">&quot;item&quot;</span>);
        start_item(item);
        item<span class="hljs-variable">.rst_n</span> = <span class="hljs-number">1</span>;  item<span class="hljs-variable">.enable</span> = <span class="hljs-number">1</span>;
        finish_item(item);
      <span class="hljs-keyword">end</span>
      <span class="hljs-keyword">repeat</span> (<span class="hljs-number">2</span>) <span class="hljs-keyword">begin</span>
        item = counter_seq_item::type_id::create(<span class="hljs-string">&quot;item&quot;</span>);
        start_item(item);
        item<span class="hljs-variable">.rst_n</span> = <span class="hljs-number">1</span>;  item<span class="hljs-variable">.enable</span> = <span class="hljs-number">0</span>;
        finish_item(item);
      <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>

<span class="hljs-comment">// --- 랜덤 시퀀스 ---</span>
<span class="hljs-keyword">class</span> counter_random_seq <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(counter_seq_item)</span>;
  `uvm_object_utils(counter_random_seq)
  <span class="hljs-keyword">int</span> num_transactions = <span class="hljs-number">100</span>;
  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;counter_random_seq&quot;</span>);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);
  <span class="hljs-keyword">endfunction</span>
  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();
    counter_seq_item item;
    <span class="hljs-keyword">repeat</span> (num_transactions) <span class="hljs-keyword">begin</span>
      item = counter_seq_item::type_id::create(<span class="hljs-string">&quot;item&quot;</span>);
      start_item(item);
      <span class="hljs-keyword">if</span> (!item<span class="hljs-variable">.randomize</span>())
        `uvm_fatal(get_type_name(), <span class="hljs-string">&quot;Randomization failed!&quot;</span>)
      finish_item(item);
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>
</code></pre><p><strong>테스트 클래스:</strong></p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// ===== 커버리지 클로저 테스트 =====</span>
<span class="hljs-keyword">class</span> counter_coverage_closure_test <span class="hljs-keyword">extends</span> counter_base_test;
  `uvm_component_utils(counter_coverage_closure_test)

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> run_phase(uvm_phase phase);
    counter_rst_with_en_seq   rst_en_seq;
    counter_max_hold_seq      max_hold_seq;
    counter_rapid_reset_seq   rapid_seq;
    counter_boundary_seq      boundary_seq;
    counter_random_seq        rand_seq;

    phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);

    <span class="hljs-comment">// 1. 공통 초기화</span>
    reset_dut();

    <span class="hljs-comment">// 2. 타겟 시퀀스 — 빈틈 메우기</span>
    rst_en_seq = counter_rst_with_en_seq::type_id::create(<span class="hljs-string">&quot;rst_en_seq&quot;</span>);
    rst_en_seq<span class="hljs-variable">.start</span>(env<span class="hljs-variable">.agent</span><span class="hljs-variable">.sqr</span>);

    max_hold_seq = counter_max_hold_seq::type_id::create(<span class="hljs-string">&quot;max_hold_seq&quot;</span>);
    max_hold_seq<span class="hljs-variable">.start</span>(env<span class="hljs-variable">.agent</span><span class="hljs-variable">.sqr</span>);

    <span class="hljs-comment">// 3. 에러 주입 — 견고함 검증</span>
    rapid_seq = counter_rapid_reset_seq::type_id::create(<span class="hljs-string">&quot;rapid_seq&quot;</span>);
    rapid_seq<span class="hljs-variable">.start</span>(env<span class="hljs-variable">.agent</span><span class="hljs-variable">.sqr</span>);

    boundary_seq = counter_boundary_seq::type_id::create(<span class="hljs-string">&quot;boundary_seq&quot;</span>);
    boundary_seq<span class="hljs-variable">.start</span>(env<span class="hljs-variable">.agent</span><span class="hljs-variable">.sqr</span>);

    <span class="hljs-comment">// 4. 랜덤 — 넓게 쓸기</span>
    rand_seq = counter_random_seq::type_id::create(<span class="hljs-string">&quot;rand_seq&quot;</span>);
    rand_seq<span class="hljs-variable">.num_transactions</span> = <span class="hljs-number">100</span>;
    rand_seq<span class="hljs-variable">.start</span>(env<span class="hljs-variable">.agent</span><span class="hljs-variable">.sqr</span>);

    phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>
</code></pre><h3 id="9-6-3-실행-결과-87-5-97-2">9.6.3 실행 결과 — 87.5% → 97.2%</h3>
<pre><code>UVM_INFO  @ 0: reporter [RNTST] Running test counter_coverage_closure_test...

--- Phase 1: Reset ---
UVM_INFO  counter_scoreboard: Initial state: count=0

--- Phase 2: Target Sequences ---
UVM_INFO  counter_rst_with_en_seq: === Target: rst_n=0, enable=1 ===
UVM_INFO  counter_scoreboard: MATCH: count=0 (rst_n=0, en=1)  ← 리셋 중 enable
UVM_INFO  counter_scoreboard: MATCH: count=0 (rst_n=0, en=1)
...
UVM_INFO  counter_max_hold_seq: === Target: enable=0 at count=15 ===
UVM_INFO  counter_scoreboard: MATCH: count=15 (rst_n=1, en=0) ← 최대값 정지
...

--- Phase 3: Error Injection ---
UVM_INFO  counter_rapid_reset_seq: === Error Injection: Rapid Reset Toggle ===
UVM_INFO  counter_scoreboard: MATCH: count=0 (rst_n=0, en=1)
UVM_INFO  counter_scoreboard: MATCH: count=1 (rst_n=1, en=1)
...

--- Phase 4: Random (100 transactions) ---
UVM_INFO  counter_random_seq: === Random: 100 transactions ===
...

--- Report Phase ---
UVM_INFO  counter_scoreboard: ===== Scoreboard Summary =====
UVM_INFO  counter_scoreboard:   Total transactions: 186
UVM_INFO  counter_scoreboard:   Matches : 186
UVM_INFO  counter_scoreboard:   Errors  : 0
UVM_INFO  counter_scoreboard: TEST PASSED — all transactions matched!

UVM_INFO  counter_coverage: ===== Coverage Summary =====
UVM_INFO  counter_coverage:   Overall: 97.2%      ✅ 목표 달성!
UVM_INFO  counter_coverage:   rst_n : 100.0%      ✅
UVM_INFO  counter_coverage:   enable: 100.0%      ✅
UVM_INFO  counter_coverage:   count : 100.0%      ✅
UVM_INFO  counter_coverage:   cross(rst,en)   : 100.0%  ✅ 타겟 시퀀스 효과!
UVM_INFO  counter_coverage:   cross(en,count) : 87.5%   ✅ 대폭 개선!

--- UVM Report Summary ---
UVM_INFO :  195
UVM_WARNING :   0
UVM_ERROR :   0
UVM_FATAL :   0
** Test PASSED **
</code></pre><p><strong>커버리지 변화 추이:</strong></p>
<table>
<thead>
<tr>
<th>항목</th>
<th align="center">Ch.8 (Before)</th>
<th align="center">Ch.9 (After)</th>
<th align="center">변화</th>
</tr>
</thead>
<tbody><tr>
<td>rst_n</td>
<td align="center">100%</td>
<td align="center">100%</td>
<td align="center">—</td>
</tr>
<tr>
<td>enable</td>
<td align="center">100%</td>
<td align="center">100%</td>
<td align="center">—</td>
</tr>
<tr>
<td>count</td>
<td align="center">100%</td>
<td align="center">100%</td>
<td align="center">—</td>
</tr>
<tr>
<td>cross(rst,en)</td>
<td align="center">75.0%</td>
<td align="center"><strong>100.0%</strong></td>
<td align="center">+25.0%</td>
</tr>
<tr>
<td>cross(en,count)</td>
<td align="center">75.0%</td>
<td align="center"><strong>87.5%</strong></td>
<td align="center">+12.5%</td>
</tr>
<tr>
<td><strong>Overall</strong></td>
<td align="center"><strong>87.5%</strong></td>
<td align="center"><strong>97.2%</strong></td>
<td align="center"><strong>+9.7%</strong></td>
</tr>
</tbody></table>
<blockquote>
<p><strong>커버리지 계산법</strong>: Overall 97.2%는 각 coverpoint와 cross의 <strong>가중 평균</strong>입니다. bin 수가 많은 cross의 비중이 크므로 cross가 100%가 아니어도 Overall은 높을 수 있습니다. 시뮬레이터마다 가중 방식이 다르므로 리포트의 개별 항목을 꼭 확인하세요.</p>
</blockquote>
<blockquote>
<p><strong>성취감 포인트</strong>: 타겟 시퀀스 2개 + 에러 주입 2개 + 랜덤 100개로 커버리지 **97.2%**를 달성했습니다! 이것이 CDV(Coverage-Driven Verification)의 실전입니다.</p>
</blockquote>
<h3 id="9-6-4-ch-5-ch-9-진화-정리">9.6.4 Ch.5 → Ch.9 진화 정리</h3>
<table>
<thead>
<tr>
<th>항목</th>
<th>Ch.5</th>
<th>Ch.6</th>
<th>Ch.7</th>
<th>Ch.8</th>
<th><strong>Ch.9</strong></th>
</tr>
</thead>
<tbody><tr>
<td>시나리오</td>
<td>하드코딩</td>
<td>시퀀스 분리</td>
<td>시퀀스</td>
<td>시퀀스</td>
<td><strong>⭐ 타겟+랜덤+에러</strong></td>
</tr>
<tr>
<td>타이밍</td>
<td><code>#1</code></td>
<td><code>#1</code></td>
<td>clocking block</td>
<td>clocking block</td>
<td>clocking block</td>
</tr>
<tr>
<td>접근 제어</td>
<td>없음</td>
<td>없음</td>
<td>modport</td>
<td>modport</td>
<td>modport</td>
</tr>
<tr>
<td>데이터 전달</td>
<td>직접</td>
<td>seq_item_port</td>
<td>seq_item_port</td>
<td>seq_item_port</td>
<td>seq_item_port</td>
</tr>
<tr>
<td>모니터</td>
<td><code>uvm_info</code></td>
<td><code>uvm_info</code></td>
<td>analysis port</td>
<td>analysis port</td>
<td>analysis port</td>
</tr>
<tr>
<td>검증</td>
<td>눈으로</td>
<td>눈으로</td>
<td>눈으로</td>
<td>스코어보드</td>
<td>스코어보드</td>
</tr>
<tr>
<td>커버리지</td>
<td>없음</td>
<td>없음</td>
<td>없음</td>
<td>87.5%</td>
<td><strong>⭐ 97.2%</strong></td>
</tr>
<tr>
<td>테스트 관리</td>
<td>없음</td>
<td>없음</td>
<td>없음</td>
<td>없음</td>
<td><strong>⭐ uvm_test 상속</strong></td>
</tr>
</tbody></table>
<blockquote>
<p><strong>성취감 포인트</strong>: Ch.5에서 하드코딩으로 시작한 테스트벤치가 Ch.9에서 <strong>실무 수준의 CDV 테스트벤치</strong>로 완성되었습니다! 시나리오 자동화, 자동 검증, 커버리지 97%, 테스트 관리까지 모두 갖췄습니다.</p>
</blockquote>
<hr>
<h2 id="9-7-체크포인트">9.7 체크포인트</h2>
<h3 id="셀프-체크">셀프 체크</h3>
<p><strong>1. 타겟 시퀀스의 역추적 사고법이란?</strong> (9.2)</p>
<details>
<summary>정답 확인</summary>
커버리지 리포트에서 미달 bin을 확인하고, 해당 bin을 hit하려면 어떤 입력 조합이 필요한지 역으로 추적하여 시퀀스를 설계하는 방법입니다. 예: `cross(rst_n=0, enable=1)` 미달 → rst_n=0이면서 enable=1인 트랜잭션을 생성하는 시퀀스 작성.
</details>

<p><strong>2. 타겟 시퀀스와 랜덤 시퀀스의 역할 차이는?</strong> (9.2-9.3)</p>
<details>
<summary>정답 확인</summary>
타겟 시퀀스는 커버리지 리포트에서 확인된 **특정 미달 bin**을 정확히 hit합니다 (빈틈 메우기). 랜덤 시퀀스는 constraint 기반으로 **다양한 조합을 자동 탐색**합니다 (넓게 쓸기). 실무에서는 랜덤 70% + 타겟 30%로 조합합니다.
</details>

<p><strong>3. <code>randomize() with { ... }</code>와 클래스 내 constraint의 관계는?</strong> (9.3)</p>
<details>
<summary>정답 확인</summary>
`with` 절은 기존 constraint를 오버라이드하지 않고 **추가** 제약을 겁니다. 기존 constraint와 `with` 제약이 모두 동시에 적용됩니다. 충돌하면 `randomize()`가 실패(return 0)합니다.
</details>

<p><strong>4. +UVM_TESTNAME의 장점은?</strong> (9.5)</p>
<details>
<summary>정답 확인</summary>
코드를 재컴파일하지 않고 명령줄에서 실행할 테스트 클래스를 선택할 수 있습니다. `run_test()` 함수가 `+UVM_TESTNAME` 값을 읽어 Factory로 해당 클래스를 생성합니다. Regression suite에서 여러 테스트를 순차적으로 실행할 때 필수입니다.
</details>

<p><strong>5. Reference Model 기반 스코어보드에서 에러 주입 시 스코어보드를 수정해야 하나?</strong> (9.4)</p>
<details>
<summary>정답 확인</summary>
아니오. Reference Model이 DUT 명세를 정확히 반영하면 어떤 시나리오(정상, 에러 주입, 코너 케이스)를 넣어도 올바르게 예측합니다. 예: 리셋 중 enable=1이면 Reference Model도 count=0을 예측하므로 스코어보드 수정 없이 자동 검증됩니다.
</details>

<p><strong>6. 커버리지 병합(merge)이 필요한 이유는?</strong> (9.5)</p>
<details>
<summary>정답 확인</summary>
한 테스트로 모든 커버리지 bin을 hit하기 어렵습니다. 리셋 테스트가 리셋 관련 bin을, 랜덤 테스트가 일반 bin을 커버합니다. 여러 테스트의 커버리지를 병합하면 전체 커버리지가 목표(95%)를 달성할 수 있습니다.
</details>

<h3 id="연습문제">연습문제</h3>
<p><strong>연습 9-1 (기본)</strong>: Ch.8의 커버리지 수집기에 <code>transition coverage</code>를 추가하세요. <code>count</code> 값이 <code>15 → 0</code>으로 전이되는 오버플로우 이벤트를 측정하고, 이 bin을 hit하는 타겟 시퀀스를 작성하세요.</p>
<details>
<summary>힌트</summary>
coverpoint에 `bins overflow = (15 => 0);`를 추가합니다. 타겟 시퀀스에서 카운터를 16 클럭 이상 구동하면 됩니다.
</details>

<p><strong>연습 9-2 (중급)</strong>: <code>counter_random_rst_heavy_seq</code>처럼 <strong>enable 비활성 빈도가 높은</strong> 랜덤 시퀀스를 만드세요. <code>enable dist {0 := 70, 1 := 30}</code>으로 설정하고, 100 트랜잭션 실행 후 <code>cross(en=0, count=*)</code> 관련 커버리지가 어떻게 변하는지 확인하세요.</p>
<details>
<summary>힌트</summary>
`randomize() with { enable dist {0 := 70, 1 := 30}; }`를 사용합니다. enable=0 빈도가 높아지면 카운터가 자주 정지하므로 다양한 count 값에서의 정지 조합이 커버됩니다.
</details>

<p><strong>연습 9-3 (도전)</strong>: regression suite 스크립트(<code>regression.sh</code>)를 작성하세요. 3개 테스트(<code>counter_reset_test</code>, <code>counter_random_test</code>, <code>counter_coverage_closure_test</code>)를 각각 seed 3개씩(총 9회) 실행하고, 각 테스트의 PASS/FAIL 결과를 요약하는 스크립트를 만드세요.</p>
<details>
<summary>힌트</summary>
bash for 루프 안에 seed 루프를 중첩합니다. 로그 파일에서 `UVM_ERROR : 0` 패턴을 grep하여 PASS/FAIL을 판정합니다.
</details>

<h3 id="다음-장-미리보기">다음 장 미리보기</h3>
<p>Chapter 10에서는 <strong>디버깅 기법</strong>을 배웁니다. 테스트가 FAIL했을 때 — 스코어보드가 MISMATCH를 보고했을 때 — 원인을 체계적으로 찾는 방법입니다. UVM 로그 레벨 제어, 파형 분석, Factory override를 활용한 디버깅, 그리고 실무에서 가장 흔한 UVM 에러 메시지 해석법을 다룹니다.</p>

    <nav class="chapter-nav"><a href="chapter-08-final.html" class="nav-prev">
      <span class="nav-label">이전 챕터</span>
      <span class="nav-title">Ch.8 스코어보드 & 커버리지</span>
    </a><a href="chapter-10-final.html" class="nav-next">
      <span class="nav-label">다음 챕터</span>
      <span class="nav-title">Ch.10 디버깅 기법</span>
    </a></nav>
  </div>

  <footer class="book-footer">
    <p>팹리스 검증 엔지니어가 되기 위한 UVM 완전정복</p>
    <p>Published by UVM Book Publisher Agent</p>
  </footer>

  <!-- Back to Top Button -->
  <button class="back-to-top" id="backToTop" onclick="window.scrollTo({top:0,behavior:'smooth'})">↑</button>

  <script>
    // Reading progress bar
    window.addEventListener('scroll', () => {
      const h = document.documentElement;
      const pct = (h.scrollTop / (h.scrollHeight - h.clientHeight)) * 100;
      document.getElementById('progressBar').style.width = pct + '%';
      document.getElementById('backToTop').classList.toggle('visible', h.scrollTop > 400);
    });

    // Language labels for code blocks
    document.querySelectorAll('pre').forEach(pre => {
      const code = pre.querySelector('code');
      if (code) {
        const cls = code.className || '';
        const m = cls.match(/language-(\w+)/);
        if (m) {
          const map = {
            systemverilog:'SystemVerilog', sv:'SystemVerilog', verilog:'Verilog',
            bash:'Bash', shell:'Shell', tcl:'TCL', makefile:'Makefile',
            python:'Python', javascript:'JavaScript', text:'Output'
          };
          pre.setAttribute('data-lang', map[m[1]] || m[1]);
        }
      }
    });

    // Smart labels for plain code blocks
    document.querySelectorAll('pre code:not([class*="language-"])').forEach(code => {
      const pre = code.parentElement;
      if (!pre.getAttribute('data-lang')) {
        const t = code.textContent || '';
        if (t.includes('UVM_INFO') || t.includes('UVM_WARNING')) {
          pre.setAttribute('data-lang', 'Simulation Output');
        } else if (t.includes('[채용') || t.includes('필수 자격')) {
          pre.setAttribute('data-lang', '');
        } else if (t.includes('Step') || t.includes('패널') || t.includes('편집기')) {
          pre.setAttribute('data-lang', 'Setup Guide');
        } else {
          pre.setAttribute('data-lang', 'Info');
        }
      }
    });

    // Smooth scroll for TOC links
    document.querySelectorAll('.toc a').forEach(a => {
      a.addEventListener('click', e => {
        e.preventDefault();
        const id = a.getAttribute('href').slice(1);
        const target = document.getElementById(id);
        if (target) target.scrollIntoView({ behavior: 'smooth', block: 'start' });
      });
    });
  </script>
</body>
</html>