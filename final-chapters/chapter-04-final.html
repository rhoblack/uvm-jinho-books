<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chapter 4: UVM 기본 컴포넌트 | 팹리스 검증 엔지니어가 되기 위한 UVM 완전정복</title>
  <style>
    /* =============================================
       UVM Book Publisher - Stylesheet
       Generated by Publisher Agent
       ============================================= */

    @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;600;700&display=swap');

    :root {
      --bg: #ffffff;
      --text: #1a1a2e;
      --accent: #2563eb;
      --accent-light: #2563eb18;
      --code-bg: #1e1e2e;
      --code-text: #cdd6f4;
      --border: #e2e8f0;
      --blockquote-bg: #f0f9ff;
      --blockquote-border: #3b82f6;
      --table-header: #1e293b;
      --table-stripe: #f8fafc;
      --warning-bg: #fef3c7;
      --warning-border: #f59e0b;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: 'Noto Sans KR', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      line-height: 1.85;
      color: var(--text);
      background: var(--bg);
      font-size: 16px;
    }

    /* === Reading Progress Bar === */
    .progress-bar {
      position: fixed;
      top: 0;
      left: 0;
      width: 0%;
      height: 3px;
      background: linear-gradient(90deg, var(--accent), #2563ebcc);
      z-index: 9999;
      transition: width 0.1s;
    }

    /* === Cover Header === */
    .cover-header {
      background: linear-gradient(135deg, #2563eb08, #2563eb15);
      border-bottom: 3px solid var(--accent);
      padding: 32px 24px 24px;
      text-align: center;
      margin-bottom: 0;
    }
    .cover-part {
      display: inline-block;
      background: var(--accent);
      color: white;
      padding: 4px 16px;
      border-radius: 20px;
      font-size: 0.85em;
      font-weight: 600;
      letter-spacing: 0.5px;
      margin-bottom: 12px;
    }
    .cover-chapter-num {
      font-size: 2em;
      font-weight: 300;
      color: var(--accent);
      letter-spacing: 2px;
      opacity: 0.6;
    }

    /* === Main Content === */
    .content {
      max-width: 860px;
      margin: 0 auto;
      padding: 32px 24px 60px;
    }

    /* === TOC === */
    .toc {
      background: #f8fafc;
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 20px 28px;
      margin: 24px 0 32px;
    }
    .toc-title {
      font-size: 1.1em;
      color: var(--accent);
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 2px solid var(--border);
    }
    .toc ul { list-style: none; padding: 0; }
    .toc li { margin: 6px 0; }
    .toc li a {
      color: var(--text);
      text-decoration: none;
      font-weight: 500;
      font-size: 0.95em;
      padding: 4px 8px;
      border-radius: 4px;
      display: inline-block;
      transition: background 0.15s;
    }
    .toc li a:hover {
      background: var(--accent-light);
      color: var(--accent);
    }
    .toc li.toc-sub { padding-left: 24px; }
    .toc li.toc-sub a {
      font-weight: 400;
      font-size: 0.9em;
      color: #475569;
    }

    /* === Headings === */
    h1 {
      font-size: 2em;
      border-bottom: 3px solid var(--accent);
      padding-bottom: 12px;
      margin: 40px 0 20px;
      color: var(--text);
    }
    h1:first-child { margin-top: 0; }
    h2 {
      font-size: 1.5em;
      color: var(--accent);
      margin: 40px 0 16px;
      padding-bottom: 8px;
      border-bottom: 2px solid var(--border);
      scroll-margin-top: 16px;
    }
    h3 {
      font-size: 1.25em;
      margin: 28px 0 12px;
      color: #334155;
      scroll-margin-top: 16px;
    }
    h4 { font-size: 1.05em; margin: 20px 0 8px; color: #475569; }
    p { margin: 12px 0; }
    a { color: var(--accent); text-decoration: none; }
    a:hover { text-decoration: underline; }
    hr { border: none; border-top: 2px solid var(--border); margin: 32px 0; }
    strong { color: #1e293b; }
    img { max-width: 100%; border-radius: 8px; margin: 16px 0; }

    /* === Code Blocks === */
    pre {
      position: relative;
      background: var(--code-bg);
      border-radius: 12px;
      padding: 0;
      margin: 20px 0;
      overflow: hidden;
      box-shadow: 0 4px 16px rgba(0,0,0,0.12), 0 1px 4px rgba(0,0,0,0.08);
      border: 1px solid #313244;
    }
    pre::before {
      content: attr(data-lang);
      display: block;
      background: #313244;
      color: #a6adc8;
      padding: 8px 16px;
      font-size: 0.8em;
      font-family: 'Fira Code','JetBrains Mono',monospace;
      letter-spacing: 0.5px;
      border-bottom: 1px solid #45475a;
    }
    pre code {
      display: block;
      padding: 16px 20px;
      overflow-x: auto;
      font-family: 'Fira Code','JetBrains Mono','Cascadia Code','D2Coding',monospace;
      font-size: 0.88em;
      line-height: 1.75;
      tab-size: 4;
      color: var(--code-text);
    }
    pre code::-webkit-scrollbar { height: 6px; }
    pre code::-webkit-scrollbar-track { background: #1e1e2e; }
    pre code::-webkit-scrollbar-thumb { background: #45475a; border-radius: 3px; }

    code:not(pre code) {
      background: #f1f5f9;
      color: #be185d;
      padding: 2px 7px;
      border-radius: 5px;
      font-family: 'Fira Code','JetBrains Mono','D2Coding',monospace;
      font-size: 0.86em;
      border: 1px solid #e2e8f0;
    }

    /* Highlight.js Catppuccin */
    .hljs { background: transparent; color: #cdd6f4; }
    .hljs-keyword { color: #cba6f7; font-weight: bold; }
    .hljs-type { color: #f9e2af; }
    .hljs-string { color: #a6e3a1; }
    .hljs-number { color: #fab387; }
    .hljs-comment { color: #6c7086; font-style: italic; }
    .hljs-function, .hljs-title { color: #89b4fa; }
    .hljs-built_in { color: #f38ba8; }
    .hljs-variable { color: #cdd6f4; }
    .hljs-attr { color: #89dceb; }
    .hljs-meta { color: #f5c2e7; }
    .hljs-literal { color: #fab387; }

    /* === SVG Diagrams === */
    .svg-diagram {
      margin: 24px 0;
      padding: 20px;
      background: #fafbfc;
      border: 1px solid var(--border);
      border-radius: 12px;
      text-align: center;
      overflow-x: auto;
    }
    .svg-diagram svg { display: inline-block; }

    /* === Blockquotes === */
    blockquote {
      background: var(--blockquote-bg);
      border-left: 4px solid var(--blockquote-border);
      padding: 16px 20px;
      margin: 16px 0;
      border-radius: 0 8px 8px 0;
    }
    blockquote p:first-child { margin-top: 0; }
    blockquote p:last-child { margin-bottom: 0; }
    blockquote:has(strong:first-child) {
      background: var(--warning-bg);
      border-left-color: var(--warning-border);
    }

    /* === Tables === */
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 1px 4px rgba(0,0,0,0.06);
      border: 1px solid var(--border);
      font-size: 0.95em;
    }
    thead th {
      background: var(--table-header);
      color: white;
      padding: 12px 16px;
      text-align: left;
      font-weight: 600;
      font-size: 0.9em;
    }
    tbody td {
      padding: 10px 16px;
      border-bottom: 1px solid var(--border);
    }
    tbody tr:nth-child(even) { background: var(--table-stripe); }
    tbody tr:hover { background: var(--accent-light); }

    /* === Lists === */
    ul, ol { padding-left: 28px; margin: 12px 0; }
    li { margin: 6px 0; }
    li > ul, li > ol { margin: 4px 0; }

    /* === Details/Summary === */
    details {
      background: #f8fafc;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px 16px;
      margin: 12px 0;
    }
    details summary {
      cursor: pointer;
      font-weight: 600;
      color: var(--accent);
    }
    details[open] summary { margin-bottom: 8px; }

    /* === Plain code blocks === */
    pre:has(code:not(.hljs)) {
      background: #fafbfc;
      border: 2px solid var(--border);
      box-shadow: none;
    }
    pre:has(code:not(.hljs))::before {
      background: #f1f5f9;
      color: #64748b;
      border-bottom-color: var(--border);
    }
    pre:has(code:not(.hljs)) code { color: #334155; }

    /* === Chapter Navigation === */
    .chapter-nav {
      display: flex;
      justify-content: space-between;
      gap: 16px;
      margin: 40px 0 20px;
      padding-top: 24px;
      border-top: 2px solid var(--border);
    }
    .chapter-nav a {
      display: flex;
      flex-direction: column;
      padding: 14px 20px;
      border: 1px solid var(--border);
      border-radius: 10px;
      text-decoration: none;
      transition: all 0.2s;
      min-width: 200px;
    }
    .chapter-nav a:hover {
      border-color: var(--accent);
      background: var(--accent-light);
      text-decoration: none;
    }
    .nav-prev { align-items: flex-start; }
    .nav-next { align-items: flex-end; }
    .nav-label {
      font-size: 0.8em;
      color: #94a3b8;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .nav-title { font-weight: 600; color: var(--accent); margin-top: 2px; }

    /* === Footer === */
    .book-footer {
      text-align: center;
      padding: 20px;
      margin-top: 40px;
      border-top: 1px solid var(--border);
      color: #94a3b8;
      font-size: 0.85em;
    }

    /* === Back to Top === */
    .back-to-top {
      position: fixed;
      bottom: 24px;
      right: 24px;
      width: 44px;
      height: 44px;
      background: var(--accent);
      color: white;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      font-size: 20px;
      display: none;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      transition: opacity 0.3s;
      z-index: 100;
    }
    .back-to-top.visible { display: flex; }

    /* === Print === */
    @media print {
      .progress-bar, .back-to-top, .chapter-nav, .toc { display: none !important; }
      body { font-size: 11pt; }
      .content { max-width: 100%; padding: 0; }
      .cover-header { break-after: page; }
      pre { box-shadow: none; border: 2px solid #ccc; break-inside: avoid; }
      .svg-diagram { break-inside: avoid; border: 1px solid #ccc; }
      table { break-inside: avoid; }
      h2, h3 { break-after: avoid; }
    }

    /* === Responsive === */
    @media (max-width: 640px) {
      .content { padding: 16px 12px 40px; font-size: 15px; }
      h1 { font-size: 1.5em; }
      h2 { font-size: 1.25em; }
      pre code { font-size: 0.8em; padding: 12px; }
      thead th, tbody td { padding: 8px 10px; font-size: 0.88em; }
      .svg-diagram { padding: 10px; }
      .toc { padding: 14px 18px; }
      .chapter-nav { flex-direction: column; }
      .chapter-nav a { min-width: unset; }
      .nav-next { align-items: flex-start; }
      .cover-chapter-num { font-size: 1.5em; }
    }
  </style>
</head>
<body>
  <!-- Reading Progress Bar -->
  <div class="progress-bar" id="progressBar"></div>

  
<header class="cover-header">
  <div class="cover-part" style="--part-color: #2563eb">
    <span class="cover-part-label">Part 1: 시작하기</span>
  </div>
  <div class="cover-chapter-num">Chapter 04</div>
</header>

  <div class="content">
    <nav class="toc">
<h2 class="toc-title">목차</h2>
<ul>
<li><a href="#4-1-uvm-클래스-계층-구조">4.1 UVM 클래스 계층 구조</a></li>
  <li class="toc-sub"><a href="#4-1-1-uvm은-거대한-클래스-라이브러리">4.1.1 UVM은 거대한 클래스 라이브러리</a></li>
  <li class="toc-sub"><a href="#4-1-2-uvm-object와-uvm-component의-차이">4.1.2 uvm_object와 uvm_component의 차이</a></li>
  <li class="toc-sub"><a href="#4-1-3-생성자의-차이-parent가-핵심">4.1.3 생성자의 차이 — parent가 핵심</a></li>
  <li class="toc-sub"><a href="#4-1-4-실습-uvm-component-기본-예제">4.1.4 실습: uvm_component 기본 예제</a></li>
<li><a href="#4-2-factory-패턴-new-대신-create-를-쓰는-이유">4.2 Factory 패턴 — new() 대신 create()를 쓰는 이유</a></li>
  <li class="toc-sub"><a href="#4-2-1-먼저-new-로-만들어보면">4.2.1 먼저 new()로 만들어보면?</a></li>
  <li class="toc-sub"><a href="#4-2-2-new-의-문제-교체가-안-된다">4.2.2 new()의 문제 — 교체가 안 된다</a></li>
  <li class="toc-sub"><a href="#4-2-3-factory의-해결책-코드-수정-없이-교체">4.2.3 Factory의 해결책 — 코드 수정 없이 교체</a></li>
  <li class="toc-sub"><a href="#4-2-4-factory-사용법-3단계">4.2.4 Factory 사용법 3단계</a></li>
  <li class="toc-sub"><a href="#4-2-5-factory-매크로가-하는-일">4.2.5 Factory 매크로가 하는 일</a></li>
  <li class="toc-sub"><a href="#4-2-6-흔한-실수-매크로를-빠뜨리면">4.2.6 흔한 실수: 매크로를 빠뜨리면?</a></li>
  <li class="toc-sub"><a href="#4-2-7-factory-실습-예제">4.2.7 Factory 실습 예제</a></li>
<li><a href="#4-3-phase-메커니즘-시뮬레이션의-순서-관리">4.3 Phase 메커니즘 — 시뮬레이션의 순서 관리</a></li>
  <li class="toc-sub"><a href="#4-3-1-phase가-필요한-이유">4.3.1 Phase가 필요한 이유</a></li>
  <li class="toc-sub"><a href="#4-3-2-핵심-phase-3가지">4.3.2 핵심 Phase 3가지</a></li>
  <li class="toc-sub"><a href="#4-3-3-phase의-실행-순서-상세">4.3.3 Phase의 실행 순서 상세</a></li>
  <li class="toc-sub"><a href="#4-3-4-build-phase의-실행-순서-위에서-아래로">4.3.4 build_phase의 실행 순서 — 위에서 아래로</a></li>
  <li class="toc-sub"><a href="#4-3-5-phase에서-하면-안-되는-것">4.3.5 Phase에서 하면 안 되는 것</a></li>
  <li class="toc-sub"><a href="#4-3-6-run-phase와-objection-시뮬레이션-종료-조건">4.3.6 run_phase와 objection — 시뮬레이션 종료 조건</a></li>
  <li class="toc-sub"><a href="#4-3-7-phase-실습-실행-순서-확인">4.3.7 Phase 실습: 실행 순서 확인</a></li>
<li><a href="#4-4-종합-uvm-컴포넌트-작성-패턴">4.4 종합: UVM 컴포넌트 작성 패턴</a></li>
  <li class="toc-sub"><a href="#4-4-1-uvm-컴포넌트-작성-템플릿">4.4.1 UVM 컴포넌트 작성 템플릿</a></li>
  <li class="toc-sub"><a href="#4-4-2-uvm-object-작성-템플릿">4.4.2 uvm_object 작성 템플릿</a></li>
  <li class="toc-sub"><a href="#4-4-3-종합-실습-미니-검증-환경">4.4.3 종합 실습: 미니 검증 환경</a></li>
<li><a href="#4-5-체크포인트">4.5 체크포인트</a></li>
  <li class="toc-sub"><a href="#셀프-체크">셀프 체크</a></li>
  <li class="toc-sub"><a href="#연습문제">연습문제</a></li>
  <li class="toc-sub"><a href="#흔한-에러와-해결법">흔한 에러와 해결법</a></li>
  <li class="toc-sub"><a href="#용어-정리">용어 정리</a></li>
  <li class="toc-sub"><a href="#다음-챕터-미리보기">다음 챕터 미리보기</a></li>
</ul>
</nav>
    <h1>Chapter 4: UVM 기본 컴포넌트</h1>
<blockquote>
<p><strong>학습 목표</strong></p>
<ul>
<li><code>uvm_object</code>와 <code>uvm_component</code>의 차이를 이해한다</li>
<li>UVM Factory 패턴의 동작 원리를 이해하고, <code>type_id::create()</code>를 사용할 수 있다</li>
<li>Phase 메커니즘의 실행 순서를 이해하고, 각 Phase의 역할을 안다</li>
<li><code>`uvm_component_utils</code>와 <code>`uvm_object_utils</code> 매크로의 역할을 안다</li>
<li>간단한 UVM 컴포넌트를 직접 작성하고 실행할 수 있다</li>
</ul>
</blockquote>
<blockquote>
<p><strong>선수 지식</strong>: Chapter 3에서 배운 클래스(class), 상속(extends), 다형성(virtual), 생성자(new)를 사용합니다. 특히 &quot;부모 클래스를 extends로 확장한다&quot;는 개념이 핵심입니다.</p>
</blockquote>
<hr>
<h2 id="4-1-uvm-클래스-계층-구조">4.1 UVM 클래스 계층 구조</h2>
<blockquote>
<p><strong>이 절의 목표</strong>: UVM의 모든 클래스가 하나의 계층 트리에서 시작한다는 것을 이해하고, <code>uvm_object</code>와 <code>uvm_component</code>의 차이를 명확히 구분합니다.</p>
</blockquote>
<h3 id="4-1-1-uvm은-거대한-클래스-라이브러리">4.1.1 UVM은 거대한 클래스 라이브러리</h3>
<p>Chapter 3에서 class와 extends를 배웠습니다. UVM은 이 기능을 사용하여 만들어진 <strong>거대한 클래스 라이브러리</strong>입니다. UVM을 처음 배울 때 압도당하는 이유는 클래스가 수백 개이기 때문인데, 실제로 우리가 직접 다루는 클래스는 10개 미만입니다.</p>
<p>핵심만 보면 UVM의 클래스 계층은 매우 단순합니다:</p>

<div class="svg-diagram">
<svg viewBox="0 0 800 520" xmlns="http://www.w3.org/2000/svg" style="max-width:800px;width:100%">
  
  <style>
    .diagram-box { fill: #ffffff; stroke: #334155; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-accent { fill: #eff6ff; stroke: #2563eb; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-highlight { fill: #fef3c7; stroke: #f59e0b; stroke-width: 2.5; rx: 10; ry: 10; }
    .diagram-box-dark { fill: #1e293b; stroke: #1e293b; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-run { fill: #fef3c7; stroke: #f59e0b; stroke-width: 3; rx: 10; ry: 10; }
    .diagram-box-green { fill: #ecfdf5; stroke: #10b981; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-purple { fill: #f5f3ff; stroke: #7c3aed; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-red { fill: #fef2f2; stroke: #ef4444; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-gray { fill: #f8fafc; stroke: #94a3b8; stroke-width: 1.5; rx: 8; ry: 8; }
    .diagram-text { font-family: 'Noto Sans KR', sans-serif; fill: #1e293b; }
    .diagram-text-white { font-family: 'Noto Sans KR', sans-serif; fill: #ffffff; }
    .diagram-text-accent { font-family: 'Noto Sans KR', sans-serif; fill: #2563eb; }
    .diagram-text-small { font-family: 'Noto Sans KR', sans-serif; fill: #64748b; font-size: 12px; }
    .diagram-text-code { font-family: 'Fira Code', 'JetBrains Mono', monospace; fill: #1e293b; }
    .diagram-arrow { fill: none; stroke: #64748b; stroke-width: 1.5; }
    .diagram-arrow-accent { fill: none; stroke: #2563eb; stroke-width: 1.5; }
    .diagram-line { stroke: #cbd5e1; stroke-width: 1.5; stroke-dasharray: 6,3; }
  </style>
  <defs>
    <marker id="arrowhead" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#64748b" />
    </marker>
    <marker id="arrowhead-accent" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#2563eb" />
    </marker>
    <marker id="arrowhead-dark" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#1e293b" />
    </marker>
    <marker id="arrowhead-orange" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#f59e0b" />
    </marker>
    <filter id="shadow" x="-5%" y="-5%" width="115%" height="115%">
      <feDropShadow dx="0" dy="2" stdDeviation="3" flood-color="#000" flood-opacity="0.1"/>
    </filter>
  </defs>


  <!-- ===== Level 0: uvm_void ===== -->
  <rect x="260" y="8" width="160" height="34" class="diagram-box-gray" filter="url(#shadow)"/>
  <text x="340" y="30" text-anchor="middle" class="diagram-text-code" font-size="12">uvm_void</text>
  <line x1="340" y1="42" x2="340" y2="60" stroke="#64748b" stroke-width="1.5" marker-end="url(#arrowhead)"/>

  <!-- ===== Level 1: uvm_object (accent blue) ===== -->
  <rect x="230" y="62" width="220" height="40" class="diagram-box-accent" filter="url(#shadow)"/>
  <text x="340" y="87" text-anchor="middle" class="diagram-text-code" font-size="13" font-weight="bold">uvm_object</text>

  <!-- Distribution from uvm_object: 3 branches -->
  <line x1="340" y1="102" x2="340" y2="120" stroke="#64748b" stroke-width="2"/>
  <line x1="155" y1="120" x2="555" y2="120" stroke="#64748b" stroke-width="2"/>
  <line x1="155" y1="120" x2="155" y2="140" stroke="#64748b" stroke-width="1.5"/>
  <line x1="340" y1="120" x2="340" y2="140" stroke="#64748b" stroke-width="1.5"/>
  <line x1="555" y1="120" x2="555" y2="140" stroke="#64748b" stroke-width="1.5"/>

  <!-- ===== Level 2 Left: uvm_transaction ===== -->
  <rect x="65" y="142" width="180" height="34" class="diagram-box-gray" filter="url(#shadow)"/>
  <text x="155" y="164" text-anchor="middle" class="diagram-text-code" font-size="11">uvm_transaction</text>
  <line x1="155" y1="176" x2="155" y2="200" stroke="#64748b" stroke-width="1.5" marker-end="url(#arrowhead)"/>

  <!-- Level 3 Left: uvm_sequence_item -->
  <rect x="38" y="202" width="234" height="34" class="diagram-box-gray" filter="url(#shadow)"/>
  <text x="155" y="224" text-anchor="middle" class="diagram-text-code" font-size="11">uvm_sequence_item</text>
  <text x="280" y="224" class="diagram-text-small" font-size="9" fill="#64748b">Ch.6</text>

  <!-- ===== Level 2 Middle: uvm_sequence ===== -->
  <rect x="265" y="142" width="150" height="34" class="diagram-box-gray" filter="url(#shadow)"/>
  <text x="340" y="164" text-anchor="middle" class="diagram-text-code" font-size="11">uvm_sequence</text>
  <text x="422" y="164" class="diagram-text-small" font-size="9" fill="#64748b">Ch.6</text>

  <!-- ===== Level 2 Right: uvm_component (green) ===== -->
  <rect x="445" y="140" width="220" height="38" class="diagram-box-green" filter="url(#shadow)"/>
  <text x="555" y="164" text-anchor="middle" class="diagram-text-code" font-size="13" font-weight="bold">uvm_component</text>

  <!-- ===== Component children: vertical tree list ===== -->
  <!-- Trunk connector: from component bottom → left → vertical down -->
  <line x1="555" y1="178" x2="555" y2="194" stroke="#10b981" stroke-width="2"/>
  <line x1="505" y1="194" x2="555" y2="194" stroke="#10b981" stroke-width="2"/>
  <line x1="505" y1="194" x2="505" y2="444" stroke="#10b981" stroke-width="2"/>

  <!-- Horizontal tees from trunk to each child box -->
  <line x1="505" y1="216" x2="525" y2="216" stroke="#10b981" stroke-width="1.5"/>
  <line x1="505" y1="254" x2="525" y2="254" stroke="#10b981" stroke-width="1.5"/>
  <line x1="505" y1="292" x2="525" y2="292" stroke="#10b981" stroke-width="1.5"/>
  <line x1="505" y1="330" x2="525" y2="330" stroke="#10b981" stroke-width="1.5"/>
  <line x1="505" y1="368" x2="525" y2="368" stroke="#10b981" stroke-width="1.5"/>
  <line x1="505" y1="406" x2="525" y2="406" stroke="#10b981" stroke-width="1.5"/>
  <line x1="505" y1="444" x2="525" y2="444" stroke="#10b981" stroke-width="1.5"/>

  <!-- Child 1: uvm_test (highlight — students used it) -->
  <rect x="525" y="200" width="190" height="32" class="diagram-box-highlight" filter="url(#shadow)"/>
  <text x="620" y="221" text-anchor="middle" class="diagram-text-code" font-size="11" font-weight="bold">uvm_test</text>
  <text x="725" y="221" class="diagram-text-small" font-size="9" fill="#f59e0b">Ch.1-2</text>

  <!-- Child 2: uvm_env -->
  <rect x="525" y="238" width="190" height="32" class="diagram-box-gray" filter="url(#shadow)"/>
  <text x="620" y="259" text-anchor="middle" class="diagram-text-code" font-size="11">uvm_env</text>

  <!-- Child 3: uvm_agent -->
  <rect x="525" y="276" width="190" height="32" class="diagram-box-gray" filter="url(#shadow)"/>
  <text x="620" y="297" text-anchor="middle" class="diagram-text-code" font-size="11">uvm_agent</text>

  <!-- Child 4: uvm_driver -->
  <rect x="525" y="314" width="190" height="32" class="diagram-box-gray" filter="url(#shadow)"/>
  <text x="620" y="335" text-anchor="middle" class="diagram-text-code" font-size="11">uvm_driver</text>
  <text x="725" y="335" class="diagram-text-small" font-size="9" fill="#64748b">Ch.7</text>

  <!-- Child 5: uvm_monitor -->
  <rect x="525" y="352" width="190" height="32" class="diagram-box-gray" filter="url(#shadow)"/>
  <text x="620" y="373" text-anchor="middle" class="diagram-text-code" font-size="11">uvm_monitor</text>
  <text x="725" y="373" class="diagram-text-small" font-size="9" fill="#64748b">Ch.7</text>

  <!-- Child 6: uvm_sequencer -->
  <rect x="525" y="390" width="190" height="32" class="diagram-box-gray" filter="url(#shadow)"/>
  <text x="620" y="411" text-anchor="middle" class="diagram-text-code" font-size="11">uvm_sequencer</text>
  <text x="725" y="411" class="diagram-text-small" font-size="9" fill="#64748b">Ch.6</text>

  <!-- Child 7: uvm_scoreboard -->
  <rect x="525" y="428" width="190" height="32" class="diagram-box-gray" filter="url(#shadow)"/>
  <text x="620" y="449" text-anchor="middle" class="diagram-text-code" font-size="11">uvm_scoreboard</text>
  <text x="725" y="449" class="diagram-text-small" font-size="9" fill="#64748b">Ch.8</text>

  <!-- ===== Legend ===== -->
  <rect x="15" y="472" width="760" height="38" rx="8" ry="8" fill="#f8fafc" stroke="#cbd5e1" stroke-width="1"/>
  <rect x="35" y="483" width="14" height="14" class="diagram-box-accent" rx="3" ry="3"/>
  <text x="55" y="495" class="diagram-text-small" font-size="10">uvm_object (기반)</text>
  <rect x="200" y="483" width="14" height="14" class="diagram-box-green" rx="3" ry="3"/>
  <text x="220" y="495" class="diagram-text-small" font-size="10">uvm_component (구조)</text>
  <rect x="400" y="483" width="14" height="14" class="diagram-box-highlight" rx="3" ry="3"/>
  <text x="420" y="495" class="diagram-text-small" font-size="10">사용 경험 있음</text>
  <rect x="560" y="483" width="14" height="14" class="diagram-box-gray" rx="3" ry="3"/>
  <text x="580" y="495" class="diagram-text-small" font-size="10">앞으로 배울 것</text>
</svg>
</div><blockquote>
<p><strong>참고</strong>: 위 계층도는 학습에 필요한 핵심 클래스만 표시한 것입니다. 실제 UVM 라이브러리에는 중간 단계의 클래스(uvm_sequence_base, uvm_driver #(REQ,RSP) 등)가 더 있지만, 사용법은 동일하므로 지금은 이 구조만 기억하면 충분합니다.</p>
</blockquote>
<blockquote>
<p><strong>핵심</strong>: 모든 UVM 클래스는 <code>uvm_object</code>에서 시작합니다. 그리고 크게 두 가지로 나뉩니다:</p>
<ul>
<li><strong>uvm_object 계열</strong>: 데이터를 담는 용도 (트랜잭션, 시퀀스)</li>
<li><strong>uvm_component 계열</strong>: 테스트벤치 구조를 만드는 용도 (테스트, 드라이버 등)</li>
</ul>
</blockquote>
<h3 id="4-1-2-uvm-object와-uvm-component의-차이">4.1.2 uvm_object와 uvm_component의 차이</h3>
<p>이 둘의 차이가 UVM을 이해하는 첫 번째 관문입니다:</p>
<table>
<thead>
<tr>
<th>비교 항목</th>
<th><code>uvm_object</code></th>
<th><code>uvm_component</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>역할</strong></td>
<td>데이터를 담는 그릇</td>
<td>테스트벤치의 뼈대(구조)</td>
</tr>
<tr>
<td><strong>비유</strong></td>
<td>택배 상자 (만들고 버림)</td>
<td>건물의 방 (한 번 짓고 계속 사용)</td>
</tr>
<tr>
<td><strong>생명 주기</strong></td>
<td>필요할 때 생성, 사용 후 소멸</td>
<td>시뮬레이션 시작 시 생성, 끝까지 유지</td>
</tr>
<tr>
<td><strong>부모-자식 관계</strong></td>
<td>없음</td>
<td>있음 (트리 구조)</td>
</tr>
<tr>
<td><strong>Phase</strong></td>
<td>없음</td>
<td>있음 (build → connect → run)</td>
</tr>
<tr>
<td><strong>생성자</strong></td>
<td><code>new(string name)</code></td>
<td><code>new(string name, uvm_component parent)</code></td>
</tr>
<tr>
<td><strong>대표 예시</strong></td>
<td>트랜잭션, 시퀀스</td>
<td>드라이버, 모니터, 환경</td>
</tr>
</tbody></table>

<div class="svg-diagram">
<svg viewBox="0 0 700 260" xmlns="http://www.w3.org/2000/svg" style="max-width:700px;width:100%">
  
  <style>
    .diagram-box { fill: #ffffff; stroke: #334155; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-accent { fill: #eff6ff; stroke: #2563eb; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-highlight { fill: #fef3c7; stroke: #f59e0b; stroke-width: 2.5; rx: 10; ry: 10; }
    .diagram-box-dark { fill: #1e293b; stroke: #1e293b; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-run { fill: #fef3c7; stroke: #f59e0b; stroke-width: 3; rx: 10; ry: 10; }
    .diagram-box-green { fill: #ecfdf5; stroke: #10b981; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-purple { fill: #f5f3ff; stroke: #7c3aed; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-red { fill: #fef2f2; stroke: #ef4444; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-gray { fill: #f8fafc; stroke: #94a3b8; stroke-width: 1.5; rx: 8; ry: 8; }
    .diagram-text { font-family: 'Noto Sans KR', sans-serif; fill: #1e293b; }
    .diagram-text-white { font-family: 'Noto Sans KR', sans-serif; fill: #ffffff; }
    .diagram-text-accent { font-family: 'Noto Sans KR', sans-serif; fill: #2563eb; }
    .diagram-text-small { font-family: 'Noto Sans KR', sans-serif; fill: #64748b; font-size: 12px; }
    .diagram-text-code { font-family: 'Fira Code', 'JetBrains Mono', monospace; fill: #1e293b; }
    .diagram-arrow { fill: none; stroke: #64748b; stroke-width: 1.5; }
    .diagram-arrow-accent { fill: none; stroke: #2563eb; stroke-width: 1.5; }
    .diagram-line { stroke: #cbd5e1; stroke-width: 1.5; stroke-dasharray: 6,3; }
  </style>
  <defs>
    <marker id="arrowhead" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#64748b" />
    </marker>
    <marker id="arrowhead-accent" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#2563eb" />
    </marker>
    <marker id="arrowhead-dark" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#1e293b" />
    </marker>
    <marker id="arrowhead-orange" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#f59e0b" />
    </marker>
    <filter id="shadow" x="-5%" y="-5%" width="115%" height="115%">
      <feDropShadow dx="0" dy="2" stdDeviation="3" flood-color="#000" flood-opacity="0.1"/>
    </filter>
  </defs>

  <!-- Left: uvm_object -->
  <rect x="20" y="10" width="280" height="240" class="diagram-box-accent" filter="url(#shadow)"/>
  <rect x="20" y="10" width="280" height="34" rx="10" ry="10" fill="#2563eb"/>
  <rect x="20" y="32" width="280" height="12" fill="#2563eb"/>
  <text x="160" y="33" text-anchor="middle" class="diagram-text-white" font-size="13" font-weight="bold">uvm_object (택배 상자)</text>

  <text x="45" y="72" class="diagram-text" font-size="12" font-weight="600">시뮬레이션 중</text>
  <text x="45" y="96" class="diagram-text" font-size="12" font-weight="600">수백~수천 개 생성</text>
  <text x="45" y="120" class="diagram-text" font-size="12">사용 후 버려짐</text>
  <line x1="40" y1="134" x2="280" y2="134" stroke="#bfdbfe" stroke-width="1" stroke-dasharray="4,3"/>
  <text x="45" y="156" class="diagram-text-small" font-size="11">부모-자식 관계: 없음</text>
  <text x="45" y="178" class="diagram-text-small" font-size="11">Phase: 없음</text>
  <line x1="40" y1="192" x2="280" y2="192" stroke="#bfdbfe" stroke-width="1" stroke-dasharray="4,3"/>
  <text x="45" y="214" class="diagram-text-code" font-size="11">new(string name)</text>
  <text x="45" y="236" class="diagram-text-small" font-size="10">예: 패킷 데이터, 트랜잭션</text>

  <!-- VS badge (yellow circle) -->
  <circle cx="350" cy="130" r="22" fill="#f59e0b" filter="url(#shadow)"/>
  <text x="350" y="136" text-anchor="middle" class="diagram-text-white" font-size="14" font-weight="bold">vs</text>

  <!-- Right: uvm_component -->
  <rect x="400" y="10" width="280" height="240" class="diagram-box-green" filter="url(#shadow)"/>
  <rect x="400" y="10" width="280" height="34" rx="10" ry="10" fill="#10b981"/>
  <rect x="400" y="32" width="280" height="12" fill="#10b981"/>
  <text x="540" y="33" text-anchor="middle" class="diagram-text-white" font-size="13" font-weight="bold">uvm_component (건물의 방)</text>

  <text x="425" y="72" class="diagram-text" font-size="12" font-weight="600">시뮬레이션 시작 시</text>
  <text x="425" y="96" class="diagram-text" font-size="12" font-weight="600">한 번만 생성</text>
  <text x="425" y="120" class="diagram-text" font-size="12">끝까지 유지</text>
  <line x1="420" y1="134" x2="660" y2="134" stroke="#86efac" stroke-width="1" stroke-dasharray="4,3"/>
  <text x="425" y="156" class="diagram-text-small" font-size="11">부모-자식 관계: 있음 (트리)</text>
  <text x="425" y="178" class="diagram-text-small" font-size="11">Phase: 있음 (build/connect/run)</text>
  <line x1="420" y1="192" x2="660" y2="192" stroke="#86efac" stroke-width="1" stroke-dasharray="4,3"/>
  <text x="425" y="214" class="diagram-text-code" font-size="11">new(name, parent)</text>
  <text x="425" y="236" class="diagram-text-small" font-size="10">예: 드라이버, 모니터, 환경</text>
</svg>
</div><blockquote>
<p><strong>기억하세요</strong>: &quot;<strong>데이터는 object, 구조는 component</strong>&quot;. 택배 상자(object)는 매번 새로 만들지만, 택배 시스템의 분류기(component)는 한 번 설치하고 계속 사용합니다.</p>
</blockquote>
<h3 id="4-1-3-생성자의-차이-parent가-핵심">4.1.3 생성자의 차이 — parent가 핵심</h3>
<p>Chapter 3에서 배운 <code>new()</code>를 UVM에서는 약간 다르게 사용합니다:</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// uvm_object 계열: 이름만 필요</span>
<span class="hljs-keyword">class</span> my_transaction <span class="hljs-keyword">extends</span> uvm_sequence_item;
  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;my_transaction&quot;</span>);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);        <span class="hljs-comment">// 이름만 전달</span>
  <span class="hljs-keyword">endfunction</span>
<span class="hljs-keyword">endclass</span>

<span class="hljs-comment">// uvm_component 계열: 이름 + 부모(parent) 필요</span>
<span class="hljs-keyword">class</span> my_driver <span class="hljs-keyword">extends</span> uvm_driver;
  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);  <span class="hljs-comment">// 이름과 부모 전달</span>
  <span class="hljs-keyword">endfunction</span>
<span class="hljs-keyword">endclass</span>
</code></pre><p><code>uvm_component</code>에 <code>parent</code>가 필요한 이유는 <strong>컴포넌트 트리</strong>를 만들기 위해서입니다:</p>

<div class="svg-diagram">
<svg viewBox="0 0 600 340" xmlns="http://www.w3.org/2000/svg" style="max-width:600px;width:100%">
  
  <style>
    .diagram-box { fill: #ffffff; stroke: #334155; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-accent { fill: #eff6ff; stroke: #2563eb; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-highlight { fill: #fef3c7; stroke: #f59e0b; stroke-width: 2.5; rx: 10; ry: 10; }
    .diagram-box-dark { fill: #1e293b; stroke: #1e293b; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-run { fill: #fef3c7; stroke: #f59e0b; stroke-width: 3; rx: 10; ry: 10; }
    .diagram-box-green { fill: #ecfdf5; stroke: #10b981; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-purple { fill: #f5f3ff; stroke: #7c3aed; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-red { fill: #fef2f2; stroke: #ef4444; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-gray { fill: #f8fafc; stroke: #94a3b8; stroke-width: 1.5; rx: 8; ry: 8; }
    .diagram-text { font-family: 'Noto Sans KR', sans-serif; fill: #1e293b; }
    .diagram-text-white { font-family: 'Noto Sans KR', sans-serif; fill: #ffffff; }
    .diagram-text-accent { font-family: 'Noto Sans KR', sans-serif; fill: #2563eb; }
    .diagram-text-small { font-family: 'Noto Sans KR', sans-serif; fill: #64748b; font-size: 12px; }
    .diagram-text-code { font-family: 'Fira Code', 'JetBrains Mono', monospace; fill: #1e293b; }
    .diagram-arrow { fill: none; stroke: #64748b; stroke-width: 1.5; }
    .diagram-arrow-accent { fill: none; stroke: #2563eb; stroke-width: 1.5; }
    .diagram-line { stroke: #cbd5e1; stroke-width: 1.5; stroke-dasharray: 6,3; }
  </style>
  <defs>
    <marker id="arrowhead" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#64748b" />
    </marker>
    <marker id="arrowhead-accent" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#2563eb" />
    </marker>
    <marker id="arrowhead-dark" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#1e293b" />
    </marker>
    <marker id="arrowhead-orange" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#f59e0b" />
    </marker>
    <filter id="shadow" x="-5%" y="-5%" width="115%" height="115%">
      <feDropShadow dx="0" dy="2" stdDeviation="3" flood-color="#000" flood-opacity="0.1"/>
    </filter>
  </defs>

  <!-- uvm_test_top (highlight) -->
  <rect x="180" y="10" width="240" height="44" class="diagram-box-highlight" filter="url(#shadow)"/>
  <text x="300" y="30" text-anchor="middle" class="diagram-text-code" font-size="13" font-weight="bold">uvm_test_top (테스트)</text>
  <text x="440" y="38" class="diagram-text-small" font-size="10">트리의 최상위</text>
  <line x1="300" y1="54" x2="300" y2="84" stroke="#64748b" stroke-width="1.5" marker-end="url(#arrowhead)"/>

  <!-- env (accent) -->
  <rect x="200" y="88" width="200" height="44" class="diagram-box-accent" filter="url(#shadow)"/>
  <text x="300" y="108" text-anchor="middle" class="diagram-text-code" font-size="13" font-weight="bold">env (환경)</text>
  <text x="420" y="116" class="diagram-text-small" font-size="10">parent = uvm_test_top</text>
  <line x1="300" y1="132" x2="300" y2="162" stroke="#64748b" stroke-width="1.5" marker-end="url(#arrowhead)"/>

  <!-- agent (green) -->
  <rect x="210" y="166" width="180" height="44" class="diagram-box-green" filter="url(#shadow)"/>
  <text x="300" y="186" text-anchor="middle" class="diagram-text-code" font-size="13" font-weight="bold">agent (에이전트)</text>
  <text x="410" y="194" class="diagram-text-small" font-size="10">parent = env</text>

  <!-- Branch lines from agent -->
  <line x1="300" y1="210" x2="300" y2="240" stroke="#64748b" stroke-width="2"/>
  <line x1="140" y1="240" x2="460" y2="240" stroke="#64748b" stroke-width="2"/>
  <line x1="140" y1="240" x2="140" y2="260" stroke="#64748b" stroke-width="1.5"/>
  <line x1="300" y1="240" x2="300" y2="260" stroke="#64748b" stroke-width="1.5"/>
  <line x1="460" y1="240" x2="460" y2="260" stroke="#64748b" stroke-width="1.5"/>

  <!-- driver (gray) -->
  <rect x="70" y="264" width="140" height="44" class="diagram-box-gray" filter="url(#shadow)"/>
  <text x="140" y="284" text-anchor="middle" class="diagram-text-code" font-size="12">driver (드라이버)</text>
  <text x="140" y="302" text-anchor="middle" class="diagram-text-small" font-size="9">parent = agent</text>

  <!-- monitor (gray) -->
  <rect x="230" y="264" width="140" height="44" class="diagram-box-gray" filter="url(#shadow)"/>
  <text x="300" y="284" text-anchor="middle" class="diagram-text-code" font-size="12">monitor (모니터)</text>
  <text x="300" y="302" text-anchor="middle" class="diagram-text-small" font-size="9">parent = agent</text>

  <!-- sequencer (gray) -->
  <rect x="390" y="264" width="140" height="44" class="diagram-box-gray" filter="url(#shadow)"/>
  <text x="460" y="284" text-anchor="middle" class="diagram-text-code" font-size="12">sequencer (시퀀서)</text>
  <text x="460" y="302" text-anchor="middle" class="diagram-text-small" font-size="9">parent = agent</text>
</svg>
</div><blockquote>
<p><strong>UVM과의 연결</strong>: Chapter 1-2에서 <code>class hello_test extends uvm_test</code>를 작성했을 때, UVM이 내부적으로 <code>hello_test</code>를 트리의 최상위에 배치했습니다. Chapter 5에서 실제 환경(env), 에이전트(agent)를 추가하면 이 트리가 확장됩니다.</p>
</blockquote>
<h3 id="4-1-4-실습-uvm-component-기본-예제">4.1.4 실습: uvm_component 기본 예제</h3>
<p>Chapter 1-2에서 이미 <code>uvm_test</code>를 사용해봤습니다. 이번에는 <code>uvm_component</code>를 직접 만들어봅시다:</p>
<p><strong>[예제 4-1] 간단한 uvm_component 작성</strong></p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// 파일: testbench.sv (EDA Playground)</span>
<span class="hljs-comment">// [예제 4-1] uvm_component 기본 사용</span>
<span class="hljs-comment">// 목적: uvm_component 생성, 부모-자식 관계, 기본 Phase 이해</span>
<span class="hljs-comment">// 시뮬레이터 설정: SystemVerilog, UVM 1.2 (Chapter 2와 동일)</span>

<span class="hljs-meta">`<span class="hljs-keyword">include</span> &quot;uvm_macros.svh&quot;</span>
<span class="hljs-keyword">import</span> uvm_pkg::*;

<span class="hljs-comment">// ── 커스텀 컴포넌트 정의 ──</span>
<span class="hljs-comment">// uvm_component를 extends하여 나만의 컴포넌트를 만듭니다</span>
<span class="hljs-keyword">class</span> my_component <span class="hljs-keyword">extends</span> uvm_component;

  <span class="hljs-comment">// ⭐ Factory 등록 매크로 (4.2절에서 자세히 설명)</span>
  <span class="hljs-comment">// 지금은 &quot;이 줄이 있어야 UVM이 이 클래스를 인식한다&quot; 정도로 이해하세요</span>
  `uvm_component_utils(my_component)

  <span class="hljs-comment">// 생성자: 이름과 부모를 받습니다</span>
  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-comment">// build_phase: 시뮬레이션 시작 전, 하위 컴포넌트를 생성하는 단계</span>
  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);  <span class="hljs-comment">// ⚠️ 반드시 호출! (아래 설명 참조)</span>
    `uvm_info(get_type_name(), <span class="hljs-string">&quot;build_phase 실행됨&quot;</span>, UVM_MEDIUM)
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-comment">// connect_phase: 컴포넌트 간 연결을 설정하는 단계</span>
  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> connect_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.connect_phase</span>(phase);
    `uvm_info(get_type_name(), <span class="hljs-string">&quot;connect_phase 실행됨&quot;</span>, UVM_MEDIUM)
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-comment">// run_phase: 실제 시뮬레이션이 실행되는 단계</span>
  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> run_phase(uvm_phase phase);
    phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);
    `uvm_info(get_type_name(), <span class="hljs-string">&quot;run_phase 시작!&quot;</span>, UVM_MEDIUM)
    #<span class="hljs-number">100</span>;
    `uvm_info(get_type_name(), <span class="hljs-string">&quot;run_phase 완료!&quot;</span>, UVM_MEDIUM)
    phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);
  <span class="hljs-keyword">endtask</span>

<span class="hljs-keyword">endclass</span>

<span class="hljs-comment">// ── 테스트 클래스 ──</span>
<span class="hljs-keyword">class</span> my_test <span class="hljs-keyword">extends</span> uvm_test;
  `uvm_component_utils(my_test)

  my_component comp;  <span class="hljs-comment">// 하위 컴포넌트 핸들 선언</span>

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-comment">// build_phase에서 하위 컴포넌트 생성</span>
  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);
    <span class="hljs-comment">// ⭐ Factory를 통한 생성 (4.2절에서 자세히 설명)</span>
    comp = my_component::type_id::create(<span class="hljs-string">&quot;comp&quot;</span>, <span class="hljs-keyword">this</span>);
    `uvm_info(get_type_name(), <span class="hljs-string">&quot;my_component를 생성했습니다!&quot;</span>, UVM_MEDIUM)
  <span class="hljs-keyword">endfunction</span>

<span class="hljs-keyword">endclass</span>

<span class="hljs-comment">// ── 실행 ──</span>
<span class="hljs-keyword">module</span> top;
  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span>
    run_test(<span class="hljs-string">&quot;my_test&quot;</span>);
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</code></pre><p><strong>예상 출력</strong>:</p>
<pre><code>UVM_INFO @ 0: uvm_test_top [my_test] my_component를 생성했습니다!
UVM_INFO @ 0: uvm_test_top.comp [my_component] build_phase 실행됨
UVM_INFO @ 0: uvm_test_top.comp [my_component] connect_phase 실행됨
UVM_INFO @ 0: uvm_test_top.comp [my_component] run_phase 시작!
UVM_INFO @ 100: uvm_test_top.comp [my_component] run_phase 완료!
</code></pre><blockquote>
<p><strong>관찰 포인트</strong>: 출력에서 <code>uvm_test_top.comp</code>라는 경로에 주목하세요. <code>uvm_test_top</code>은 UVM이 자동으로 만드는 최상위 이름이고, <code>comp</code>는 우리가 <code>create(&quot;comp&quot;, this)</code>에서 지정한 이름입니다. 이것이 컴포넌트 트리의 경로입니다.</p>
</blockquote>
<blockquote>
<p><strong>참고</strong>: 예상 출력의 세부 형식(타임스탬프, 줄 번호 등)은 시뮬레이터에 따라 다를 수 있습니다. <code>[my_component] build_phase 실행됨</code> 같은 핵심 메시지가 순서대로 나오면 정상입니다.</p>
</blockquote>
<blockquote>
<p><strong>중요: super.build_phase(phase)를 반드시 호출하세요</strong>
위 코드에서 <code>super.build_phase(phase);</code>를 빠뜨리면 어떻게 될까요? 겉보기에는 동작하는 것 같지만, Chapter 5에서 배울 <code>uvm_config_db</code>(설정값 전달 기능)가 제대로 동작하지 않게 됩니다. UVM의 build_phase는 부모 클래스에서 중요한 초기화 작업을 하므로, <strong>모든 Phase 함수의 첫 줄에 <code>super.xxx_phase(phase);</code>를 호출하는 습관</strong>을 들이세요.</p>
</blockquote>
<hr>
<h2 id="4-2-factory-패턴-new-대신-create-를-쓰는-이유">4.2 Factory 패턴 — new() 대신 create()를 쓰는 이유</h2>
<blockquote>
<p><strong>이 절의 목표</strong>: UVM Factory의 필요성을 이해하고, <code>type_id::create()</code>로 객체를 생성하는 방법을 익힙니다.</p>
</blockquote>
<h3 id="4-2-1-먼저-new-로-만들어보면">4.2.1 먼저 new()로 만들어보면?</h3>
<p>Chapter 3에서 객체를 만들 때 <code>new()</code>를 사용했습니다. UVM에서도 <code>new()</code>로 만들 수 있긴 합니다:</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// ❌ 직접 new()로 생성 (동작하지만 권장하지 않음)</span>
<span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
  <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);
  comp = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;comp&quot;</span>, <span class="hljs-keyword">this</span>);  <span class="hljs-comment">// 직접 생성</span>
<span class="hljs-keyword">endfunction</span>
</code></pre><p>이 코드는 동작합니다. 그런데 왜 UVM에서는 <code>new()</code> 대신 더 복잡해 보이는 <code>type_id::create()</code>를 쓸까요?</p>
<h3 id="4-2-2-new-의-문제-교체가-안-된다">4.2.2 new()의 문제 — 교체가 안 된다</h3>
<p>실무 시나리오로 이해해봅시다:</p>
<blockquote>
<p><strong>시나리오</strong>: 당신은 UART 검증 환경을 만들었습니다. 기본 드라이버(<code>uart_driver</code>)가 잘 동작합니다. 그런데 어느 날 팀장이 말합니다: &quot;에러 주입 기능이 있는 드라이버(<code>error_uart_driver</code>)로 바꿔서 테스트해봐.&quot;</p>
</blockquote>
<p><strong>new()를 사용했다면:</strong></p>
<pre><code class="hljs language-systemverilog"><span class="hljs-keyword">class</span> uart_agent <span class="hljs-keyword">extends</span> uvm_agent;
  uart_driver drv;

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);
    drv = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;drv&quot;</span>, <span class="hljs-keyword">this</span>);  <span class="hljs-comment">// uart_driver로 고정!</span>
  <span class="hljs-keyword">endfunction</span>
<span class="hljs-keyword">endclass</span>
</code></pre><p><code>error_uart_driver</code>로 교체하려면 이 코드를 <strong>직접 수정</strong>해야 합니다:</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// ❌ 코드 직접 수정 필요</span>
drv = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;drv&quot;</span>, <span class="hljs-keyword">this</span>);  <span class="hljs-comment">// 이 줄을 찾아서</span>
<span class="hljs-comment">// 아래로 변경</span>
error_drv = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;drv&quot;</span>, <span class="hljs-keyword">this</span>);  <span class="hljs-comment">// 이렇게 바꿔야 함</span>
</code></pre><p>프로젝트가 커지면 수십 개의 파일을 수정해야 할 수도 있습니다!</p>
<h3 id="4-2-3-factory의-해결책-코드-수정-없이-교체">4.2.3 Factory의 해결책 — 코드 수정 없이 교체</h3>
<p>Factory를 사용하면 <strong>코드를 한 줄도 수정하지 않고</strong> 컴포넌트를 교체할 수 있습니다:</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-keyword">class</span> uart_agent <span class="hljs-keyword">extends</span> uvm_agent;
  uart_driver drv;

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);
    drv = uart_driver::type_id::create(<span class="hljs-string">&quot;drv&quot;</span>, <span class="hljs-keyword">this</span>);  <span class="hljs-comment">// Factory를 통한 생성</span>
  <span class="hljs-keyword">endfunction</span>
<span class="hljs-keyword">endclass</span>
</code></pre><p>교체할 때는 <strong>테스트 클래스에서 한 줄만 추가</strong>하면 됩니다. 환경 코드(<code>uart_agent</code>)는 전혀 수정할 필요가 없습니다. 이것이 Factory의 핵심 가치입니다.</p>
<blockquote>
<p><strong>미리보기</strong>: Factory override(교체)의 구체적인 코드와 사용법은 이후 챕터에서 실습합니다. 지금은 &quot;create()를 쓰면 나중에 코드 수정 없이 교체할 수 있다&quot;는 것만 기억하세요.</p>
</blockquote>
<blockquote>
<p><strong>비유</strong>: Factory = <strong>자동차 조립 공장의 부품 교체 시스템</strong></p>
<ul>
<li><code>new()</code> = 부품을 직접 용접 (교체하려면 용접을 뜯어야 함)</li>
<li><code>create()</code> = 부품을 규격화된 슬롯에 끼움 (같은 규격이면 다른 부품으로 바로 교체 가능)</li>
</ul>
</blockquote>

<div class="svg-diagram">
<svg viewBox="0 0 760 280" xmlns="http://www.w3.org/2000/svg" style="max-width:760px;width:100%">
  
  <style>
    .diagram-box { fill: #ffffff; stroke: #334155; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-accent { fill: #eff6ff; stroke: #2563eb; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-highlight { fill: #fef3c7; stroke: #f59e0b; stroke-width: 2.5; rx: 10; ry: 10; }
    .diagram-box-dark { fill: #1e293b; stroke: #1e293b; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-run { fill: #fef3c7; stroke: #f59e0b; stroke-width: 3; rx: 10; ry: 10; }
    .diagram-box-green { fill: #ecfdf5; stroke: #10b981; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-purple { fill: #f5f3ff; stroke: #7c3aed; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-red { fill: #fef2f2; stroke: #ef4444; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-gray { fill: #f8fafc; stroke: #94a3b8; stroke-width: 1.5; rx: 8; ry: 8; }
    .diagram-text { font-family: 'Noto Sans KR', sans-serif; fill: #1e293b; }
    .diagram-text-white { font-family: 'Noto Sans KR', sans-serif; fill: #ffffff; }
    .diagram-text-accent { font-family: 'Noto Sans KR', sans-serif; fill: #2563eb; }
    .diagram-text-small { font-family: 'Noto Sans KR', sans-serif; fill: #64748b; font-size: 12px; }
    .diagram-text-code { font-family: 'Fira Code', 'JetBrains Mono', monospace; fill: #1e293b; }
    .diagram-arrow { fill: none; stroke: #64748b; stroke-width: 1.5; }
    .diagram-arrow-accent { fill: none; stroke: #2563eb; stroke-width: 1.5; }
    .diagram-line { stroke: #cbd5e1; stroke-width: 1.5; stroke-dasharray: 6,3; }
  </style>
  <defs>
    <marker id="arrowhead" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#64748b" />
    </marker>
    <marker id="arrowhead-accent" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#2563eb" />
    </marker>
    <marker id="arrowhead-dark" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#1e293b" />
    </marker>
    <marker id="arrowhead-orange" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#f59e0b" />
    </marker>
    <filter id="shadow" x="-5%" y="-5%" width="115%" height="115%">
      <feDropShadow dx="0" dy="2" stdDeviation="3" flood-color="#000" flood-opacity="0.1"/>
    </filter>
  </defs>

  <!-- Left: new() 방식 (red border) -->
  <rect x="10" y="10" width="320" height="260" rx="12" ry="12" fill="#fef2f2" stroke="#ef4444" stroke-width="2" filter="url(#shadow)"/>
  <rect x="10" y="10" width="320" height="32" rx="12" ry="12" fill="#ef4444"/>
  <rect x="10" y="30" width="320" height="12" fill="#ef4444"/>
  <text x="170" y="32" text-anchor="middle" class="diagram-text-white" font-size="13" font-weight="bold">new() 방식</text>

  <!-- uart_agent box (left) -->
  <rect x="40" y="56" width="200" height="100" class="diagram-box" filter="url(#shadow)"/>
  <text x="140" y="80" text-anchor="middle" class="diagram-text-code" font-size="12" font-weight="bold">uart_agent</text>
  <line x1="60" y1="90" x2="220" y2="90" stroke="#cbd5e1" stroke-width="1"/>
  <text x="140" y="112" text-anchor="middle" class="diagram-text-code" font-size="11">drv = new()</text>
  <text x="140" y="134" text-anchor="middle" class="diagram-text" font-size="11" fill="#ef4444" font-weight="bold">(고정됨)</text>

  <!-- Arrow to "코드 수정 필요!" -->
  <line x1="240" y1="105" x2="300" y2="105" stroke="#ef4444" stroke-width="1.5" marker-end="url(#arrowhead)" stroke-dasharray="6,3"/>
  <text x="270" y="90" text-anchor="middle" class="diagram-text" font-size="9" fill="#ef4444" font-weight="bold" transform="rotate(-30, 270, 90)">교체 시</text>

  <!-- 코드 수정 필요 label -->
  <rect x="50" y="176" width="220" height="36" rx="6" ry="6" fill="#fecaca" stroke="#ef4444" stroke-width="1.5"/>
  <text x="160" y="199" text-anchor="middle" class="diagram-text" font-size="12" fill="#ef4444" font-weight="bold">코드 수정 필요!</text>
  <text x="160" y="234" text-anchor="middle" class="diagram-text-code" font-size="10" fill="#ef4444">error_drv = new()</text>
  <text x="160" y="256" text-anchor="middle" class="diagram-text-small" font-size="10">직접 코드를 변경해야 함</text>

  <!-- Right: Factory (create) 방식 (green border) -->
  <rect x="370" y="10" width="380" height="260" rx="12" ry="12" fill="#ecfdf5" stroke="#10b981" stroke-width="2" filter="url(#shadow)"/>
  <rect x="370" y="10" width="380" height="32" rx="12" ry="12" fill="#10b981"/>
  <rect x="370" y="30" width="380" height="12" fill="#10b981"/>
  <text x="560" y="32" text-anchor="middle" class="diagram-text-white" font-size="13" font-weight="bold">Factory (create) 방식</text>

  <!-- uart_agent box (right) -->
  <rect x="390" y="56" width="180" height="100" class="diagram-box" filter="url(#shadow)"/>
  <text x="480" y="80" text-anchor="middle" class="diagram-text-code" font-size="12" font-weight="bold">uart_agent</text>
  <line x1="410" y1="90" x2="550" y2="90" stroke="#cbd5e1" stroke-width="1"/>
  <text x="480" y="112" text-anchor="middle" class="diagram-text-code" font-size="11">drv = create()</text>
  <text x="480" y="134" text-anchor="middle" class="diagram-text" font-size="11" fill="#10b981" font-weight="bold">(Factory에 요청)</text>

  <!-- Arrow to Factory -->
  <line x1="570" y1="105" x2="620" y2="105" stroke="#2563eb" stroke-width="1.5" marker-end="url(#arrowhead-accent)"/>

  <!-- Factory box -->
  <rect x="624" y="78" width="100" height="50" class="diagram-box-accent" filter="url(#shadow)"/>
  <text x="674" y="108" text-anchor="middle" class="diagram-text-code" font-size="12" font-weight="bold">Factory</text>

  <!-- Arrow to 실제 객체 -->
  <line x1="674" y1="128" x2="674" y2="158" stroke="#2563eb" stroke-width="1.5" marker-end="url(#arrowhead-accent)"/>

  <!-- 실제 객체 box -->
  <rect x="614" y="162" width="120" height="40" class="diagram-box-green" filter="url(#shadow)"/>
  <text x="674" y="187" text-anchor="middle" class="diagram-text" font-size="12" font-weight="bold">실제 객체</text>

  <!-- Override arrow -->
  <line x1="674" y1="220" x2="674" y2="248" stroke="#f59e0b" stroke-width="1.5" marker-end="url(#arrowhead)"/>
  <text x="674" y="260" text-anchor="middle" class="diagram-text-code" font-size="10" fill="#f59e0b" font-weight="bold">set_type_override()</text>

  <!-- 코드 수정 없음 label -->
  <rect x="400" y="176" width="190" height="36" rx="6" ry="6" fill="#bbf7d0" stroke="#10b981" stroke-width="1.5"/>
  <text x="495" y="199" text-anchor="middle" class="diagram-text" font-size="12" fill="#10b981" font-weight="bold">코드 수정 없음!</text>
  <text x="495" y="234" text-anchor="middle" class="diagram-text-small" font-size="10">테스트에서 override만 설정</text>
</svg>
</div><blockquote>
<p><strong>실무 팁</strong>: 팹리스에서 검증 환경을 만들면, 프로젝트 끝날 때까지 수십 번의 변경이 생깁니다. Factory를 사용하면 환경 코드를 수정하지 않고 테스트 클래스에서만 교체할 수 있어서, 코드 안정성이 크게 높아집니다.</p>
</blockquote>
<blockquote>
<p><strong>면접 빈출</strong>: &quot;UVM Factory 패턴을 설명하세요&quot;는 검증 엔지니어 면접에서 가장 자주 나오는 질문 중 하나입니다. &quot;코드 수정 없이 컴포넌트를 교체할 수 있게 해주는 메커니즘&quot;이라고 답하면 됩니다.</p>
</blockquote>
<h3 id="4-2-4-factory-사용법-3단계">4.2.4 Factory 사용법 3단계</h3>
<p>Factory를 사용하려면 3가지가 필요합니다:</p>
<p><strong>1단계: Factory에 등록 (매크로)</strong></p>
<pre><code class="hljs language-systemverilog"><span class="hljs-keyword">class</span> my_driver <span class="hljs-keyword">extends</span> uvm_driver;
  `uvm_component_utils(my_driver)    <span class="hljs-comment">// uvm_component 계열</span>
  <span class="hljs-comment">// ...</span>
<span class="hljs-keyword">endclass</span>

<span class="hljs-keyword">class</span> my_transaction <span class="hljs-keyword">extends</span> uvm_sequence_item;
  `uvm_object_utils(my_transaction)  <span class="hljs-comment">// uvm_object 계열</span>
  <span class="hljs-comment">// ...</span>
<span class="hljs-keyword">endclass</span>
</code></pre><table>
<thead>
<tr>
<th>매크로</th>
<th>대상</th>
<th>용도</th>
</tr>
</thead>
<tbody><tr>
<td><code>`uvm_component_utils</code></td>
<td><code>uvm_component</code>를 extends한 클래스</td>
<td>컴포넌트를 Factory에 등록</td>
</tr>
<tr>
<td><code>`uvm_object_utils</code></td>
<td><code>uvm_object</code>를 extends한 클래스</td>
<td>데이터 객체를 Factory에 등록</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>기억하세요</strong>: &quot;component에는 <code>uvm_component_utils</code>, object에는 <code>uvm_object_utils</code>.&quot; 매크로 이름이 직관적이라 외우기 쉽습니다.</p>
</blockquote>
<p><strong>2단계: 표준 생성자 작성</strong></p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// uvm_component 계열: 반드시 이 형태</span>
<span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
  <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
<span class="hljs-keyword">endfunction</span>

<span class="hljs-comment">// uvm_object 계열: 반드시 이 형태</span>
<span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;my_transaction&quot;</span>);
  <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);
<span class="hljs-keyword">endfunction</span>
</code></pre><blockquote>
<p><strong>주의</strong>: 생성자의 형태(파라미터)를 지키지 않으면 Factory가 객체를 만들 수 없어서 에러가 발생합니다. 이것은 UVM의 규칙입니다.</p>
</blockquote>
<p><strong>3단계: create()로 생성</strong></p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// uvm_component 생성 (부모 지정)</span>
my_driver drv;
drv = my_driver::type_id::create(<span class="hljs-string">&quot;drv&quot;</span>, <span class="hljs-keyword">this</span>);

<span class="hljs-comment">// uvm_object 생성 (부모 없음)</span>
my_transaction txn;
txn = my_transaction::type_id::create(<span class="hljs-string">&quot;txn&quot;</span>);
</code></pre><blockquote>
<p><strong>패턴 정리</strong>: <code>클래스명::type_id::create(&quot;인스턴스이름&quot;, 부모)</code> — 이 패턴은 UVM 코드에서 수백 번 나옵니다. &quot;클래스이름 콜론콜론 type_id 콜론콜론 create&quot;로 외워두세요.</p>
</blockquote>
<h3 id="4-2-5-factory-매크로가-하는-일">4.2.5 Factory 매크로가 하는 일</h3>
<p><code>`uvm_component_utils(my_driver)</code>가 뒤에서 하는 일을 간단히 설명하면:</p>
<ol>
<li><strong>Factory에 등록</strong>: &quot;my_driver라는 클래스가 있다&quot;고 알려줌</li>
<li><strong>type_id 생성</strong>: <code>my_driver::type_id::create()</code>를 사용할 수 있게 함</li>
<li><strong>get_type_name() 제공</strong>: 로그에 클래스 이름이 표시됨</li>
</ol>
<blockquote>
<p><strong>실무 참고</strong>: 매크로의 내부 동작은 복잡하지만, 사용법은 간단합니다. &quot;class 바로 다음 줄에 매크로를 넣고, 표준 생성자를 작성하고, create()로 생성한다&quot; — 이 3단계만 기억하면 됩니다.</p>
</blockquote>
<h3 id="4-2-6-흔한-실수-매크로를-빠뜨리면">4.2.6 흔한 실수: 매크로를 빠뜨리면?</h3>
<pre><code class="hljs language-systemverilog"><span class="hljs-keyword">class</span> my_driver <span class="hljs-keyword">extends</span> uvm_driver;
  <span class="hljs-comment">// `uvm_component_utils(my_driver)  ← 이 줄을 빠뜨리면!</span>

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>
<span class="hljs-keyword">endclass</span>
</code></pre><pre><code>에러 메시지:
** Fatal: (SIGSEGV) Bad handle or reference.
또는
UVM_FATAL @ 0: reporter [NOFACTORY] ...
</code></pre><p><strong>해결</strong>: class 선언 바로 다음 줄에 매크로를 추가하세요. UVM 코드를 작성할 때 습관적으로 &quot;class 선언 → 매크로 → 생성자&quot; 순서를 따르면 실수를 방지할 수 있습니다.</p>
<h3 id="4-2-7-factory-실습-예제">4.2.7 Factory 실습 예제</h3>
<p><strong>[예제 4-2] Factory 등록과 create() 사용</strong></p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// 파일: testbench.sv (EDA Playground)</span>
<span class="hljs-comment">// [예제 4-2] Factory 패턴 기본 실습</span>
<span class="hljs-comment">// 목적: `uvm_component_utils, `uvm_object_utils, type_id::create() 사용법 이해</span>

<span class="hljs-meta">`<span class="hljs-keyword">include</span> &quot;uvm_macros.svh&quot;</span>
<span class="hljs-keyword">import</span> uvm_pkg::*;

<span class="hljs-comment">// ── uvm_object 계열: 트랜잭션 ──</span>
<span class="hljs-keyword">class</span> simple_txn <span class="hljs-keyword">extends</span> uvm_sequence_item;
  `uvm_object_utils(simple_txn)     <span class="hljs-comment">// ⭐ object 계열 매크로</span>

  <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] addr;
  <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] data;

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;simple_txn&quot;</span>);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);               <span class="hljs-comment">// object: 이름만 전달</span>
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-comment">// convert2string(): 트랜잭션의 내용을 한 줄의 문자열로 변환하는 함수</span>
  <span class="hljs-comment">// 디버깅할 때 `uvm_info로 &quot;이 트랜잭션에 무슨 값이 들어있는지&quot; 확인하려면 필수!</span>
  <span class="hljs-comment">// UVM의 관례적인 함수명이므로 이 이름을 사용합니다</span>
  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">string</span> convert2string();
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;addr=0x%02h, data=0x%08h&quot;</span>, addr, data);
  <span class="hljs-keyword">endfunction</span>
<span class="hljs-keyword">endclass</span>

<span class="hljs-comment">// ── uvm_component 계열: 간단한 프로듀서 ──</span>
<span class="hljs-keyword">class</span> simple_producer <span class="hljs-keyword">extends</span> uvm_component;
  `uvm_component_utils(simple_producer)  <span class="hljs-comment">// ⭐ component 계열 매크로</span>

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);       <span class="hljs-comment">// component: 이름 + 부모 전달</span>
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> run_phase(uvm_phase phase);
    simple_txn txn;
    phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);

    <span class="hljs-comment">// Factory로 트랜잭션(uvm_object) 생성</span>
    txn = simple_txn::type_id::create(<span class="hljs-string">&quot;txn&quot;</span>);

    <span class="hljs-comment">// 랜덤화 (Chapter 3에서 배운 내용!)</span>
    <span class="hljs-keyword">if</span> (!txn<span class="hljs-variable">.randomize</span>())
      `uvm_fatal(get_type_name(), <span class="hljs-string">&quot;랜덤화 실패!&quot;</span>)

    `uvm_info(get_type_name(),
      <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;트랜잭션 생성: %s&quot;</span>, txn<span class="hljs-variable">.convert2string</span>()), UVM_MEDIUM)

    #<span class="hljs-number">50</span>;
    phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>

<span class="hljs-comment">// ── 테스트 ──</span>
<span class="hljs-keyword">class</span> factory_test <span class="hljs-keyword">extends</span> uvm_test;
  `uvm_component_utils(factory_test)

  simple_producer producer;

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);
    producer = simple_producer::type_id::create(<span class="hljs-string">&quot;producer&quot;</span>, <span class="hljs-keyword">this</span>);
  <span class="hljs-keyword">endfunction</span>
<span class="hljs-keyword">endclass</span>

<span class="hljs-comment">// ── 실행 ──</span>
<span class="hljs-keyword">module</span> top;
  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span>
    run_test(<span class="hljs-string">&quot;factory_test&quot;</span>);
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</code></pre><p><strong>예상 출력</strong>:</p>
<pre><code>UVM_INFO @ 0: uvm_test_top.producer [simple_producer] 트랜잭션 생성: addr=0x1a, data=0x3f2c80a4
</code></pre><blockquote>
<p><strong>확인해보세요</strong>: (1) <code>uvm_test_top.producer</code>라는 컴포넌트 경로가 보이나요? (2) 실행할 때마다 addr과 data 값이 바뀌나요? — 바뀐다면 랜덤화가 정상 동작하는 것입니다.</p>
</blockquote>
<hr>
<h2 id="4-3-phase-메커니즘-시뮬레이션의-순서-관리">4.3 Phase 메커니즘 — 시뮬레이션의 순서 관리</h2>
<blockquote>
<p><strong>이 절의 목표</strong>: UVM Phase의 실행 순서를 이해하고, 각 Phase에서 해야 하는 일과 하지 말아야 하는 일을 구분합니다.</p>
</blockquote>
<h3 id="4-3-1-phase가-필요한-이유">4.3.1 Phase가 필요한 이유</h3>
<p>일반적인 Verilog 테스트벤치에서는 <code>initial begin ... end</code> 안에 모든 것을 넣었습니다. 간단한 DUT에서는 문제없지만, 복잡한 검증 환경에서는 순서가 중요합니다:</p>
<pre><code>문제 상황:
1. 드라이버가 데이터를 보내려면 → 먼저 시퀀서와 연결되어야 함
2. 시퀀서와 연결하려면 → 먼저 시퀀서가 생성되어야 함
3. 시퀀서가 생성되려면 → 먼저 에이전트가 생성되어야 함

→ 생성 → 연결 → 실행 순서를 강제할 방법이 필요!
</code></pre><p>UVM Phase는 이 순서를 <strong>자동으로 관리</strong>합니다. &quot;모든 컴포넌트의 build_phase가 끝나야 connect_phase가 시작된다&quot;는 것을 UVM이 보장합니다.</p>
<h3 id="4-3-2-핵심-phase-3가지">4.3.2 핵심 Phase 3가지</h3>
<p>UVM에는 여러 Phase가 있지만, 처음에 알아야 할 것은 <strong>3가지</strong>입니다:</p>

<div class="svg-diagram">
<svg viewBox="0 0 520 460" xmlns="http://www.w3.org/2000/svg" style="max-width:520px;width:100%">
  
  <style>
    .diagram-box { fill: #ffffff; stroke: #334155; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-accent { fill: #eff6ff; stroke: #2563eb; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-highlight { fill: #fef3c7; stroke: #f59e0b; stroke-width: 2.5; rx: 10; ry: 10; }
    .diagram-box-dark { fill: #1e293b; stroke: #1e293b; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-run { fill: #fef3c7; stroke: #f59e0b; stroke-width: 3; rx: 10; ry: 10; }
    .diagram-box-green { fill: #ecfdf5; stroke: #10b981; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-purple { fill: #f5f3ff; stroke: #7c3aed; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-red { fill: #fef2f2; stroke: #ef4444; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-gray { fill: #f8fafc; stroke: #94a3b8; stroke-width: 1.5; rx: 8; ry: 8; }
    .diagram-text { font-family: 'Noto Sans KR', sans-serif; fill: #1e293b; }
    .diagram-text-white { font-family: 'Noto Sans KR', sans-serif; fill: #ffffff; }
    .diagram-text-accent { font-family: 'Noto Sans KR', sans-serif; fill: #2563eb; }
    .diagram-text-small { font-family: 'Noto Sans KR', sans-serif; fill: #64748b; font-size: 12px; }
    .diagram-text-code { font-family: 'Fira Code', 'JetBrains Mono', monospace; fill: #1e293b; }
    .diagram-arrow { fill: none; stroke: #64748b; stroke-width: 1.5; }
    .diagram-arrow-accent { fill: none; stroke: #2563eb; stroke-width: 1.5; }
    .diagram-line { stroke: #cbd5e1; stroke-width: 1.5; stroke-dasharray: 6,3; }
  </style>
  <defs>
    <marker id="arrowhead" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#64748b" />
    </marker>
    <marker id="arrowhead-accent" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#2563eb" />
    </marker>
    <marker id="arrowhead-dark" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#1e293b" />
    </marker>
    <marker id="arrowhead-orange" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#f59e0b" />
    </marker>
    <filter id="shadow" x="-5%" y="-5%" width="115%" height="115%">
      <feDropShadow dx="0" dy="2" stdDeviation="3" flood-color="#000" flood-opacity="0.1"/>
    </filter>
  </defs>

  <!-- build_phase (accent blue) -->
  <rect x="60" y="10" width="400" height="120" class="diagram-box-accent" filter="url(#shadow)"/>
  <rect x="60" y="10" width="400" height="32" rx="10" ry="10" fill="#2563eb"/>
  <rect x="60" y="30" width="400" height="12" fill="#2563eb"/>
  <text x="260" y="31" text-anchor="middle" class="diagram-text-white" font-size="14" font-weight="bold">build_phase</text>
  <text x="85" y="62" class="diagram-text" font-size="12" font-weight="600">"건설 단계" -- 컴포넌트를 만듭니다</text>
  <text x="85" y="84" class="diagram-text-small" font-size="11">- 하위 컴포넌트 생성 (create)</text>
  <text x="85" y="104" class="diagram-text-small" font-size="11">- 설정값 적용 (config_db)</text>
  <text x="320" y="118" class="diagram-text-code" font-size="10" fill="#2563eb">function (시간 소모 없음)</text>

  <!-- Arrow -->
  <line x1="260" y1="130" x2="260" y2="170" stroke="#64748b" stroke-width="1.5" marker-end="url(#arrowhead)"/>
  <text x="280" y="156" class="diagram-text-small" font-size="10">Top-Down</text>

  <!-- connect_phase (green) -->
  <rect x="60" y="174" width="400" height="110" class="diagram-box-green" filter="url(#shadow)"/>
  <rect x="60" y="174" width="400" height="32" rx="10" ry="10" fill="#10b981"/>
  <rect x="60" y="194" width="400" height="12" fill="#10b981"/>
  <text x="260" y="195" text-anchor="middle" class="diagram-text-white" font-size="14" font-weight="bold">connect_phase</text>
  <text x="85" y="228" class="diagram-text" font-size="12" font-weight="600">"배선 단계" -- 컴포넌트를 연결합니다</text>
  <text x="85" y="250" class="diagram-text-small" font-size="11">- TLM 포트 연결 (Chapter 7)</text>
  <text x="320" y="272" class="diagram-text-code" font-size="10" fill="#10b981">function (시간 소모 없음)</text>

  <!-- Arrow -->
  <line x1="260" y1="284" x2="260" y2="324" stroke="#f59e0b" stroke-width="2" marker-end="url(#arrowhead)"/>
  <text x="280" y="310" class="diagram-text-small" font-size="10">Bottom-Up</text>

  <!-- run_phase (highlight/yellow) -->
  <rect x="50" y="328" width="420" height="120" class="diagram-box-highlight" filter="url(#shadow)"/>
  <rect x="50" y="328" width="420" height="32" rx="10" ry="10" fill="#f59e0b"/>
  <rect x="50" y="348" width="420" height="12" fill="#f59e0b"/>
  <text x="260" y="349" text-anchor="middle" class="diagram-text-white" font-size="14" font-weight="bold">run_phase</text>
  <text x="75" y="382" class="diagram-text" font-size="12" font-weight="600">"가동 단계" -- 실제 시뮬레이션 실행</text>
  <text x="75" y="404" class="diagram-text-small" font-size="11">- 시퀀스 실행, 데이터 주고받기</text>
  <text x="75" y="424" class="diagram-text-small" font-size="11">- 모든 컴포넌트가 동시에 실행</text>
  <text x="320" y="438" class="diagram-text-code" font-size="10" fill="#92400e">task (시간 소모 있음)</text>
</svg>
</div><blockquote>
<p><strong>비유</strong>: 공장을 떠올려보세요:</p>
<ol>
<li><strong>build_phase</strong> = 기계 설치 (컨베이어, 로봇팔 배치)</li>
<li><strong>connect_phase</strong> = 배선 연결 (전선, 파이프 연결)</li>
<li><strong>run_phase</strong> = 공장 가동! (제품 생산 시작)</li>
</ol>
<p>기계를 설치하기 전에 공장을 가동할 수 없고, 배선 없이 기계가 동작할 수 없습니다. UVM Phase가 이 순서를 보장합니다.</p>
</blockquote>
<h3 id="4-3-3-phase의-실행-순서-상세">4.3.3 Phase의 실행 순서 상세</h3>
<p>UVM의 전체 Phase 순서는 다음과 같습니다. <strong>굵은 글씨</strong> 3가지만 먼저 기억하세요:</p>
<table>
<thead>
<tr>
<th>순서</th>
<th>Phase</th>
<th>종류</th>
<th>역할</th>
<th>중요도</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><strong>build_phase</strong></td>
<td>function</td>
<td>컴포넌트 생성</td>
<td>필수</td>
</tr>
<tr>
<td>2</td>
<td><strong>connect_phase</strong></td>
<td>function</td>
<td>포트 연결</td>
<td>필수</td>
</tr>
<tr>
<td>3</td>
<td>end_of_elaboration_phase</td>
<td>function</td>
<td>구조 완성 확인</td>
<td>선택</td>
</tr>
<tr>
<td>4</td>
<td>start_of_simulation_phase</td>
<td>function</td>
<td>시뮬레이션 시작 알림</td>
<td>선택</td>
</tr>
<tr>
<td>5</td>
<td><strong>run_phase</strong></td>
<td>task</td>
<td>시뮬레이션 실행</td>
<td>필수</td>
</tr>
<tr>
<td>6</td>
<td>extract_phase</td>
<td>function</td>
<td>결과 추출</td>
<td>선택</td>
</tr>
<tr>
<td>7</td>
<td>check_phase</td>
<td>function</td>
<td>결과 확인</td>
<td>선택</td>
</tr>
<tr>
<td>8</td>
<td>report_phase</td>
<td>function</td>
<td>보고서 출력</td>
<td>선택</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>핵심</strong>: build → connect → run, 이 3개만 기억하세요. 나머지 Phase는 필요할 때 배웁니다.</p>
</blockquote>
<h3 id="4-3-4-build-phase의-실행-순서-위에서-아래로">4.3.4 build_phase의 실행 순서 — 위에서 아래로</h3>
<p>build_phase는 다른 Phase와 달리 <strong>위에서 아래로(Top-Down)</strong> 실행됩니다. 이유는 간단합니다: 부모가 먼저 생성되어야 자식을 만들 수 있으니까요.</p>

<div class="svg-diagram">
<svg viewBox="0 0 600 380" xmlns="http://www.w3.org/2000/svg" style="max-width:600px;width:100%">
  
  <style>
    .diagram-box { fill: #ffffff; stroke: #334155; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-accent { fill: #eff6ff; stroke: #2563eb; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-highlight { fill: #fef3c7; stroke: #f59e0b; stroke-width: 2.5; rx: 10; ry: 10; }
    .diagram-box-dark { fill: #1e293b; stroke: #1e293b; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-run { fill: #fef3c7; stroke: #f59e0b; stroke-width: 3; rx: 10; ry: 10; }
    .diagram-box-green { fill: #ecfdf5; stroke: #10b981; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-purple { fill: #f5f3ff; stroke: #7c3aed; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-red { fill: #fef2f2; stroke: #ef4444; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-gray { fill: #f8fafc; stroke: #94a3b8; stroke-width: 1.5; rx: 8; ry: 8; }
    .diagram-text { font-family: 'Noto Sans KR', sans-serif; fill: #1e293b; }
    .diagram-text-white { font-family: 'Noto Sans KR', sans-serif; fill: #ffffff; }
    .diagram-text-accent { font-family: 'Noto Sans KR', sans-serif; fill: #2563eb; }
    .diagram-text-small { font-family: 'Noto Sans KR', sans-serif; fill: #64748b; font-size: 12px; }
    .diagram-text-code { font-family: 'Fira Code', 'JetBrains Mono', monospace; fill: #1e293b; }
    .diagram-arrow { fill: none; stroke: #64748b; stroke-width: 1.5; }
    .diagram-arrow-accent { fill: none; stroke: #2563eb; stroke-width: 1.5; }
    .diagram-line { stroke: #cbd5e1; stroke-width: 1.5; stroke-dasharray: 6,3; }
  </style>
  <defs>
    <marker id="arrowhead" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#64748b" />
    </marker>
    <marker id="arrowhead-accent" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#2563eb" />
    </marker>
    <marker id="arrowhead-dark" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#1e293b" />
    </marker>
    <marker id="arrowhead-orange" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#f59e0b" />
    </marker>
    <filter id="shadow" x="-5%" y="-5%" width="115%" height="115%">
      <feDropShadow dx="0" dy="2" stdDeviation="3" flood-color="#000" flood-opacity="0.1"/>
    </filter>
  </defs>

  <!-- Title -->
  <text x="300" y="22" text-anchor="middle" class="diagram-text" font-size="14" font-weight="bold" fill="#2563eb">build_phase 실행 순서 (Top-Down)</text>

  <!-- uvm_test_top - #1 -->
  <rect x="170" y="36" width="240" height="40" class="diagram-box-accent" filter="url(#shadow)"/>
  <text x="290" y="61" text-anchor="middle" class="diagram-text-code" font-size="12" font-weight="bold">uvm_test_top (my_test)</text>
  <circle cx="430" cy="56" r="14" fill="#2563eb"/>
  <text x="430" y="61" text-anchor="middle" class="diagram-text-white" font-size="11" font-weight="bold">1</text>
  <text x="458" y="61" class="diagram-text-small" font-size="10">1번째 실행</text>

  <!-- Arrow -->
  <line x1="290" y1="76" x2="290" y2="106" stroke="#2563eb" stroke-width="1.5" marker-end="url(#arrowhead-accent)"/>

  <!-- env - #2 -->
  <rect x="190" y="110" width="200" height="40" class="diagram-box-accent" filter="url(#shadow)"/>
  <text x="290" y="135" text-anchor="middle" class="diagram-text-code" font-size="12" font-weight="bold">env</text>
  <circle cx="410" cy="130" r="14" fill="#2563eb"/>
  <text x="410" y="135" text-anchor="middle" class="diagram-text-white" font-size="11" font-weight="bold">2</text>
  <text x="438" y="135" class="diagram-text-small" font-size="10">2번째 실행</text>

  <!-- Arrow -->
  <line x1="290" y1="150" x2="290" y2="180" stroke="#2563eb" stroke-width="1.5" marker-end="url(#arrowhead-accent)"/>

  <!-- agent - #3 -->
  <rect x="210" y="184" width="160" height="40" class="diagram-box-accent" filter="url(#shadow)"/>
  <text x="290" y="209" text-anchor="middle" class="diagram-text-code" font-size="12" font-weight="bold">agent</text>
  <circle cx="390" cy="204" r="14" fill="#2563eb"/>
  <text x="390" y="209" text-anchor="middle" class="diagram-text-white" font-size="11" font-weight="bold">3</text>
  <text x="418" y="209" class="diagram-text-small" font-size="10">3번째 실행</text>

  <!-- Branch lines -->
  <line x1="290" y1="224" x2="290" y2="254" stroke="#2563eb" stroke-width="2"/>
  <line x1="130" y1="254" x2="450" y2="254" stroke="#2563eb" stroke-width="1.5"/>
  <line x1="130" y1="254" x2="130" y2="274" stroke="#2563eb" stroke-width="1.5" marker-end="url(#arrowhead-accent)"/>
  <line x1="290" y1="254" x2="290" y2="274" stroke="#2563eb" stroke-width="1.5" marker-end="url(#arrowhead-accent)"/>
  <line x1="450" y1="254" x2="450" y2="274" stroke="#2563eb" stroke-width="1.5" marker-end="url(#arrowhead-accent)"/>

  <!-- driver - #4 -->
  <rect x="60" y="278" width="140" height="40" class="diagram-box-accent" filter="url(#shadow)"/>
  <text x="130" y="303" text-anchor="middle" class="diagram-text-code" font-size="12">driver</text>
  <circle cx="130" cy="332" r="14" fill="#2563eb"/>
  <text x="130" y="337" text-anchor="middle" class="diagram-text-white" font-size="11" font-weight="bold">4</text>
  <text x="150" y="360" text-anchor="middle" class="diagram-text-small" font-size="10">4번째</text>

  <!-- monitor - #5 -->
  <rect x="220" y="278" width="140" height="40" class="diagram-box-accent" filter="url(#shadow)"/>
  <text x="290" y="303" text-anchor="middle" class="diagram-text-code" font-size="12">monitor</text>
  <circle cx="290" cy="332" r="14" fill="#2563eb"/>
  <text x="290" y="337" text-anchor="middle" class="diagram-text-white" font-size="11" font-weight="bold">5</text>
  <text x="310" y="360" text-anchor="middle" class="diagram-text-small" font-size="10">5번째</text>

  <!-- sequencer - #6 -->
  <rect x="380" y="278" width="140" height="40" class="diagram-box-accent" filter="url(#shadow)"/>
  <text x="450" y="303" text-anchor="middle" class="diagram-text-code" font-size="12">sequencer</text>
  <circle cx="450" cy="332" r="14" fill="#2563eb"/>
  <text x="450" y="337" text-anchor="middle" class="diagram-text-white" font-size="11" font-weight="bold">6</text>
  <text x="470" y="360" text-anchor="middle" class="diagram-text-small" font-size="10">6번째</text>
</svg>
</div><p>다른 Phase(connect, run 등)는 <strong>아래에서 위로(Bottom-Up)</strong> 실행됩니다:</p>

<div class="svg-diagram">
<svg viewBox="0 0 600 380" xmlns="http://www.w3.org/2000/svg" style="max-width:600px;width:100%">
  
  <style>
    .diagram-box { fill: #ffffff; stroke: #334155; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-accent { fill: #eff6ff; stroke: #2563eb; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-highlight { fill: #fef3c7; stroke: #f59e0b; stroke-width: 2.5; rx: 10; ry: 10; }
    .diagram-box-dark { fill: #1e293b; stroke: #1e293b; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-run { fill: #fef3c7; stroke: #f59e0b; stroke-width: 3; rx: 10; ry: 10; }
    .diagram-box-green { fill: #ecfdf5; stroke: #10b981; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-purple { fill: #f5f3ff; stroke: #7c3aed; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-red { fill: #fef2f2; stroke: #ef4444; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-gray { fill: #f8fafc; stroke: #94a3b8; stroke-width: 1.5; rx: 8; ry: 8; }
    .diagram-text { font-family: 'Noto Sans KR', sans-serif; fill: #1e293b; }
    .diagram-text-white { font-family: 'Noto Sans KR', sans-serif; fill: #ffffff; }
    .diagram-text-accent { font-family: 'Noto Sans KR', sans-serif; fill: #2563eb; }
    .diagram-text-small { font-family: 'Noto Sans KR', sans-serif; fill: #64748b; font-size: 12px; }
    .diagram-text-code { font-family: 'Fira Code', 'JetBrains Mono', monospace; fill: #1e293b; }
    .diagram-arrow { fill: none; stroke: #64748b; stroke-width: 1.5; }
    .diagram-arrow-accent { fill: none; stroke: #2563eb; stroke-width: 1.5; }
    .diagram-line { stroke: #cbd5e1; stroke-width: 1.5; stroke-dasharray: 6,3; }
  </style>
  <defs>
    <marker id="arrowhead" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#64748b" />
    </marker>
    <marker id="arrowhead-accent" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#2563eb" />
    </marker>
    <marker id="arrowhead-dark" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#1e293b" />
    </marker>
    <marker id="arrowhead-orange" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#f59e0b" />
    </marker>
    <filter id="shadow" x="-5%" y="-5%" width="115%" height="115%">
      <feDropShadow dx="0" dy="2" stdDeviation="3" flood-color="#000" flood-opacity="0.1"/>
    </filter>
  </defs>

  <!-- Title -->
  <text x="300" y="22" text-anchor="middle" class="diagram-text" font-size="14" font-weight="bold" fill="#10b981">connect_phase 실행 순서 (Bottom-Up)</text>

  <!-- uvm_test_top - #6 -->
  <rect x="170" y="36" width="240" height="40" class="diagram-box-green" filter="url(#shadow)"/>
  <text x="290" y="61" text-anchor="middle" class="diagram-text-code" font-size="12" font-weight="bold">uvm_test_top (my_test)</text>
  <circle cx="430" cy="56" r="14" fill="#10b981"/>
  <text x="430" y="61" text-anchor="middle" class="diagram-text-white" font-size="11" font-weight="bold">6</text>
  <text x="458" y="61" class="diagram-text-small" font-size="10">6번째 실행</text>

  <!-- Arrow (upward conceptually, drawn downward structurally) -->
  <line x1="290" y1="76" x2="290" y2="106" stroke="#10b981" stroke-width="2"/>
  <polygon points="282,80 290,76 298,80" fill="#10b981"/>

  <!-- env - #5 -->
  <rect x="190" y="110" width="200" height="40" class="diagram-box-green" filter="url(#shadow)"/>
  <text x="290" y="135" text-anchor="middle" class="diagram-text-code" font-size="12" font-weight="bold">env</text>
  <circle cx="410" cy="130" r="14" fill="#10b981"/>
  <text x="410" y="135" text-anchor="middle" class="diagram-text-white" font-size="11" font-weight="bold">5</text>
  <text x="438" y="135" class="diagram-text-small" font-size="10">5번째 실행</text>

  <!-- Arrow -->
  <line x1="290" y1="150" x2="290" y2="180" stroke="#10b981" stroke-width="2"/>
  <polygon points="282,154 290,150 298,154" fill="#10b981"/>

  <!-- agent - #4 -->
  <rect x="210" y="184" width="160" height="40" class="diagram-box-green" filter="url(#shadow)"/>
  <text x="290" y="209" text-anchor="middle" class="diagram-text-code" font-size="12" font-weight="bold">agent</text>
  <circle cx="390" cy="204" r="14" fill="#10b981"/>
  <text x="390" y="209" text-anchor="middle" class="diagram-text-white" font-size="11" font-weight="bold">4</text>
  <text x="418" y="209" class="diagram-text-small" font-size="10">4번째 실행</text>

  <!-- Branch lines -->
  <line x1="290" y1="224" x2="290" y2="254" stroke="#10b981" stroke-width="2"/>
  <polygon points="282,228 290,224 298,228" fill="#10b981"/>
  <line x1="130" y1="254" x2="450" y2="254" stroke="#10b981" stroke-width="1.5"/>
  <line x1="130" y1="254" x2="130" y2="274" stroke="#10b981" stroke-width="1.5"/>
  <line x1="290" y1="254" x2="290" y2="274" stroke="#10b981" stroke-width="1.5"/>
  <line x1="450" y1="254" x2="450" y2="274" stroke="#10b981" stroke-width="1.5"/>

  <!-- driver - #1 -->
  <rect x="60" y="278" width="140" height="40" class="diagram-box-green" filter="url(#shadow)"/>
  <text x="130" y="303" text-anchor="middle" class="diagram-text-code" font-size="12">driver</text>
  <circle cx="130" cy="332" r="14" fill="#10b981"/>
  <text x="130" y="337" text-anchor="middle" class="diagram-text-white" font-size="11" font-weight="bold">1</text>
  <text x="150" y="360" text-anchor="middle" class="diagram-text-small" font-size="10">1번째</text>

  <!-- monitor - #2 -->
  <rect x="220" y="278" width="140" height="40" class="diagram-box-green" filter="url(#shadow)"/>
  <text x="290" y="303" text-anchor="middle" class="diagram-text-code" font-size="12">monitor</text>
  <circle cx="290" cy="332" r="14" fill="#10b981"/>
  <text x="290" y="337" text-anchor="middle" class="diagram-text-white" font-size="11" font-weight="bold">2</text>
  <text x="310" y="360" text-anchor="middle" class="diagram-text-small" font-size="10">2번째</text>

  <!-- sequencer - #3 -->
  <rect x="380" y="278" width="140" height="40" class="diagram-box-green" filter="url(#shadow)"/>
  <text x="450" y="303" text-anchor="middle" class="diagram-text-code" font-size="12">sequencer</text>
  <circle cx="450" cy="332" r="14" fill="#10b981"/>
  <text x="450" y="337" text-anchor="middle" class="diagram-text-white" font-size="11" font-weight="bold">3</text>
  <text x="470" y="360" text-anchor="middle" class="diagram-text-small" font-size="10">3번째</text>
</svg>
</div><blockquote>
<p><strong>기억하세요</strong>: &quot;build는 위에서 아래(부모 먼저), 나머지는 아래에서 위(자식 먼저).&quot; 면접에서도 자주 나오는 질문입니다.</p>
</blockquote>
<h3 id="4-3-5-phase에서-하면-안-되는-것">4.3.5 Phase에서 하면 안 되는 것</h3>
<table>
<thead>
<tr>
<th>Phase</th>
<th>해야 할 일</th>
<th>하면 안 되는 일</th>
</tr>
</thead>
<tbody><tr>
<td>build_phase</td>
<td><code>create()</code>로 컴포넌트 생성</td>
<td>포트 연결 (아직 생성 안 된 컴포넌트와 연결 시도)</td>
</tr>
<tr>
<td>connect_phase</td>
<td>포트/export 연결</td>
<td>새 컴포넌트 생성 (build에서 해야 함)</td>
</tr>
<tr>
<td>run_phase</td>
<td>시퀀스 실행, 데이터 전송</td>
<td>컴포넌트 생성 또는 연결 (이미 끝난 단계)</td>
</tr>
</tbody></table>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// ❌ 잘못된 예: connect_phase에서 컴포넌트 생성</span>
<span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> connect_phase(uvm_phase phase);
  <span class="hljs-keyword">super</span><span class="hljs-variable">.connect_phase</span>(phase);
  drv = my_driver::type_id::create(<span class="hljs-string">&quot;drv&quot;</span>, <span class="hljs-keyword">this</span>);  <span class="hljs-comment">// 여기서 하면 안 됨!</span>
<span class="hljs-keyword">endfunction</span>

<span class="hljs-comment">// ✅ 올바른 예: build_phase에서 생성, connect_phase에서 연결</span>
<span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
  <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);
  drv = my_driver::type_id::create(<span class="hljs-string">&quot;drv&quot;</span>, <span class="hljs-keyword">this</span>);  <span class="hljs-comment">// 생성은 여기서!</span>
<span class="hljs-keyword">endfunction</span>

<span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> connect_phase(uvm_phase phase);
  <span class="hljs-keyword">super</span><span class="hljs-variable">.connect_phase</span>(phase);
  <span class="hljs-comment">// 연결은 여기서! (Chapter 7에서 자세히 배움)</span>
<span class="hljs-keyword">endfunction</span>
</code></pre><h3 id="4-3-6-run-phase와-objection-시뮬레이션-종료-조건">4.3.6 run_phase와 objection — 시뮬레이션 종료 조건</h3>
<p>Chapter 1-2에서 <code>raise_objection</code>과 <code>drop_objection</code>을 사용했습니다. 이제 왜 필요한지 정확히 이해합시다:</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> run_phase(uvm_phase phase);
  phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);   <span class="hljs-comment">// &quot;아직 할 일이 있어요!&quot; (시뮬레이션 유지)</span>

  <span class="hljs-comment">// ... 실제 작업 ...</span>

  phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);    <span class="hljs-comment">// &quot;다 끝났어요!&quot; (종료해도 됨)</span>
<span class="hljs-keyword">endtask</span>
</code></pre><blockquote>
<p><strong>비유</strong>: objection = <strong>비행기 출발 전 승객 탑승</strong></p>
<ul>
<li><code>raise_objection</code> = &quot;아직 탑승 중입니다!&quot; (문 닫지 마세요)</li>
<li><code>drop_objection</code> = &quot;모두 탑승 완료!&quot; (출발해도 됩니다)</li>
<li>아무도 raise하지 않으면 UVM은 &quot;할 일이 없다&quot;고 판단하고 즉시 종료합니다.</li>
</ul>
</blockquote>
<p><strong>흔한 실수: raise_objection을 빠뜨리면?</strong></p>
<pre><code class="hljs language-systemverilog"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> run_phase(uvm_phase phase);
  <span class="hljs-comment">// phase.raise_objection(this);  ← 빠뜨림!</span>
  #<span class="hljs-number">100</span>;
  `uvm_info(get_type_name(), <span class="hljs-string">&quot;이 메시지는 절대 출력 안 됨!&quot;</span>, UVM_MEDIUM)
  <span class="hljs-comment">// phase.drop_objection(this);</span>
<span class="hljs-keyword">endtask</span>
</code></pre><pre><code>결과: run_phase가 시작되자마자 시뮬레이션이 종료됨
→ #100 이전에 이미 끝나버림
</code></pre><blockquote>
<p><strong>주의</strong>: objection은 run_phase에서만 필요합니다. build_phase와 connect_phase는 function이므로 시간 개념이 없고, UVM이 자동으로 관리합니다.</p>
</blockquote>
<h3 id="4-3-7-phase-실습-실행-순서-확인">4.3.7 Phase 실습: 실행 순서 확인</h3>
<p><strong>[예제 4-3] Phase 실행 순서 관찰하기</strong></p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// 파일: testbench.sv (EDA Playground)</span>
<span class="hljs-comment">// [예제 4-3] Phase 실행 순서 관찰</span>
<span class="hljs-comment">// 목적: build → connect → run 순서와 Top-Down/Bottom-Up 확인</span>

<span class="hljs-meta">`<span class="hljs-keyword">include</span> &quot;uvm_macros.svh&quot;</span>
<span class="hljs-keyword">import</span> uvm_pkg::*;

<span class="hljs-comment">// ── 자식 컴포넌트 ──</span>
<span class="hljs-keyword">class</span> child_comp <span class="hljs-keyword">extends</span> uvm_component;
  `uvm_component_utils(child_comp)

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);
    `uvm_info(get_name(), <span class="hljs-string">&quot;build_phase 실행&quot;</span>, UVM_MEDIUM)
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> connect_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.connect_phase</span>(phase);
    `uvm_info(get_name(), <span class="hljs-string">&quot;connect_phase 실행&quot;</span>, UVM_MEDIUM)
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> run_phase(uvm_phase phase);
    `uvm_info(get_name(), <span class="hljs-string">&quot;run_phase 시작&quot;</span>, UVM_MEDIUM)
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>

<span class="hljs-comment">// ── 부모 컴포넌트 ──</span>
<span class="hljs-keyword">class</span> parent_comp <span class="hljs-keyword">extends</span> uvm_component;
  `uvm_component_utils(parent_comp)

  child_comp child_a;
  child_comp child_b;

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);
    `uvm_info(get_name(), <span class="hljs-string">&quot;build_phase 실행&quot;</span>, UVM_MEDIUM)
    child_a = child_comp::type_id::create(<span class="hljs-string">&quot;child_a&quot;</span>, <span class="hljs-keyword">this</span>);
    child_b = child_comp::type_id::create(<span class="hljs-string">&quot;child_b&quot;</span>, <span class="hljs-keyword">this</span>);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> connect_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.connect_phase</span>(phase);
    `uvm_info(get_name(), <span class="hljs-string">&quot;connect_phase 실행&quot;</span>, UVM_MEDIUM)
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> run_phase(uvm_phase phase);
    `uvm_info(get_name(), <span class="hljs-string">&quot;run_phase 시작&quot;</span>, UVM_MEDIUM)
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>

<span class="hljs-comment">// ── 테스트 ──</span>
<span class="hljs-keyword">class</span> phase_test <span class="hljs-keyword">extends</span> uvm_test;
  `uvm_component_utils(phase_test)

  parent_comp parent;

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);
    `uvm_info(get_name(), <span class="hljs-string">&quot;build_phase 실행&quot;</span>, UVM_MEDIUM)
    parent = parent_comp::type_id::create(<span class="hljs-string">&quot;parent&quot;</span>, <span class="hljs-keyword">this</span>);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> connect_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.connect_phase</span>(phase);
    `uvm_info(get_name(), <span class="hljs-string">&quot;connect_phase 실행&quot;</span>, UVM_MEDIUM)
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> run_phase(uvm_phase phase);
    phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);
    `uvm_info(get_name(), <span class="hljs-string">&quot;run_phase 시작&quot;</span>, UVM_MEDIUM)
    #<span class="hljs-number">10</span>;
    `uvm_info(get_name(), <span class="hljs-string">&quot;run_phase 완료&quot;</span>, UVM_MEDIUM)
    phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>

<span class="hljs-keyword">module</span> top;
  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span>
    run_test(<span class="hljs-string">&quot;phase_test&quot;</span>);
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</code></pre><p><strong>예상 출력</strong>:</p>
<pre><code>UVM_INFO @ 0: uvm_test_top [uvm_test_top] build_phase 실행
UVM_INFO @ 0: uvm_test_top.parent [parent] build_phase 실행
UVM_INFO @ 0: uvm_test_top.parent.child_a [child_a] build_phase 실행
UVM_INFO @ 0: uvm_test_top.parent.child_b [child_b] build_phase 실행
UVM_INFO @ 0: uvm_test_top.parent.child_a [child_a] connect_phase 실행
UVM_INFO @ 0: uvm_test_top.parent.child_b [child_b] connect_phase 실행
UVM_INFO @ 0: uvm_test_top.parent [parent] connect_phase 실행
UVM_INFO @ 0: uvm_test_top [uvm_test_top] connect_phase 실행
UVM_INFO @ 0: uvm_test_top [uvm_test_top] run_phase 시작
UVM_INFO @ 0: uvm_test_top.parent [parent] run_phase 시작
UVM_INFO @ 0: uvm_test_top.parent.child_a [child_a] run_phase 시작
UVM_INFO @ 0: uvm_test_top.parent.child_b [child_b] run_phase 시작
UVM_INFO @ 10: uvm_test_top [uvm_test_top] run_phase 완료
</code></pre><blockquote>
<p><strong>관찰 포인트</strong>:</p>
<ol>
<li><strong>build_phase</strong>: test → parent → child_a → child_b (위에서 아래)</li>
<li><strong>connect_phase</strong>: child_a → child_b → parent → test (아래에서 위)</li>
<li><strong>run_phase</strong>: 모든 컴포넌트가 동시 시작 (@ 0), test만 #10 후 완료</li>
</ol>
</blockquote>
<hr>
<h2 id="4-4-종합-uvm-컴포넌트-작성-패턴">4.4 종합: UVM 컴포넌트 작성 패턴</h2>
<blockquote>
<p><strong>이 절의 목표</strong>: 지금까지 배운 내용을 종합하여, UVM 컴포넌트를 작성할 때의 표준 패턴을 정리합니다.</p>
</blockquote>
<h3 id="4-4-1-uvm-컴포넌트-작성-템플릿">4.4.1 UVM 컴포넌트 작성 템플릿</h3>
<p>모든 UVM 컴포넌트는 이 패턴을 따릅니다:</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-keyword">class</span> 클래스이름 <span class="hljs-keyword">extends</span> 부모_UVM_클래스;
  <span class="hljs-comment">// 1. Factory 등록</span>
  `uvm_component_utils(클래스이름)

  <span class="hljs-comment">// 2. 하위 컴포넌트 핸들 선언</span>
  하위컴포넌트_타입 핸들이름;

  <span class="hljs-comment">// 3. 표준 생성자</span>
  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-comment">// 4. build_phase: 하위 컴포넌트 생성</span>
  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);
    핸들이름 = 하위컴포넌트_타입::type_id::create(<span class="hljs-string">&quot;이름&quot;</span>, <span class="hljs-keyword">this</span>);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-comment">// 5. connect_phase: 포트 연결 (Chapter 7에서 배움)</span>
  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> connect_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.connect_phase</span>(phase);
    <span class="hljs-comment">// 연결 코드</span>
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-comment">// 6. run_phase: 시뮬레이션 로직 (필요한 경우만)</span>
  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> run_phase(uvm_phase phase);
    phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);
    <span class="hljs-comment">// 시뮬레이션 코드</span>
    phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>
</code></pre><h3 id="4-4-2-uvm-object-작성-템플릿">4.4.2 uvm_object 작성 템플릿</h3>
<p>데이터 클래스(트랜잭션 등)는 이 패턴을 따릅니다:</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-keyword">class</span> 클래스이름 <span class="hljs-keyword">extends</span> uvm_sequence_item;
  <span class="hljs-comment">// 1. Factory 등록 (object용!)</span>
  `uvm_object_utils(클래스이름)

  <span class="hljs-comment">// 2. 데이터 필드 선언</span>
  <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] addr;
  <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] data;

  <span class="hljs-comment">// 3. 제약 조건</span>
  <span class="hljs-keyword">constraint</span> addr_c {
    addr <span class="hljs-keyword">inside</span> {[<span class="hljs-number">0</span>:<span class="hljs-number">255</span>]};
  }

  <span class="hljs-comment">// 4. 표준 생성자</span>
  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;클래스이름&quot;</span>);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-comment">// 5. 문자열 변환 (디버깅용)</span>
  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">string</span> convert2string();
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;addr=0x%02h, data=0x%08h&quot;</span>, addr, data);
  <span class="hljs-keyword">endfunction</span>
<span class="hljs-keyword">endclass</span>
</code></pre><h3 id="4-4-3-종합-실습-미니-검증-환경">4.4.3 종합 실습: 미니 검증 환경</h3>
<p>지금까지 배운 모든 것을 합쳐서 미니 검증 환경을 만들어봅시다. 아직 DUT 연결 없이 <strong>구조만</strong> 만드는 것이 목표입니다:</p>
<p><strong>[예제 4-4] 미니 UVM 환경 구조</strong></p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// 파일: testbench.sv (EDA Playground)</span>
<span class="hljs-comment">// [예제 4-4] 미니 UVM 검증 환경 구조</span>
<span class="hljs-comment">// 목적: test → env → agent → (driver, monitor) 트리 구조 만들기</span>
<span class="hljs-comment">// DUT 연결 없이 구조만 확인</span>

<span class="hljs-meta">`<span class="hljs-keyword">include</span> &quot;uvm_macros.svh&quot;</span>
<span class="hljs-keyword">import</span> uvm_pkg::*;

<span class="hljs-comment">// ── 트랜잭션 (uvm_object) ──</span>
<span class="hljs-keyword">class</span> simple_txn <span class="hljs-keyword">extends</span> uvm_sequence_item;
  `uvm_object_utils(simple_txn)

  <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]  addr;
  <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] data;
  <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span>        rw;     <span class="hljs-comment">// 0: Read, 1: Write</span>

  <span class="hljs-keyword">constraint</span> addr_c { addr <span class="hljs-keyword">inside</span> {[<span class="hljs-number">0</span>:<span class="hljs-number">127</span>]}; }
  <span class="hljs-keyword">constraint</span> rw_c   { rw <span class="hljs-keyword">dist</span> {<span class="hljs-number">0</span> := <span class="hljs-number">3</span>, <span class="hljs-number">1</span> := <span class="hljs-number">7</span>}; }  <span class="hljs-comment">// 쓰기 70%</span>

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;simple_txn&quot;</span>);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">string</span> convert2string();
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;addr=0x%02h, data=0x%08h, %s&quot;</span>,
                     addr, data, rw ? <span class="hljs-string">&quot;WR&quot;</span> : <span class="hljs-string">&quot;RD&quot;</span>);
  <span class="hljs-keyword">endfunction</span>
<span class="hljs-keyword">endclass</span>

<span class="hljs-comment">// ── 드라이버 (uvm_component) ──</span>
<span class="hljs-keyword">class</span> simple_driver <span class="hljs-keyword">extends</span> uvm_component;
  `uvm_component_utils(simple_driver)

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);
    `uvm_info(get_type_name(), <span class="hljs-string">&quot;드라이버 생성 완료&quot;</span>, UVM_MEDIUM)
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> run_phase(uvm_phase phase);
    `uvm_info(get_type_name(), <span class="hljs-string">&quot;드라이버 대기 중... (Chapter 7에서 구현)&quot;</span>, UVM_MEDIUM)
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>

<span class="hljs-comment">// ── 모니터 (uvm_component) ──</span>
<span class="hljs-keyword">class</span> simple_monitor <span class="hljs-keyword">extends</span> uvm_component;
  `uvm_component_utils(simple_monitor)

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);
    `uvm_info(get_type_name(), <span class="hljs-string">&quot;모니터 생성 완료&quot;</span>, UVM_MEDIUM)
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> run_phase(uvm_phase phase);
    `uvm_info(get_type_name(), <span class="hljs-string">&quot;모니터 관찰 중... (Chapter 7에서 구현)&quot;</span>, UVM_MEDIUM)
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>

<span class="hljs-comment">// ── 에이전트 (uvm_component) ──</span>
<span class="hljs-keyword">class</span> simple_agent <span class="hljs-keyword">extends</span> uvm_agent;
  `uvm_component_utils(simple_agent)

  simple_driver  drv;
  simple_monitor mon;

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);
    drv = simple_driver::type_id::create(<span class="hljs-string">&quot;drv&quot;</span>, <span class="hljs-keyword">this</span>);
    mon = simple_monitor::type_id::create(<span class="hljs-string">&quot;mon&quot;</span>, <span class="hljs-keyword">this</span>);
    `uvm_info(get_type_name(), <span class="hljs-string">&quot;에이전트: 드라이버 + 모니터 생성&quot;</span>, UVM_MEDIUM)
  <span class="hljs-keyword">endfunction</span>
<span class="hljs-keyword">endclass</span>

<span class="hljs-comment">// ── 환경 (uvm_component) ──</span>
<span class="hljs-keyword">class</span> simple_env <span class="hljs-keyword">extends</span> uvm_env;
  `uvm_component_utils(simple_env)

  simple_agent agent;

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);
    agent = simple_agent::type_id::create(<span class="hljs-string">&quot;agent&quot;</span>, <span class="hljs-keyword">this</span>);
    `uvm_info(get_type_name(), <span class="hljs-string">&quot;환경: 에이전트 생성&quot;</span>, UVM_MEDIUM)
  <span class="hljs-keyword">endfunction</span>
<span class="hljs-keyword">endclass</span>

<span class="hljs-comment">// ── 테스트 (최상위) ──</span>
<span class="hljs-keyword">class</span> mini_test <span class="hljs-keyword">extends</span> uvm_test;
  `uvm_component_utils(mini_test)

  simple_env env;

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);
    env = simple_env::type_id::create(<span class="hljs-string">&quot;env&quot;</span>, <span class="hljs-keyword">this</span>);
    `uvm_info(get_type_name(), <span class="hljs-string">&quot;테스트: 환경 생성&quot;</span>, UVM_MEDIUM)
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> run_phase(uvm_phase phase);
    simple_txn txn;
    phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);

    `uvm_info(get_type_name(), <span class="hljs-string">&quot;=== 미니 검증 환경 가동! ===&quot;</span>, UVM_MEDIUM)

    <span class="hljs-comment">// 트랜잭션 3개 생성하여 출력</span>
    <span class="hljs-keyword">repeat</span>(<span class="hljs-number">3</span>) <span class="hljs-keyword">begin</span>
      txn = simple_txn::type_id::create(<span class="hljs-string">&quot;txn&quot;</span>);
      <span class="hljs-keyword">if</span> (!txn<span class="hljs-variable">.randomize</span>())
        `uvm_fatal(get_type_name(), <span class="hljs-string">&quot;랜덤화 실패!&quot;</span>)
      `uvm_info(get_type_name(),
        <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;생성된 트랜잭션: %s&quot;</span>, txn<span class="hljs-variable">.convert2string</span>()), UVM_MEDIUM)
    <span class="hljs-keyword">end</span>

    <span class="hljs-comment">// 컴포넌트 트리 출력 (UVM 내장 기능)</span>
    `uvm_info(get_type_name(), <span class="hljs-string">&quot;=== 컴포넌트 트리 ===&quot;</span>, UVM_MEDIUM)
    uvm_top<span class="hljs-variable">.print_topology</span>();

    phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>

<span class="hljs-keyword">module</span> top;
  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span>
    run_test(<span class="hljs-string">&quot;mini_test&quot;</span>);
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</code></pre><p><strong>예상 출력</strong>:</p>
<pre><code>UVM_INFO @ 0: uvm_test_top [mini_test] 테스트: 환경 생성
UVM_INFO @ 0: uvm_test_top.env [simple_env] 환경: 에이전트 생성
UVM_INFO @ 0: uvm_test_top.env.agent [simple_agent] 에이전트: 드라이버 + 모니터 생성
UVM_INFO @ 0: uvm_test_top.env.agent.drv [simple_driver] 드라이버 생성 완료
UVM_INFO @ 0: uvm_test_top.env.agent.mon [simple_monitor] 모니터 생성 완료
UVM_INFO @ 0: uvm_test_top [mini_test] === 미니 검증 환경 가동! ===
UVM_INFO @ 0: uvm_test_top [mini_test] 생성된 트랜잭션: addr=0x1a, data=0x3f2c80a4, WR
UVM_INFO @ 0: uvm_test_top [mini_test] 생성된 트랜잭션: addr=0x42, data=0x0000beef, RD
UVM_INFO @ 0: uvm_test_top [mini_test] 생성된 트랜잭션: addr=0x05, data=0x12345678, WR
UVM_INFO @ 0: uvm_test_top [mini_test] === 컴포넌트 트리 ===

--------------------------------------
Name          Type           Size  Value
--------------------------------------
uvm_test_top  mini_test      -     @...
  env         simple_env     -     @...
    agent     simple_agent   -     @...
      drv     simple_driver  -     @...
      mon     simple_monitor -     @...
--------------------------------------
</code></pre><blockquote>
<p><strong>관찰 포인트</strong>:</p>
<ol>
<li>build_phase 실행 순서: test → env → agent → drv, mon (위에서 아래)</li>
<li>컴포넌트 경로: <code>uvm_test_top.env.agent.drv</code> — 트리 구조가 명확합니다</li>
<li><code>print_topology()</code>로 전체 구조를 한눈에 확인할 수 있습니다</li>
<li>트랜잭션은 랜덤화로 매번 다른 값이 생성됩니다</li>
</ol>
</blockquote>
<blockquote>
<p><strong>성취감 포인트</strong>: 축하합니다! 방금 실무에서 사용하는 것과 동일한 구조의 UVM 검증 환경 뼈대를 만들었습니다. test → env → agent → driver/monitor — 이 구조를 기반으로 Chapter 5에서 첫 완전한 테스트벤치를 만들게 됩니다.</p>
</blockquote>
<hr>
<h2 id="4-5-체크포인트">4.5 체크포인트</h2>
<h3 id="셀프-체크">셀프 체크</h3>
<p>아래 질문에 답할 수 있다면 이 챕터를 충분히 이해한 것입니다:</p>
<ol>
<li><code>uvm_object</code>와 <code>uvm_component</code>의 가장 큰 차이점 2가지는?</li>
</ol>
<details>
<summary>정답 확인</summary>

<p>(1) uvm_component는 부모-자식 관계(트리 구조)가 있지만 uvm_object는 없습니다.
(2) uvm_component는 Phase(build, connect, run)가 있지만 uvm_object는 없습니다.
추가: uvm_component의 생성자에는 parent 파라미터가 필요합니다.</p>
</details>

<ol start="2">
<li>UVM에서 <code>new()</code> 대신 <code>type_id::create()</code>를 사용하는 이유는?</li>
</ol>
<details>
<summary>정답 확인</summary>

<p>Factory 패턴을 통해 코드 수정 없이 컴포넌트를 교체할 수 있게 하기 위해서입니다. 예를 들어, 기본 드라이버를 에러 주입 드라이버로 교체할 때, create()를 사용했으면 테스트 클래스에서 set_type_override() 한 줄로 교체 가능하지만, new()를 사용했으면 환경 코드를 직접 수정해야 합니다.</p>
</details>

<ol start="3">
<li><code>`uvm_component_utils</code>와 <code>`uvm_object_utils</code>는 각각 언제 사용하는가?</li>
</ol>
<details>
<summary>정답 확인</summary>

<p><code>uvm_component_utils</code>는 uvm_component를 상속한 클래스(test, env, agent, driver, monitor 등)에 사용합니다.
<code>uvm_object_utils</code>는 uvm_object를 상속한 클래스(transaction, sequence 등)에 사용합니다.
둘 다 Factory에 클래스를 등록하여 type_id::create()로 생성할 수 있게 해줍니다.</p>
</details>

<ol start="4">
<li>build_phase, connect_phase, run_phase의 실행 순서와 각각의 역할은?</li>
</ol>
<details>
<summary>정답 확인</summary>

<p>실행 순서: build_phase → connect_phase → run_phase</p>
<ul>
<li>build_phase: 하위 컴포넌트를 create()로 생성하는 단계. 위에서 아래로(Top-Down) 실행</li>
<li>connect_phase: 포트를 연결하는 단계. 아래에서 위로(Bottom-Up) 실행</li>
<li>run_phase: 실제 시뮬레이션이 동작하는 단계. 모든 컴포넌트가 동시 실행. task이므로 시간 소모 가능 (#, @)</details></li>
</ul>
<ol start="5">
<li><code>raise_objection()</code>과 <code>drop_objection()</code>은 왜 필요한가?</li>
</ol>
<details>
<summary>정답 확인</summary>

<p>run_phase에서 시뮬레이션의 종료 시점을 제어하기 위해서입니다. raise_objection은 &quot;아직 할 일이 남았으니 종료하지 마세요&quot;이고, drop_objection은 &quot;할 일을 마쳤습니다&quot;입니다. 아무도 raise하지 않으면 UVM은 할 일이 없다고 판단하여 즉시 종료합니다.</p>
</details>

<ol start="6">
<li>build_phase가 Top-Down으로 실행되는 이유는?</li>
</ol>
<details>
<summary>정답 확인</summary>

<p>부모 컴포넌트가 먼저 생성되어야 자식 컴포넌트를 만들 수 있기 때문입니다. 예를 들어, env의 build_phase에서 agent를 create()하므로, env가 먼저 build되어야 agent를 만들 수 있습니다. 반면 connect_phase는 아래에서 위로(Bottom-Up) 실행됩니다 — 자식이 먼저 준비되어야 부모가 연결할 수 있으니까요.</p>
</details>

<h3 id="연습문제">연습문제</h3>
<p><strong>[실습 4-1] 컴포넌트 추가하기 (쉬움)</strong> — 약 10분</p>
<p>[예제 4-4]의 <code>simple_agent</code>에 <code>simple_sequencer</code>(uvm_sequencer를 extends) 컴포넌트를 추가하세요. build_phase에서 생성하고, 출력에서 컴포넌트 트리에 나타나는지 확인하세요.</p>
<details>
<summary>힌트</summary>

<p><code>class simple_sequencer extends uvm_sequencer;</code>로 만들고, agent의 build_phase에서 <code>sqr = simple_sequencer::type_id::create(&quot;sqr&quot;, this);</code>로 생성합니다.</p>
</details>

<details>
<summary>모범 답안</summary>

<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// simple_monitor 클래스 아래에 추가</span>
<span class="hljs-keyword">class</span> simple_sequencer <span class="hljs-keyword">extends</span> uvm_sequencer;
  `uvm_component_utils(simple_sequencer)

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);
    `uvm_info(get_type_name(), <span class="hljs-string">&quot;시퀀서 생성 완료&quot;</span>, UVM_MEDIUM)
  <span class="hljs-keyword">endfunction</span>
<span class="hljs-keyword">endclass</span>

<span class="hljs-comment">// simple_agent 클래스 수정</span>
<span class="hljs-keyword">class</span> simple_agent <span class="hljs-keyword">extends</span> uvm_agent;
  `uvm_component_utils(simple_agent)

  simple_driver    drv;
  simple_monitor   mon;
  simple_sequencer sqr;  <span class="hljs-comment">// 추가!</span>

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);
    drv = simple_driver::type_id::create(<span class="hljs-string">&quot;drv&quot;</span>, <span class="hljs-keyword">this</span>);
    mon = simple_monitor::type_id::create(<span class="hljs-string">&quot;mon&quot;</span>, <span class="hljs-keyword">this</span>);
    sqr = simple_sequencer::type_id::create(<span class="hljs-string">&quot;sqr&quot;</span>, <span class="hljs-keyword">this</span>);  <span class="hljs-comment">// 추가!</span>
    `uvm_info(get_type_name(), <span class="hljs-string">&quot;에이전트: 드라이버 + 모니터 + 시퀀서 생성&quot;</span>, UVM_MEDIUM)
  <span class="hljs-keyword">endfunction</span>
<span class="hljs-keyword">endclass</span>
</code></pre></details>

<p><strong>[실습 4-2] 트랜잭션 확장하기 (보통)</strong> — 약 15분</p>
<p><code>simple_txn</code>을 상속하여 <code>error_txn</code> 클래스를 만드세요. <code>rand bit inject_error</code> 필드를 추가하고, <code>convert2string()</code>을 오버라이드하여 에러 여부도 출력되게 하세요. <code>mini_test</code>의 run_phase에서 <code>error_txn</code>을 생성하여 출력하세요.</p>
<details>
<summary>힌트</summary>

<p><code>class error_txn extends simple_txn;</code>로 시작하고, <code>`uvm_object_utils(error_txn)</code>를 사용합니다. 생성은 <code>error_txn::type_id::create(&quot;txn&quot;)</code>으로 합니다.</p>
</details>

<details>
<summary>모범 답안</summary>

<pre><code class="hljs language-systemverilog"><span class="hljs-keyword">class</span> error_txn <span class="hljs-keyword">extends</span> simple_txn;
  `uvm_object_utils(error_txn)

  <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span> inject_error;

  <span class="hljs-keyword">constraint</span> error_c {
    inject_error <span class="hljs-keyword">dist</span> { <span class="hljs-number">1</span> := <span class="hljs-number">2</span>, <span class="hljs-number">0</span> := <span class="hljs-number">8</span> };  <span class="hljs-comment">// 20% 에러 주입</span>
  }

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;error_txn&quot;</span>);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">string</span> convert2string();
    <span class="hljs-keyword">string</span> base_str = <span class="hljs-keyword">super</span><span class="hljs-variable">.convert2string</span>();
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;%s, error=%s&quot;</span>, base_str,
                     inject_error ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>);
  <span class="hljs-keyword">endfunction</span>
<span class="hljs-keyword">endclass</span>

<span class="hljs-comment">// mini_test의 run_phase에서:</span>
error_txn etxn;
<span class="hljs-keyword">repeat</span>(<span class="hljs-number">5</span>) <span class="hljs-keyword">begin</span>
  etxn = error_txn::type_id::create(<span class="hljs-string">&quot;etxn&quot;</span>);
  <span class="hljs-keyword">if</span> (!etxn<span class="hljs-variable">.randomize</span>())
    `uvm_fatal(get_type_name(), <span class="hljs-string">&quot;랜덤화 실패!&quot;</span>)
  `uvm_info(get_type_name(),
    <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;에러 트랜잭션: %s&quot;</span>, etxn<span class="hljs-variable">.convert2string</span>()), UVM_MEDIUM)
<span class="hljs-keyword">end</span>
</code></pre></details>

<p><strong>[실습 4-3] Phase 순서 예측 (도전)</strong> — 약 10분</p>
<p>아래 구조에서 build_phase와 connect_phase의 실행 순서를 예측하세요:</p>
<pre><code>test
  ├── env1
  │    └── agent_a
  │         ├── drv_a
  │         └── mon_a
  └── env2
       └── agent_b
            └── drv_b
</code></pre><details>
<summary>정답 확인</summary>

<p><strong>build_phase (Top-Down)</strong>:</p>
<ol>
<li>test</li>
<li>env1</li>
<li>agent_a</li>
<li>drv_a</li>
<li>mon_a</li>
<li>env2</li>
<li>agent_b</li>
<li>drv_b</li>
</ol>
<p><strong>connect_phase (Bottom-Up)</strong>:</p>
<ol>
<li>drv_a</li>
<li>mon_a</li>
<li>agent_a</li>
<li>env1</li>
<li>drv_b</li>
<li>agent_b</li>
<li>env2</li>
<li>test</li>
</ol>
<p>참고: 같은 레벨의 형제 컴포넌트(env1과 env2, drv_a와 mon_a)의 순서는 생성 순서에 따라 달라질 수 있지만, 부모-자식 간의 Top-Down/Bottom-Up 원칙은 항상 유지됩니다.</p>
</details>

<h3 id="흔한-에러와-해결법">흔한 에러와 해결법</h3>
<table>
<thead>
<tr>
<th>에러 메시지</th>
<th>원인</th>
<th>해결</th>
</tr>
</thead>
<tbody><tr>
<td><code>UVM_FATAL ... [NOFACTORY]</code></td>
<td><code>uvm_component_utils</code> 또는 <code>uvm_object_utils</code> 누락</td>
<td>class 다음 줄에 매크로 추가</td>
</tr>
<tr>
<td><code>Bad handle or reference (SIGSEGV)</code></td>
<td>create() 없이 컴포넌트 사용</td>
<td>build_phase에서 create()로 생성</td>
</tr>
<tr>
<td>run_phase가 즉시 종료</td>
<td>raise_objection() 누락</td>
<td>run_phase 시작 시 raise_objection() 추가</td>
</tr>
<tr>
<td><code>connect_phase에서 null 참조</code></td>
<td>build_phase에서 create() 안 함</td>
<td>build_phase에서 먼저 생성 확인</td>
</tr>
<tr>
<td><code>uvm_component_utils 대신 uvm_object_utils 사용</code></td>
<td>component에 object 매크로 사용</td>
<td>클래스가 상속한 부모 확인 후 올바른 매크로 선택</td>
</tr>
</tbody></table>
<h3 id="용어-정리">용어 정리</h3>
<table>
<thead>
<tr>
<th>한글 용어</th>
<th>영어</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>팩토리</td>
<td>Factory</td>
<td>객체 생성을 관리하는 메커니즘. type_id::create()로 사용</td>
</tr>
<tr>
<td>페이즈</td>
<td>Phase</td>
<td>시뮬레이션 단계를 관리하는 메커니즘. build → connect → run</td>
</tr>
<tr>
<td>컴포넌트</td>
<td>Component</td>
<td>테스트벤치의 구조를 이루는 클래스 (uvm_component 상속)</td>
</tr>
<tr>
<td>오브젝트</td>
<td>Object</td>
<td>데이터를 담는 클래스 (uvm_object 상속)</td>
</tr>
<tr>
<td>컴포넌트 트리</td>
<td>Component Tree</td>
<td>부모-자식 관계로 이루어진 테스트벤치 계층 구조</td>
</tr>
<tr>
<td>오브젝션</td>
<td>Objection</td>
<td>run_phase 종료 시점을 제어하는 메커니즘</td>
</tr>
<tr>
<td>매크로</td>
<td>Macro</td>
<td>컴파일러가 전처리하는 코드 치환. `uvm_component_utils 등</td>
</tr>
<tr>
<td>토폴로지</td>
<td>Topology</td>
<td>컴포넌트 트리의 전체 구조. print_topology()로 출력</td>
</tr>
<tr>
<td>오버라이드</td>
<td>Override</td>
<td>Factory를 통해 한 클래스를 다른 클래스로 교체하는 기능</td>
</tr>
</tbody></table>
<h3 id="다음-챕터-미리보기">다음 챕터 미리보기</h3>
<blockquote>
<p>Chapter 5에서는 다음 내용을 학습합니다:</p>
<ul>
<li>실제 DUT(간단한 카운터)와 연결하는 완전한 UVM 테스트벤치 구축</li>
<li><code>uvm_config_db</code>로 설정값을 전달하는 방법</li>
<li>Virtual Interface를 통한 DUT-테스트벤치 연결</li>
<li>첫 번째 <strong>완전한</strong> 시뮬레이션 실행</li>
</ul>
<p>이 챕터에서 만든 test → env → agent → driver/monitor 구조가 Chapter 5의 기반입니다!</p>
</blockquote>

    <nav class="chapter-nav"><a href="chapter-03-final.html" class="nav-prev">
      <span class="nav-label">이전 챕터</span>
      <span class="nav-title">Ch.3 SystemVerilog 핵심</span>
    </a><a href="chapter-05-final.html" class="nav-next">
      <span class="nav-label">다음 챕터</span>
      <span class="nav-title">Ch.5 첫 UVM 테스트벤치</span>
    </a></nav>
  </div>

  <footer class="book-footer">
    <p>팹리스 검증 엔지니어가 되기 위한 UVM 완전정복</p>
    <p>Published by UVM Book Publisher Agent</p>
  </footer>

  <!-- Back to Top Button -->
  <button class="back-to-top" id="backToTop" onclick="window.scrollTo({top:0,behavior:'smooth'})">↑</button>

  <script>
    // Reading progress bar
    window.addEventListener('scroll', () => {
      const h = document.documentElement;
      const pct = (h.scrollTop / (h.scrollHeight - h.clientHeight)) * 100;
      document.getElementById('progressBar').style.width = pct + '%';
      document.getElementById('backToTop').classList.toggle('visible', h.scrollTop > 400);
    });

    // Language labels for code blocks
    document.querySelectorAll('pre').forEach(pre => {
      const code = pre.querySelector('code');
      if (code) {
        const cls = code.className || '';
        const m = cls.match(/language-(\w+)/);
        if (m) {
          const map = {
            systemverilog:'SystemVerilog', sv:'SystemVerilog', verilog:'Verilog',
            bash:'Bash', shell:'Shell', tcl:'TCL', makefile:'Makefile',
            python:'Python', javascript:'JavaScript', text:'Output'
          };
          pre.setAttribute('data-lang', map[m[1]] || m[1]);
        }
      }
    });

    // Smart labels for plain code blocks
    document.querySelectorAll('pre code:not([class*="language-"])').forEach(code => {
      const pre = code.parentElement;
      if (!pre.getAttribute('data-lang')) {
        const t = code.textContent || '';
        if (t.includes('UVM_INFO') || t.includes('UVM_WARNING')) {
          pre.setAttribute('data-lang', 'Simulation Output');
        } else if (t.includes('[채용') || t.includes('필수 자격')) {
          pre.setAttribute('data-lang', '');
        } else if (t.includes('Step') || t.includes('패널') || t.includes('편집기')) {
          pre.setAttribute('data-lang', 'Setup Guide');
        } else {
          pre.setAttribute('data-lang', 'Info');
        }
      }
    });

    // Smooth scroll for TOC links
    document.querySelectorAll('.toc a').forEach(a => {
      a.addEventListener('click', e => {
        e.preventDefault();
        const id = a.getAttribute('href').slice(1);
        const target = document.getElementById(id);
        if (target) target.scrollIntoView({ behavior: 'smooth', block: 'start' });
      });
    });
  </script>
</body>
</html>