<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chapter 5: 첫 UVM 테스트벤치 | 팹리스 검증 엔지니어가 되기 위한 UVM 완전정복</title>
  <style>
    /* =============================================
       UVM Book Publisher - Stylesheet
       Generated by Publisher Agent
       ============================================= */

    @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;600;700&display=swap');

    :root {
      --bg: #ffffff;
      --text: #1a1a2e;
      --accent: #2563eb;
      --accent-light: #2563eb18;
      --code-bg: #1e1e2e;
      --code-text: #cdd6f4;
      --border: #e2e8f0;
      --blockquote-bg: #f0f9ff;
      --blockquote-border: #3b82f6;
      --table-header: #1e293b;
      --table-stripe: #f8fafc;
      --warning-bg: #fef3c7;
      --warning-border: #f59e0b;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: 'Noto Sans KR', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      line-height: 1.85;
      color: var(--text);
      background: var(--bg);
      font-size: 16px;
    }

    /* === Reading Progress Bar === */
    .progress-bar {
      position: fixed;
      top: 0;
      left: 0;
      width: 0%;
      height: 3px;
      background: linear-gradient(90deg, var(--accent), #2563ebcc);
      z-index: 9999;
      transition: width 0.1s;
    }

    /* === Cover Header === */
    .cover-header {
      background: linear-gradient(135deg, #2563eb08, #2563eb15);
      border-bottom: 3px solid var(--accent);
      padding: 32px 24px 24px;
      text-align: center;
      margin-bottom: 0;
    }
    .cover-part {
      display: inline-block;
      background: var(--accent);
      color: white;
      padding: 4px 16px;
      border-radius: 20px;
      font-size: 0.85em;
      font-weight: 600;
      letter-spacing: 0.5px;
      margin-bottom: 12px;
    }
    .cover-chapter-num {
      font-size: 2em;
      font-weight: 300;
      color: var(--accent);
      letter-spacing: 2px;
      opacity: 0.6;
    }

    /* === Main Content === */
    .content {
      max-width: 860px;
      margin: 0 auto;
      padding: 32px 24px 60px;
    }

    /* === TOC === */
    .toc {
      background: #f8fafc;
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 20px 28px;
      margin: 24px 0 32px;
    }
    .toc-title {
      font-size: 1.1em;
      color: var(--accent);
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 2px solid var(--border);
    }
    .toc ul { list-style: none; padding: 0; }
    .toc li { margin: 6px 0; }
    .toc li a {
      color: var(--text);
      text-decoration: none;
      font-weight: 500;
      font-size: 0.95em;
      padding: 4px 8px;
      border-radius: 4px;
      display: inline-block;
      transition: background 0.15s;
    }
    .toc li a:hover {
      background: var(--accent-light);
      color: var(--accent);
    }
    .toc li.toc-sub { padding-left: 24px; }
    .toc li.toc-sub a {
      font-weight: 400;
      font-size: 0.9em;
      color: #475569;
    }

    /* === Headings === */
    h1 {
      font-size: 2em;
      border-bottom: 3px solid var(--accent);
      padding-bottom: 12px;
      margin: 40px 0 20px;
      color: var(--text);
    }
    h1:first-child { margin-top: 0; }
    h2 {
      font-size: 1.5em;
      color: var(--accent);
      margin: 40px 0 16px;
      padding-bottom: 8px;
      border-bottom: 2px solid var(--border);
      scroll-margin-top: 16px;
    }
    h3 {
      font-size: 1.25em;
      margin: 28px 0 12px;
      color: #334155;
      scroll-margin-top: 16px;
    }
    h4 { font-size: 1.05em; margin: 20px 0 8px; color: #475569; }
    p { margin: 12px 0; }
    a { color: var(--accent); text-decoration: none; }
    a:hover { text-decoration: underline; }
    hr { border: none; border-top: 2px solid var(--border); margin: 32px 0; }
    strong { color: #1e293b; }
    img { max-width: 100%; border-radius: 8px; margin: 16px 0; }

    /* === Code Blocks === */
    pre {
      position: relative;
      background: var(--code-bg);
      border-radius: 12px;
      padding: 0;
      margin: 20px 0;
      overflow: hidden;
      box-shadow: 0 4px 16px rgba(0,0,0,0.12), 0 1px 4px rgba(0,0,0,0.08);
      border: 1px solid #313244;
    }
    pre::before {
      content: attr(data-lang);
      display: block;
      background: #313244;
      color: #a6adc8;
      padding: 8px 16px;
      font-size: 0.8em;
      font-family: 'Fira Code','JetBrains Mono',monospace;
      letter-spacing: 0.5px;
      border-bottom: 1px solid #45475a;
    }
    pre code {
      display: block;
      padding: 16px 20px;
      overflow-x: auto;
      font-family: 'Fira Code','JetBrains Mono','Cascadia Code','D2Coding',monospace;
      font-size: 0.88em;
      line-height: 1.75;
      tab-size: 4;
      color: var(--code-text);
    }
    pre code::-webkit-scrollbar { height: 6px; }
    pre code::-webkit-scrollbar-track { background: #1e1e2e; }
    pre code::-webkit-scrollbar-thumb { background: #45475a; border-radius: 3px; }

    code:not(pre code) {
      background: #f1f5f9;
      color: #be185d;
      padding: 2px 7px;
      border-radius: 5px;
      font-family: 'Fira Code','JetBrains Mono','D2Coding',monospace;
      font-size: 0.86em;
      border: 1px solid #e2e8f0;
    }

    /* Highlight.js Catppuccin */
    .hljs { background: transparent; color: #cdd6f4; }
    .hljs-keyword { color: #cba6f7; font-weight: bold; }
    .hljs-type { color: #f9e2af; }
    .hljs-string { color: #a6e3a1; }
    .hljs-number { color: #fab387; }
    .hljs-comment { color: #6c7086; font-style: italic; }
    .hljs-function, .hljs-title { color: #89b4fa; }
    .hljs-built_in { color: #f38ba8; }
    .hljs-variable { color: #cdd6f4; }
    .hljs-attr { color: #89dceb; }
    .hljs-meta { color: #f5c2e7; }
    .hljs-literal { color: #fab387; }

    /* === SVG Diagrams === */
    .svg-diagram {
      margin: 24px 0;
      padding: 20px;
      background: #fafbfc;
      border: 1px solid var(--border);
      border-radius: 12px;
      text-align: center;
      overflow-x: auto;
    }
    .svg-diagram svg { display: inline-block; }

    /* === Blockquotes === */
    blockquote {
      background: var(--blockquote-bg);
      border-left: 4px solid var(--blockquote-border);
      padding: 16px 20px;
      margin: 16px 0;
      border-radius: 0 8px 8px 0;
    }
    blockquote p:first-child { margin-top: 0; }
    blockquote p:last-child { margin-bottom: 0; }
    blockquote:has(strong:first-child) {
      background: var(--warning-bg);
      border-left-color: var(--warning-border);
    }

    /* === Tables === */
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 1px 4px rgba(0,0,0,0.06);
      border: 1px solid var(--border);
      font-size: 0.95em;
    }
    thead th {
      background: var(--table-header);
      color: white;
      padding: 12px 16px;
      text-align: left;
      font-weight: 600;
      font-size: 0.9em;
    }
    tbody td {
      padding: 10px 16px;
      border-bottom: 1px solid var(--border);
    }
    tbody tr:nth-child(even) { background: var(--table-stripe); }
    tbody tr:hover { background: var(--accent-light); }

    /* === Lists === */
    ul, ol { padding-left: 28px; margin: 12px 0; }
    li { margin: 6px 0; }
    li > ul, li > ol { margin: 4px 0; }

    /* === Details/Summary === */
    details {
      background: #f8fafc;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px 16px;
      margin: 12px 0;
    }
    details summary {
      cursor: pointer;
      font-weight: 600;
      color: var(--accent);
    }
    details[open] summary { margin-bottom: 8px; }

    /* === Plain code blocks === */
    pre:has(code:not(.hljs)) {
      background: #fafbfc;
      border: 2px solid var(--border);
      box-shadow: none;
    }
    pre:has(code:not(.hljs))::before {
      background: #f1f5f9;
      color: #64748b;
      border-bottom-color: var(--border);
    }
    pre:has(code:not(.hljs)) code { color: #334155; }

    /* === Chapter Navigation === */
    .chapter-nav {
      display: flex;
      justify-content: space-between;
      gap: 16px;
      margin: 40px 0 20px;
      padding-top: 24px;
      border-top: 2px solid var(--border);
    }
    .chapter-nav a {
      display: flex;
      flex-direction: column;
      padding: 14px 20px;
      border: 1px solid var(--border);
      border-radius: 10px;
      text-decoration: none;
      transition: all 0.2s;
      min-width: 200px;
    }
    .chapter-nav a:hover {
      border-color: var(--accent);
      background: var(--accent-light);
      text-decoration: none;
    }
    .nav-prev { align-items: flex-start; }
    .nav-next { align-items: flex-end; }
    .nav-label {
      font-size: 0.8em;
      color: #94a3b8;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .nav-title { font-weight: 600; color: var(--accent); margin-top: 2px; }

    /* === Footer === */
    .book-footer {
      text-align: center;
      padding: 20px;
      margin-top: 40px;
      border-top: 1px solid var(--border);
      color: #94a3b8;
      font-size: 0.85em;
    }

    /* === Back to Top === */
    .back-to-top {
      position: fixed;
      bottom: 24px;
      right: 24px;
      width: 44px;
      height: 44px;
      background: var(--accent);
      color: white;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      font-size: 20px;
      display: none;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      transition: opacity 0.3s;
      z-index: 100;
    }
    .back-to-top.visible { display: flex; }

    /* === Print === */
    @media print {
      .progress-bar, .back-to-top, .chapter-nav, .toc { display: none !important; }
      body { font-size: 11pt; }
      .content { max-width: 100%; padding: 0; }
      .cover-header { break-after: page; }
      pre { box-shadow: none; border: 2px solid #ccc; break-inside: avoid; }
      .svg-diagram { break-inside: avoid; border: 1px solid #ccc; }
      table { break-inside: avoid; }
      h2, h3 { break-after: avoid; }
    }

    /* === Responsive === */
    @media (max-width: 640px) {
      .content { padding: 16px 12px 40px; font-size: 15px; }
      h1 { font-size: 1.5em; }
      h2 { font-size: 1.25em; }
      pre code { font-size: 0.8em; padding: 12px; }
      thead th, tbody td { padding: 8px 10px; font-size: 0.88em; }
      .svg-diagram { padding: 10px; }
      .toc { padding: 14px 18px; }
      .chapter-nav { flex-direction: column; }
      .chapter-nav a { min-width: unset; }
      .nav-next { align-items: flex-start; }
      .cover-chapter-num { font-size: 1.5em; }
    }
  </style>
</head>
<body>
  <!-- Reading Progress Bar -->
  <div class="progress-bar" id="progressBar"></div>

  
<header class="cover-header">
  <div class="cover-part" style="--part-color: #2563eb">
    <span class="cover-part-label">Part 1: 시작하기</span>
  </div>
  <div class="cover-chapter-num">Chapter 05</div>
</header>

  <div class="content">
    <nav class="toc">
<h2 class="toc-title">목차</h2>
<ul>
<li><a href="#5-1-dut-소개-4비트-업카운터">5.1 DUT 소개 — 4비트 업카운터</a></li>
  <li class="toc-sub"><a href="#5-1-1-검증할-대상-4비트-카운터">5.1.1 검증할 대상: 4비트 카운터</a></li>
  <li class="toc-sub"><a href="#5-1-2-interface-정의">5.1.2 Interface 정의</a></li>
<li><a href="#5-2-virtual-interface-왜-필요한가">5.2 Virtual Interface — 왜 필요한가</a></li>
  <li class="toc-sub"><a href="#5-2-1-문제-class에서-interface에-접근할-수-없다">5.2.1 문제: class에서 interface에 접근할 수 없다</a></li>
  <li class="toc-sub"><a href="#5-2-2-해결-virtual-interface">5.2.2 해결: virtual interface</a></li>
  <li class="toc-sub"><a href="#5-2-3-virtual-interface-선언과-사용">5.2.3 virtual interface 선언과 사용</a></li>
  <li class="toc-sub"><a href="#5-2-4-흔한-실수-virtual-interface를-연결-안-하면">5.2.4 흔한 실수: virtual interface를 연결 안 하면?</a></li>
<li><a href="#5-3-uvm-config-db-설정값-전달-메커니즘">5.3 uvm_config_db — 설정값 전달 메커니즘</a></li>
  <li class="toc-sub"><a href="#5-3-1-config-db가-필요한-이유">5.3.1 config_db가 필요한 이유</a></li>
  <li class="toc-sub"><a href="#5-3-2-config-db-사용법-set-과-get">5.3.2 config_db 사용법: set()과 get()</a></li>
  <li class="toc-sub"><a href="#5-3-3-set-get-패턴-정리">5.3.3 set/get 패턴 정리</a></li>
  <li class="toc-sub"><a href="#5-3-4-흔한-실수-config-db-get-실패">5.3.4 흔한 실수: config_db get 실패</a></li>
  <li class="toc-sub"><a href="#5-3-5-실습-config-db로-virtual-interface-전달">5.3.5 실습: config_db로 virtual interface 전달</a></li>
<li><a href="#5-4-드라이버와-모니터-기초">5.4 드라이버와 모니터 기초</a></li>
  <li class="toc-sub"><a href="#5-4-1-드라이버-신호를-보내는-역할">5.4.1 드라이버 = 신호를 보내는 역할</a></li>
  <li class="toc-sub"><a href="#5-4-2-모니터-신호를-관찰하는-역할">5.4.2 모니터 = 신호를 관찰하는 역할</a></li>
  <li class="toc-sub"><a href="#5-4-3-에이전트-드라이버-모니터-묶음">5.4.3 에이전트 = 드라이버 + 모니터 묶음</a></li>
<li><a href="#5-5-종합-첫-완전한-uvm-테스트벤치">5.5 종합: 첫 완전한 UVM 테스트벤치</a></li>
  <li class="toc-sub"><a href="#5-5-1-전체-구조-한눈에-보기">5.5.1 전체 구조 한눈에 보기</a></li>
  <li class="toc-sub"><a href="#5-5-2-단계별-빌드업">5.5.2 단계별 빌드업</a></li>
  <li class="toc-sub"><a href="#5-5-3-코드-구조-정리">5.5.3 코드 구조 정리</a></li>
<li><a href="#5-6-체크포인트">5.6 체크포인트</a></li>
  <li class="toc-sub"><a href="#셀프-체크">셀프 체크</a></li>
  <li class="toc-sub"><a href="#연습문제">연습문제</a></li>
  <li class="toc-sub"><a href="#흔한-에러와-해결법">흔한 에러와 해결법</a></li>
  <li class="toc-sub"><a href="#용어-정리">용어 정리</a></li>
  <li class="toc-sub"><a href="#다음-챕터-미리보기">다음 챕터 미리보기</a></li>
</ul>
</nav>
    <h1>Chapter 5: 첫 UVM 테스트벤치</h1>
<blockquote>
<p><strong>학습 목표</strong></p>
<ul>
<li>Virtual Interface의 역할과 사용법을 이해한다</li>
<li><code>uvm_config_db</code>로 설정값(virtual interface)을 전달할 수 있다</li>
<li>간단한 DUT(4비트 카운터)에 대한 완전한 UVM 테스트벤치를 작성할 수 있다</li>
<li>드라이버/모니터의 기본 동작 원리를 이해한다</li>
<li>시뮬레이션을 실행하고 결과를 해석할 수 있다</li>
</ul>
</blockquote>
<blockquote>
<p><strong>선수 지식</strong>: Chapter 3에서 배운 interface, class, extends를 사용합니다. Chapter 4에서 배운 uvm_component, Factory(type_id::create), Phase(build/connect/run)가 핵심 기반입니다.</p>
</blockquote>
<hr>
<h2 id="5-1-dut-소개-4비트-업카운터">5.1 DUT 소개 — 4비트 업카운터</h2>
<blockquote>
<p><strong>이 절의 목표</strong>: 검증할 대상(DUT)을 이해합니다. 이 챕터 전체에서 사용할 간단한 카운터입니다.</p>
</blockquote>
<h3 id="5-1-1-검증할-대상-4비트-카운터">5.1.1 검증할 대상: 4비트 카운터</h3>
<p>드디어 실제 DUT를 검증합니다! Chapter 1-4까지는 UVM의 개념과 구조를 배웠고, 이제부터는 <strong>진짜 검증</strong>을 시작합니다.</p>
<p>검증할 DUT는 4비트 업카운터입니다. 디지털 회로 수업에서 배운 바로 그 카운터입니다:</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// 파일: counter.sv</span>
<span class="hljs-comment">// DUT: 4비트 업카운터</span>
<span class="hljs-comment">// - rst_n = 0이면 카운트 초기화</span>
<span class="hljs-comment">// - enable = 1이면 클럭마다 1씩 증가</span>
<span class="hljs-comment">// - 15(4&#x27;hF) 다음에 0으로 돌아감 (오버플로)</span>

<span class="hljs-keyword">module</span> counter (
  <span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span>       clk,
  <span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span>       rst_n,    <span class="hljs-comment">// Active-low 리셋</span>
  <span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span>       enable,   <span class="hljs-comment">// 카운트 활성화</span>
  <span class="hljs-keyword">output</span> <span class="hljs-keyword">logic</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] count     <span class="hljs-comment">// 4비트 카운트 값</span>
);

  <span class="hljs-keyword">always_ff</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> rst_n) <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (!rst_n)
      count &lt;= <span class="hljs-number">4&#x27;b0</span>;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (enable)
      count &lt;= count + <span class="hljs-number">1</span>;
  <span class="hljs-keyword">end</span>

<span class="hljs-keyword">endmodule</span>
</code></pre><blockquote>
<p><strong>왜 카운터인가?</strong>: 카운터는 입력(clk, rst_n, enable)과 출력(count)이 명확하고, 동작도 직관적입니다. 복잡한 프로토콜 없이 UVM 테스트벤치의 <strong>구조</strong>에 집중할 수 있습니다.</p>
</blockquote>
<h3 id="5-1-2-interface-정의">5.1.2 Interface 정의</h3>
<p>Chapter 3에서 interface를 배웠습니다. DUT와 테스트벤치를 연결하는 interface를 정의합니다:</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// 파일: counter_if.sv</span>
<span class="hljs-comment">// DUT와 테스트벤치를 연결하는 인터페이스</span>
<span class="hljs-comment">// 클럭, 리셋, 입력(enable), 출력(count)을 묶어서 관리</span>

<span class="hljs-keyword">interface</span> counter_if (<span class="hljs-keyword">input</span> <span class="hljs-keyword">logic</span> clk);
  <span class="hljs-keyword">logic</span>       rst_n;
  <span class="hljs-keyword">logic</span>       enable;
  <span class="hljs-keyword">logic</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] count;
<span class="hljs-keyword">endinterface</span>
</code></pre><blockquote>
<p><strong>참고</strong>: 실무에서는 interface 안에 **클럭킹 블록(clocking block)**과 <strong>modport</strong>를 추가하여 드라이버/모니터의 타이밍 안정성과 접근 권한을 관리합니다. 이 기능은 Chapter 7에서 자세히 다룹니다. 지금은 가장 단순한 형태로 시작합니다.</p>
</blockquote>

<div class="svg-diagram">
<svg viewBox="0 0 720 400" xmlns="http://www.w3.org/2000/svg" style="max-width:720px;width:100%">
  
  <style>
    .diagram-box { fill: #ffffff; stroke: #334155; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-accent { fill: #eff6ff; stroke: #2563eb; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-highlight { fill: #fef3c7; stroke: #f59e0b; stroke-width: 2.5; rx: 10; ry: 10; }
    .diagram-box-dark { fill: #1e293b; stroke: #1e293b; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-run { fill: #fef3c7; stroke: #f59e0b; stroke-width: 3; rx: 10; ry: 10; }
    .diagram-box-green { fill: #ecfdf5; stroke: #10b981; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-purple { fill: #f5f3ff; stroke: #7c3aed; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-red { fill: #fef2f2; stroke: #ef4444; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-gray { fill: #f8fafc; stroke: #94a3b8; stroke-width: 1.5; rx: 8; ry: 8; }
    .diagram-text { font-family: 'Noto Sans KR', sans-serif; fill: #1e293b; }
    .diagram-text-white { font-family: 'Noto Sans KR', sans-serif; fill: #ffffff; }
    .diagram-text-accent { font-family: 'Noto Sans KR', sans-serif; fill: #2563eb; }
    .diagram-text-small { font-family: 'Noto Sans KR', sans-serif; fill: #64748b; font-size: 12px; }
    .diagram-text-code { font-family: 'Fira Code', 'JetBrains Mono', monospace; fill: #1e293b; }
    .diagram-arrow { fill: none; stroke: #64748b; stroke-width: 1.5; }
    .diagram-arrow-accent { fill: none; stroke: #2563eb; stroke-width: 1.5; }
    .diagram-line { stroke: #cbd5e1; stroke-width: 1.5; stroke-dasharray: 6,3; }
  </style>
  <defs>
    <marker id="arrowhead" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#64748b" />
    </marker>
    <marker id="arrowhead-accent" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#2563eb" />
    </marker>
    <marker id="arrowhead-dark" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#1e293b" />
    </marker>
    <marker id="arrowhead-orange" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#f59e0b" />
    </marker>
    <filter id="shadow" x="-5%" y="-5%" width="115%" height="115%">
      <feDropShadow dx="0" dy="2" stdDeviation="3" flood-color="#000" flood-opacity="0.1"/>
    </filter>
  </defs>


  <!-- UVM Testbench region -->
  <rect x="20" y="10" width="680" height="180" rx="12" ry="12" fill="#eff6ff" stroke="#2563eb" stroke-width="2" stroke-dasharray="6,3"/>
  <text x="40" y="34" class="diagram-text-accent" font-size="13" font-weight="bold">테스트벤치 (UVM)</text>

  <!-- Test -->
  <rect x="50" y="50" width="100" height="44" class="diagram-box-highlight" filter="url(#shadow)"/>
  <text x="100" y="77" text-anchor="middle" class="diagram-text-code" font-size="12" font-weight="bold">Test</text>

  <!-- Driver -->
  <rect x="240" y="50" width="160" height="44" class="diagram-box-green" filter="url(#shadow)"/>
  <text x="320" y="70" text-anchor="middle" class="diagram-text-code" font-size="12" font-weight="bold">Driver</text>
  <text x="320" y="86" text-anchor="middle" class="diagram-text-small" font-size="10">(신호 구동)</text>

  <!-- Monitor -->
  <rect x="480" y="50" width="160" height="44" class="diagram-box-purple" filter="url(#shadow)"/>
  <text x="560" y="70" text-anchor="middle" class="diagram-text-code" font-size="12" font-weight="bold">Monitor</text>
  <text x="560" y="86" text-anchor="middle" class="diagram-text-small" font-size="10">(신호 관찰)</text>

  <!-- Arrows from driver/monitor down to interface -->
  <line x1="320" y1="94" x2="320" y2="130" stroke="#10b981" stroke-width="1.5" marker-end="url(#arrowhead)"/>
  <line x1="560" y1="94" x2="560" y2="130" stroke="#7c3aed" stroke-width="1.5" marker-end="url(#arrowhead)"/>
  <text x="295" y="118" class="diagram-text-small" font-size="9" fill="#10b981">write</text>
  <text x="540" y="118" class="diagram-text-small" font-size="9" fill="#7c3aed">read</text>

  <!-- vif labels -->
  <text x="320" y="148" text-anchor="middle" class="diagram-text-code" font-size="10" fill="#2563eb">vif</text>
  <text x="560" y="148" text-anchor="middle" class="diagram-text-code" font-size="10" fill="#2563eb">vif</text>

  <!-- Interface bar -->
  <rect x="60" y="200" width="600" height="44" class="diagram-box-accent" filter="url(#shadow)"/>
  <text x="360" y="227" text-anchor="middle" class="diagram-text-code" font-size="13" font-weight="bold">counter_if (Interface)</text>

  <!-- Connection lines from vif labels to interface -->
  <line x1="320" y1="155" x2="320" y2="200" stroke="#2563eb" stroke-width="1.5" stroke-dasharray="4,3"/>
  <line x1="560" y1="155" x2="560" y2="200" stroke="#2563eb" stroke-width="1.5" stroke-dasharray="4,3"/>

  <!-- DUT -->
  <rect x="160" y="290" width="400" height="60" class="diagram-box-gray" filter="url(#shadow)"/>
  <text x="360" y="318" text-anchor="middle" class="diagram-text-code" font-size="14" font-weight="bold">DUT: counter</text>
  <text x="360" y="338" text-anchor="middle" class="diagram-text-small" font-size="11">clk, rst_n, enable → count[3:0]</text>

  <!-- Arrow Interface to DUT -->
  <line x1="360" y1="244" x2="360" y2="290" stroke="#64748b" stroke-width="1.5" marker-end="url(#arrowhead)"/>
  <text x="375" y="272" class="diagram-text-small" font-size="10">신호 연결</text>

  <!-- Signal labels on interface -->
  <text x="140" y="222" class="diagram-text-code" font-size="10" fill="#64748b">rst_n</text>
  <text x="430" y="222" class="diagram-text-code" font-size="10" fill="#64748b">enable</text>
  <text x="560" y="222" class="diagram-text-code" font-size="10" fill="#64748b">count</text>
</svg>
</div><hr>
<h2 id="5-2-virtual-interface-왜-필요한가">5.2 Virtual Interface — 왜 필요한가</h2>
<blockquote>
<p><strong>이 절의 목표</strong>: UVM 클래스에서 DUT 신호에 접근하기 위해 virtual interface가 왜 필요한지 이해하고, 사용법을 익힙니다.</p>
</blockquote>
<h3 id="5-2-1-문제-class에서-interface에-접근할-수-없다">5.2.1 문제: class에서 interface에 접근할 수 없다</h3>
<p>UVM의 드라이버와 모니터는 <strong>class</strong>입니다. DUT의 신호는 <strong>module/interface</strong> 영역에 있습니다. SystemVerilog에서 class는 module의 신호를 직접 참조할 수 없습니다:</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// ❌ 불가능! class에서 interface 인스턴스를 직접 참조 불가</span>
<span class="hljs-keyword">class</span> my_driver <span class="hljs-keyword">extends</span> uvm_driver;
  <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);
    top<span class="hljs-variable">.vif</span><span class="hljs-variable">.enable</span> = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 컴파일 에러! class → module 접근 불가</span>
  <span class="hljs-keyword">endfunction</span>
<span class="hljs-keyword">endclass</span>
</code></pre><p>이것은 SystemVerilog의 근본적인 규칙입니다:</p>
<ul>
<li><strong>module 영역</strong> (정적): module, interface, wire, reg — 합성(synthesis) 대상</li>
<li><strong>class 영역</strong> (동적): class, object, handle — 시뮬레이션에서만 존재</li>
</ul>
<p>이 두 세계를 연결하는 다리가 바로 <strong>virtual interface</strong>입니다.</p>
<h3 id="5-2-2-해결-virtual-interface">5.2.2 해결: virtual interface</h3>
<p><code>virtual interface</code>는 interface에 대한 **참조(핸들)**입니다. class 안에서 module 영역의 interface를 가리키는 포인터라고 생각하면 됩니다:</p>

<div class="svg-diagram">
<svg viewBox="0 0 700 240" xmlns="http://www.w3.org/2000/svg" style="max-width:700px;width:100%">
  
  <style>
    .diagram-box { fill: #ffffff; stroke: #334155; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-accent { fill: #eff6ff; stroke: #2563eb; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-highlight { fill: #fef3c7; stroke: #f59e0b; stroke-width: 2.5; rx: 10; ry: 10; }
    .diagram-box-dark { fill: #1e293b; stroke: #1e293b; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-run { fill: #fef3c7; stroke: #f59e0b; stroke-width: 3; rx: 10; ry: 10; }
    .diagram-box-green { fill: #ecfdf5; stroke: #10b981; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-purple { fill: #f5f3ff; stroke: #7c3aed; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-red { fill: #fef2f2; stroke: #ef4444; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-gray { fill: #f8fafc; stroke: #94a3b8; stroke-width: 1.5; rx: 8; ry: 8; }
    .diagram-text { font-family: 'Noto Sans KR', sans-serif; fill: #1e293b; }
    .diagram-text-white { font-family: 'Noto Sans KR', sans-serif; fill: #ffffff; }
    .diagram-text-accent { font-family: 'Noto Sans KR', sans-serif; fill: #2563eb; }
    .diagram-text-small { font-family: 'Noto Sans KR', sans-serif; fill: #64748b; font-size: 12px; }
    .diagram-text-code { font-family: 'Fira Code', 'JetBrains Mono', monospace; fill: #1e293b; }
    .diagram-arrow { fill: none; stroke: #64748b; stroke-width: 1.5; }
    .diagram-arrow-accent { fill: none; stroke: #2563eb; stroke-width: 1.5; }
    .diagram-line { stroke: #cbd5e1; stroke-width: 1.5; stroke-dasharray: 6,3; }
  </style>
  <defs>
    <marker id="arrowhead" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#64748b" />
    </marker>
    <marker id="arrowhead-accent" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#2563eb" />
    </marker>
    <marker id="arrowhead-dark" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#1e293b" />
    </marker>
    <marker id="arrowhead-orange" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#f59e0b" />
    </marker>
    <filter id="shadow" x="-5%" y="-5%" width="115%" height="115%">
      <feDropShadow dx="0" dy="2" stdDeviation="3" flood-color="#000" flood-opacity="0.1"/>
    </filter>
  </defs>


  <!-- Module domain -->
  <rect x="20" y="20" width="260" height="200" rx="12" ry="12" fill="#f8fafc" stroke="#94a3b8" stroke-width="2" stroke-dasharray="6,3"/>
  <text x="40" y="44" class="diagram-text" font-size="12" font-weight="bold" fill="#64748b">module 영역 (정적)</text>

  <!-- counter_if box -->
  <rect x="45" y="60" width="210" height="100" class="diagram-box-accent" filter="url(#shadow)"/>
  <text x="150" y="88" text-anchor="middle" class="diagram-text-code" font-size="13" font-weight="bold">counter_if</text>
  <text x="150" y="108" text-anchor="middle" class="diagram-text-small" font-size="11">(실제 신호)</text>
  <text x="70" y="132" class="diagram-text-code" font-size="10" fill="#64748b">.rst_n  .enable  .count</text>

  <!-- Class domain -->
  <rect x="420" y="20" width="260" height="200" rx="12" ry="12" fill="#eff6ff" stroke="#2563eb" stroke-width="2" stroke-dasharray="6,3"/>
  <text x="440" y="44" class="diagram-text" font-size="12" font-weight="bold" fill="#2563eb">class 영역 (UVM)</text>

  <!-- my_driver box -->
  <rect x="445" y="60" width="210" height="100" class="diagram-box-green" filter="url(#shadow)"/>
  <text x="550" y="85" text-anchor="middle" class="diagram-text-code" font-size="12" font-weight="bold">my_driver</text>
  <text x="550" y="108" text-anchor="middle" class="diagram-text-code" font-size="10">virtual counter_if vif;</text>
  <text x="550" y="132" text-anchor="middle" class="diagram-text-code" font-size="10" fill="#10b981">vif.enable = 1; (가능!)</text>

  <!-- Arrow: reference from class to module -->
  <line x1="445" y1="110" x2="255" y2="110" stroke="#2563eb" stroke-width="3" marker-start="url(#arrowhead)"/>

  <!-- Label on arrow -->
  <rect x="300" y="86" width="110" height="28" rx="14" ry="14" fill="#2563eb"/>
  <text x="355" y="105" text-anchor="middle" class="diagram-text-white" font-size="11" font-weight="bold">참조 (핸들)</text>

  <!-- Bottom label -->
  <text x="350" y="232" text-anchor="middle" class="diagram-text" font-size="11" fill="#64748b">virtual interface = class에서 module 신호에 접근하는 다리</text>
</svg>
</div><blockquote>
<p><strong>비유</strong>: virtual interface = <strong>리모컨</strong></p>
<ul>
<li>Interface = TV (실제 장치)</li>
<li>Virtual interface = 리모컨 (TV를 제어하는 참조)</li>
<li>class 안에서 리모컨(virtual interface)으로 TV(interface)를 조작합니다</li>
<li>리모컨이 없으면 TV를 제어할 수 없듯이, virtual interface가 없으면 DUT 신호에 접근할 수 없습니다</li>
</ul>
</blockquote>
<h3 id="5-2-3-virtual-interface-선언과-사용">5.2.3 virtual interface 선언과 사용</h3>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// class 내부에서 virtual interface 선언</span>
<span class="hljs-keyword">class</span> my_driver <span class="hljs-keyword">extends</span> uvm_component;
  `uvm_component_utils(my_driver)

  <span class="hljs-keyword">virtual</span> counter_if vif;  <span class="hljs-comment">// ⭐ virtual 키워드가 핵심!</span>

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> run_phase(uvm_phase phase);
    phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);

    <span class="hljs-comment">// virtual interface를 통해 DUT 신호 접근 가능!</span>
    vif<span class="hljs-variable">.rst_n</span>  = <span class="hljs-number">0</span>;              <span class="hljs-comment">// 리셋 활성화</span>
    @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>);          <span class="hljs-comment">// 클럭 대기</span>
    vif<span class="hljs-variable">.rst_n</span>  = <span class="hljs-number">1</span>;              <span class="hljs-comment">// 리셋 해제</span>
    vif<span class="hljs-variable">.enable</span> = <span class="hljs-number">1</span>;              <span class="hljs-comment">// 카운터 활성화</span>
    <span class="hljs-keyword">repeat</span>(<span class="hljs-number">5</span>) @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>); <span class="hljs-comment">// 5클럭 대기</span>

    `uvm_info(get_type_name(),
      <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;카운터 값: %0d&quot;</span>, vif<span class="hljs-variable">.count</span>), UVM_MEDIUM)

    phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>
</code></pre><blockquote>
<p><strong>핵심</strong>: <code>virtual counter_if vif;</code>로 선언하면 class에서 interface의 신호에 접근할 수 있습니다. 하지만 선언만으로는 부족합니다 — vif에 실제 interface를 <strong>연결</strong>해야 합니다. 이것이 다음 절의 <code>uvm_config_db</code>입니다.</p>
</blockquote>
<h3 id="5-2-4-흔한-실수-virtual-interface를-연결-안-하면">5.2.4 흔한 실수: virtual interface를 연결 안 하면?</h3>
<pre><code class="hljs language-systemverilog"><span class="hljs-keyword">virtual</span> counter_if vif;  <span class="hljs-comment">// 선언만 함 (연결 안 함)</span>

<span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> run_phase(uvm_phase phase);
  vif<span class="hljs-variable">.drv_cb</span><span class="hljs-variable">.enable</span> &lt;= <span class="hljs-number">1</span>;  <span class="hljs-comment">// null 참조 에러!</span>
<span class="hljs-keyword">endtask</span>
</code></pre><pre><code>에러 메시지:
** Fatal: (SIGSEGV) Bad handle or reference.
</code></pre><p><code>vif</code>가 아무 interface도 가리키고 있지 않기 때문입니다. Chapter 3에서 배운 &quot;핸들은 선언만으로는 null&quot;과 같은 원리입니다. 다음 절에서 <code>uvm_config_db</code>로 연결하는 방법을 배웁니다.</p>
<blockquote>
<p><strong>면접 빈출</strong>: &quot;Virtual interface란 무엇이고 왜 필요한가요?&quot;는 팹리스 면접에서 매우 자주 나옵니다. &quot;class에서 module/interface 영역의 신호에 접근하기 위한 참조(핸들)&quot; 이라고 답하면 됩니다.</p>
</blockquote>
<hr>
<h2 id="5-3-uvm-config-db-설정값-전달-메커니즘">5.3 uvm_config_db — 설정값 전달 메커니즘</h2>
<blockquote>
<p><strong>이 절의 목표</strong>: <code>uvm_config_db</code>의 set/get 패턴을 이해하고, virtual interface를 테스트벤치 컴포넌트에 전달할 수 있습니다.</p>
</blockquote>
<h3 id="5-3-1-config-db가-필요한-이유">5.3.1 config_db가 필요한 이유</h3>
<p>virtual interface를 연결하는 방법이 필요합니다. 다음과 같은 상황을 생각해봅시다:</p>
<pre><code>문제: top 모듈에서 만든 interface를 어떻게 UVM 클래스로 전달하지?

module top;
  counter_if vif(clk);     // interface는 module 영역에서 생성
  counter dut(             // DUT 연결
    .clk(clk), .rst_n(vif.rst_n), .enable(vif.enable), .count(vif.count)
  );
  initial run_test(&quot;my_test&quot;);  // UVM 테스트 시작
endmodule

// my_driver는 class — vif를 어떻게 받지?
</code></pre><p>직접 전달할 방법이 없습니다 — class 생성자에 interface를 파라미터로 넣을 수도 없고, 전역 변수를 쓰는 것은 나쁜 설계입니다.</p>
<p><code>uvm_config_db</code>는 이 문제를 해결하는 <strong>글로벌 설정 저장소</strong>입니다:</p>

<div class="svg-diagram">
<svg viewBox="0 0 680 300" xmlns="http://www.w3.org/2000/svg" style="max-width:680px;width:100%">
  
  <style>
    .diagram-box { fill: #ffffff; stroke: #334155; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-accent { fill: #eff6ff; stroke: #2563eb; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-highlight { fill: #fef3c7; stroke: #f59e0b; stroke-width: 2.5; rx: 10; ry: 10; }
    .diagram-box-dark { fill: #1e293b; stroke: #1e293b; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-run { fill: #fef3c7; stroke: #f59e0b; stroke-width: 3; rx: 10; ry: 10; }
    .diagram-box-green { fill: #ecfdf5; stroke: #10b981; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-purple { fill: #f5f3ff; stroke: #7c3aed; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-red { fill: #fef2f2; stroke: #ef4444; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-gray { fill: #f8fafc; stroke: #94a3b8; stroke-width: 1.5; rx: 8; ry: 8; }
    .diagram-text { font-family: 'Noto Sans KR', sans-serif; fill: #1e293b; }
    .diagram-text-white { font-family: 'Noto Sans KR', sans-serif; fill: #ffffff; }
    .diagram-text-accent { font-family: 'Noto Sans KR', sans-serif; fill: #2563eb; }
    .diagram-text-small { font-family: 'Noto Sans KR', sans-serif; fill: #64748b; font-size: 12px; }
    .diagram-text-code { font-family: 'Fira Code', 'JetBrains Mono', monospace; fill: #1e293b; }
    .diagram-arrow { fill: none; stroke: #64748b; stroke-width: 1.5; }
    .diagram-arrow-accent { fill: none; stroke: #2563eb; stroke-width: 1.5; }
    .diagram-line { stroke: #cbd5e1; stroke-width: 1.5; stroke-dasharray: 6,3; }
  </style>
  <defs>
    <marker id="arrowhead" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#64748b" />
    </marker>
    <marker id="arrowhead-accent" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#2563eb" />
    </marker>
    <marker id="arrowhead-dark" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#1e293b" />
    </marker>
    <marker id="arrowhead-orange" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#f59e0b" />
    </marker>
    <filter id="shadow" x="-5%" y="-5%" width="115%" height="115%">
      <feDropShadow dx="0" dy="2" stdDeviation="3" flood-color="#000" flood-opacity="0.1"/>
    </filter>
  </defs>


  <!-- config_db store (center) -->
  <rect x="210" y="20" width="260" height="80" class="diagram-box-accent" filter="url(#shadow)"/>
  <text x="340" y="50" text-anchor="middle" class="diagram-text-code" font-size="14" font-weight="bold">uvm_config_db</text>
  <text x="340" y="72" text-anchor="middle" class="diagram-text-small" font-size="11">(글로벌 설정 저장소)</text>

  <!-- Stored item -->
  <rect x="280" y="110" width="120" height="32" rx="6" ry="6" fill="#dbeafe" stroke="#2563eb" stroke-width="1.5"/>
  <text x="340" y="131" text-anchor="middle" class="diagram-text-code" font-size="11" fill="#2563eb">"vif" = vif</text>

  <!-- top module (left) -->
  <rect x="30" y="180" width="180" height="80" class="diagram-box-gray" filter="url(#shadow)"/>
  <text x="120" y="210" text-anchor="middle" class="diagram-text-code" font-size="12" font-weight="bold">top 모듈</text>
  <text x="120" y="232" text-anchor="middle" class="diagram-text-small" font-size="10">(module 영역)</text>
  <text x="120" y="250" text-anchor="middle" class="diagram-text-code" font-size="9" fill="#64748b">counter_if vif(clk);</text>

  <!-- driver (right) -->
  <rect x="470" y="180" width="180" height="80" class="diagram-box-green" filter="url(#shadow)"/>
  <text x="560" y="210" text-anchor="middle" class="diagram-text-code" font-size="12" font-weight="bold">driver</text>
  <text x="560" y="232" text-anchor="middle" class="diagram-text-small" font-size="10">(class 영역)</text>
  <text x="560" y="250" text-anchor="middle" class="diagram-text-code" font-size="9" fill="#64748b">virtual counter_if vif;</text>

  <!-- Arrow: top → config_db (set) -->
  <path d="M 120 180 L 120 126 L 280 126" stroke="#f59e0b" stroke-width="1.5" fill="none" marker-end="url(#arrowhead)"/>
  <rect x="100" y="140" width="60" height="22" rx="4" ry="4" fill="#f59e0b"/>
  <text x="130" y="155" text-anchor="middle" class="diagram-text-white" font-size="10" font-weight="bold">set()</text>

  <!-- Arrow: config_db → driver (get) -->
  <path d="M 400 126 L 560 126 L 560 180" stroke="#10b981" stroke-width="1.5" fill="none" marker-end="url(#arrowhead)"/>
  <rect x="520" y="140" width="60" height="22" rx="4" ry="4" fill="#10b981"/>
  <text x="550" y="155" text-anchor="middle" class="diagram-text-white" font-size="10" font-weight="bold">get()</text>

  <!-- Bottom note -->
  <text x="340" y="288" text-anchor="middle" class="diagram-text-small" font-size="11">set()과 get()에서 타입과 이름이 반드시 같아야 합니다</text>
</svg>
</div><blockquote>
<p><strong>비유</strong>: config_db = <strong>호텔 프런트 데스크</strong></p>
<ul>
<li><code>set()</code> = 프런트에 열쇠를 맡김 (&quot;305호 열쇠 맡길게요&quot;)</li>
<li><code>get()</code> = 프런트에서 열쇠를 찾음 (&quot;305호 열쇠 주세요&quot;)</li>
<li>맡긴 사람과 찾는 사람이 직접 만날 필요 없음 (느슨한 결합)</li>
</ul>
</blockquote>
<h3 id="5-3-2-config-db-사용법-set-과-get">5.3.2 config_db 사용법: set()과 get()</h3>
<p><strong>1단계: set() — 값 저장 (보통 top 모듈에서)</strong></p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// top 모듈에서 interface를 config_db에 저장</span>
<span class="hljs-keyword">module</span> top;
  <span class="hljs-keyword">logic</span> clk;
  counter_if vif(clk);  <span class="hljs-comment">// interface 생성</span>
  counter dut(
    <span class="hljs-variable">.clk</span>(clk), <span class="hljs-variable">.rst_n</span>(vif<span class="hljs-variable">.rst_n</span>),
    <span class="hljs-variable">.enable</span>(vif<span class="hljs-variable">.enable</span>), <span class="hljs-variable">.count</span>(vif<span class="hljs-variable">.count</span>)
  );

  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span>
    <span class="hljs-comment">// ⭐ config_db에 virtual interface 저장</span>
    uvm_config_db<span class="hljs-variable">#(virtual counter_if)</span>::set(
      <span class="hljs-literal">null</span>,       <span class="hljs-comment">// 컨텍스트 (null = 전역)</span>
      <span class="hljs-string">&quot;*&quot;</span>,        <span class="hljs-comment">// 대상 경로 (* = 모든 컴포넌트)</span>
      <span class="hljs-string">&quot;vif&quot;</span>,      <span class="hljs-comment">// 이름 (get할 때 이 이름으로 찾음)</span>
      vif         <span class="hljs-comment">// 저장할 값 (actual interface)</span>
    );
    run_test(<span class="hljs-string">&quot;counter_test&quot;</span>);
  <span class="hljs-keyword">end</span>

  <span class="hljs-comment">// 클럭 생성</span>
  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span>
    clk = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">forever</span> #<span class="hljs-number">5</span> clk = ~clk;  <span class="hljs-comment">// 10ns 주기</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</code></pre><blockquote>
<p><strong>실무 참고</strong>: 위 예제에서 <code>set(null, &quot;*&quot;, ...)</code> 패턴은 모든 컴포넌트가 접근할 수 있도록 전역 설정입니다. 학습용으로는 충분하지만, 실무에서는 <code>set(this, &quot;env.agent.drv&quot;, &quot;vif&quot;, vif)</code> 처럼 특정 컴포넌트 경로를 지정하여 범위를 좁히는 것이 좋습니다. 지금은 <code>&quot;*&quot;</code> 패턴만 사용합니다.</p>
</blockquote>
<p><strong>2단계: get() — 값 가져오기 (보통 build_phase에서)</strong></p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// 드라이버에서 config_db로부터 virtual interface 가져오기</span>
<span class="hljs-keyword">class</span> counter_driver <span class="hljs-keyword">extends</span> uvm_component;
  `uvm_component_utils(counter_driver)

  <span class="hljs-keyword">virtual</span> counter_if vif;  <span class="hljs-comment">// virtual interface 핸들</span>

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);
    <span class="hljs-comment">// ⭐ config_db에서 virtual interface 가져오기</span>
    <span class="hljs-keyword">if</span> (!uvm_config_db<span class="hljs-variable">#(virtual counter_if)</span>::get(
          <span class="hljs-keyword">this</span>,     <span class="hljs-comment">// 현재 컴포넌트</span>
          <span class="hljs-string">&quot;&quot;</span>,       <span class="hljs-comment">// 상대 경로 (비어있으면 현재 위치)</span>
          <span class="hljs-string">&quot;vif&quot;</span>,    <span class="hljs-comment">// 이름 (set할 때 사용한 이름과 동일!)</span>
          vif       <span class="hljs-comment">// 가져온 값을 저장할 변수</span>
        ))
      `uvm_fatal(get_type_name(), <span class="hljs-string">&quot;config_db에서 vif를 찾지 못했습니다!&quot;</span>)
  <span class="hljs-keyword">endfunction</span>
<span class="hljs-keyword">endclass</span>
</code></pre><h3 id="5-3-3-set-get-패턴-정리">5.3.3 set/get 패턴 정리</h3>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// set() 패턴: 값 저장</span>
uvm_config_db<span class="hljs-variable">#(타입)::set(컨텍스트, 경로, 이름, 값)</span>;

<span class="hljs-comment">// get() 패턴: 값 가져오기</span>
uvm_config_db<span class="hljs-variable">#(타입)::get(컨텍스트, 경로, 이름, 변수)</span>;
</code></pre><table>
<thead>
<tr>
<th>파라미터</th>
<th>set()에서</th>
<th>get()에서</th>
</tr>
</thead>
<tbody><tr>
<td>타입</td>
<td><code>virtual counter_if</code></td>
<td><code>virtual counter_if</code> (동일해야 함)</td>
</tr>
<tr>
<td>컨텍스트</td>
<td><code>null</code> (전역)</td>
<td><code>this</code> (현재 컴포넌트)</td>
</tr>
<tr>
<td>경로</td>
<td><code>&quot;*&quot;</code> (모든 대상)</td>
<td><code>&quot;&quot;</code> (현재 위치)</td>
</tr>
<tr>
<td>이름</td>
<td><code>&quot;vif&quot;</code> (저장 이름)</td>
<td><code>&quot;vif&quot;</code> (동일해야 함!)</td>
</tr>
<tr>
<td>값/변수</td>
<td><code>vif</code> (저장할 값)</td>
<td><code>vif</code> (가져올 변수)</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>기억하세요</strong>: set()과 get()에서 <strong>타입</strong>과 <strong>이름</strong>이 반드시 같아야 합니다. 하나라도 다르면 get()이 실패합니다.</p>
</blockquote>
<blockquote>
<p><strong>안심하세요</strong>: config_db의 문법이 길고 복잡해 보이지만, 실제로 사용하는 패턴은 <strong>set/get 딱 2가지</strong>뿐입니다. 위의 코드를 그대로 복사해서 타입과 이름만 바꾸면 됩니다. UVM 코드를 많이 작성하다 보면 자연스럽게 외워집니다.</p>
</blockquote>
<h3 id="5-3-4-흔한-실수-config-db-get-실패">5.3.4 흔한 실수: config_db get 실패</h3>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// ❌ 실수 1: 이름이 다름</span>
uvm_config_db<span class="hljs-variable">#(virtual counter_if)::set(null, &quot;*&quot;, &quot;vif&quot;, vif)</span>;      <span class="hljs-comment">// set: &quot;vif&quot;</span>
uvm_config_db<span class="hljs-variable">#(virtual counter_if)::get(this, &quot;&quot;, &quot;counter_vif&quot;, vif)</span>; <span class="hljs-comment">// get: &quot;counter_vif&quot; ← 다르다!</span>

<span class="hljs-comment">// ❌ 실수 2: 타입이 다름</span>
uvm_config_db<span class="hljs-variable">#(virtual counter_if)::set(null, &quot;*&quot;, &quot;vif&quot;, vif)</span>;       <span class="hljs-comment">// set: counter_if</span>
uvm_config_db<span class="hljs-variable">#(virtual other_if)::get(this, &quot;&quot;, &quot;vif&quot;, other_vif)</span>;     <span class="hljs-comment">// get: other_if ← 다르다!</span>

<span class="hljs-comment">// ❌ 실수 3: set()을 빠뜨림</span>
<span class="hljs-comment">// top 모듈에서 set()을 호출하지 않으면 get()이 실패합니다</span>
</code></pre><pre><code>에러 메시지:
UVM_FATAL @ 0: uvm_test_top.env.agent.drv [counter_driver] config_db에서 vif를 찾지 못했습니다!
</code></pre><blockquote>
<p><strong>디버깅 팁</strong>: config_db get이 실패하면 먼저 3가지를 확인하세요:</p>
<ol>
<li>top 모듈에서 <code>set()</code>을 호출했는가?</li>
<li>set()과 get()의 <strong>이름</strong>(&quot;vif&quot;)이 같은가?</li>
<li>set()과 get()의 <strong>타입</strong>(virtual counter_if)이 같은가?</li>
</ol>
</blockquote>
<h3 id="5-3-5-실습-config-db로-virtual-interface-전달">5.3.5 실습: config_db로 virtual interface 전달</h3>
<p><strong>[예제 5-1] Virtual Interface 전달 테스트</strong></p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// 파일: testbench.sv (EDA Playground)</span>
<span class="hljs-comment">// [예제 5-1] config_db로 virtual interface 전달</span>
<span class="hljs-comment">// 목적: set/get으로 virtual interface를 전달하고 DUT 신호에 접근</span>
<span class="hljs-comment">// 시뮬레이터 설정: SystemVerilog, UVM 1.2</span>

<span class="hljs-meta">`<span class="hljs-keyword">include</span> &quot;uvm_macros.svh&quot;</span>
<span class="hljs-keyword">import</span> uvm_pkg::*;

<span class="hljs-comment">// ── DUT ──</span>
<span class="hljs-keyword">module</span> counter (
  <span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span>       clk,
  <span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span>       rst_n,
  <span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span>       enable,
  <span class="hljs-keyword">output</span> <span class="hljs-keyword">logic</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] count
);
  <span class="hljs-keyword">always_ff</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> rst_n) <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (!rst_n) count &lt;= <span class="hljs-number">4&#x27;b0</span>;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (enable) count &lt;= count + <span class="hljs-number">1</span>;
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>

<span class="hljs-comment">// ── Interface ──</span>
<span class="hljs-keyword">interface</span> counter_if (<span class="hljs-keyword">input</span> <span class="hljs-keyword">logic</span> clk);
  <span class="hljs-keyword">logic</span>       rst_n;
  <span class="hljs-keyword">logic</span>       enable;
  <span class="hljs-keyword">logic</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] count;
<span class="hljs-keyword">endinterface</span>

<span class="hljs-comment">// ── 간단한 드라이버 ──</span>
<span class="hljs-keyword">class</span> simple_driver <span class="hljs-keyword">extends</span> uvm_component;
  `uvm_component_utils(simple_driver)

  <span class="hljs-keyword">virtual</span> counter_if vif;  <span class="hljs-comment">// virtual interface 핸들</span>

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);
    <span class="hljs-comment">// config_db에서 virtual interface 가져오기</span>
    <span class="hljs-keyword">if</span> (!uvm_config_db<span class="hljs-variable">#(virtual counter_if)::get(this, &quot;&quot;, &quot;vif&quot;, vif))</span>
      `uvm_fatal(get_type_name(), <span class="hljs-string">&quot;config_db에서 vif를 찾을 수 없습니다!&quot;</span>)
    `uvm_info(get_type_name(), <span class="hljs-string">&quot;virtual interface 연결 성공!&quot;</span>, UVM_MEDIUM)
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> run_phase(uvm_phase phase);
    phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);

    <span class="hljs-comment">// 리셋</span>
    vif<span class="hljs-variable">.rst_n</span>  = <span class="hljs-number">0</span>;
    vif<span class="hljs-variable">.enable</span> = <span class="hljs-number">0</span>;
    @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>);
    @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>);
    vif<span class="hljs-variable">.rst_n</span>  = <span class="hljs-number">1</span>;
    `uvm_info(get_type_name(), <span class="hljs-string">&quot;리셋 해제&quot;</span>, UVM_MEDIUM)

    <span class="hljs-comment">// 카운터 활성화</span>
    vif<span class="hljs-variable">.enable</span> = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">repeat</span>(<span class="hljs-number">5</span>) <span class="hljs-keyword">begin</span>
      @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>);
      `uvm_info(get_type_name(),
        <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;카운터 값: %0d&quot;</span>, vif<span class="hljs-variable">.count</span>), UVM_MEDIUM)
    <span class="hljs-keyword">end</span>

    vif<span class="hljs-variable">.enable</span> = <span class="hljs-number">0</span>;
    phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>

<span class="hljs-comment">// ── 테스트 ──</span>
<span class="hljs-keyword">class</span> config_test <span class="hljs-keyword">extends</span> uvm_test;
  `uvm_component_utils(config_test)

  simple_driver drv;

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);
    drv = simple_driver::type_id::create(<span class="hljs-string">&quot;drv&quot;</span>, <span class="hljs-keyword">this</span>);
  <span class="hljs-keyword">endfunction</span>
<span class="hljs-keyword">endclass</span>

<span class="hljs-comment">// ── Top 모듈 ──</span>
<span class="hljs-keyword">module</span> top;
  <span class="hljs-keyword">logic</span> clk;

  <span class="hljs-comment">// 클럭 생성</span>
  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span>
    clk = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">forever</span> #<span class="hljs-number">5</span> clk = ~clk;
  <span class="hljs-keyword">end</span>

  <span class="hljs-comment">// Interface 인스턴스</span>
  counter_if vif(clk);

  <span class="hljs-comment">// DUT 연결</span>
  counter dut (
    <span class="hljs-variable">.clk</span>    (clk),
    <span class="hljs-variable">.rst_n</span>  (vif<span class="hljs-variable">.rst_n</span>),
    <span class="hljs-variable">.enable</span> (vif<span class="hljs-variable">.enable</span>),
    <span class="hljs-variable">.count</span>  (vif<span class="hljs-variable">.count</span>)
  );

  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span>
    <span class="hljs-comment">// ⭐ config_db에 virtual interface 저장</span>
    uvm_config_db<span class="hljs-variable">#(virtual counter_if)::set(null, &quot;*&quot;, &quot;vif&quot;, vif)</span>;
    run_test(<span class="hljs-string">&quot;config_test&quot;</span>);
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</code></pre><p><strong>예상 출력</strong>:</p>
<pre><code>UVM_INFO @ 0: uvm_test_top.drv [simple_driver] virtual interface 연결 성공!
UVM_INFO @ 0: uvm_test_top.drv [simple_driver] 리셋 해제
UVM_INFO @ 15: uvm_test_top.drv [simple_driver] 카운터 값: 1
UVM_INFO @ 25: uvm_test_top.drv [simple_driver] 카운터 값: 2
UVM_INFO @ 35: uvm_test_top.drv [simple_driver] 카운터 값: 3
UVM_INFO @ 45: uvm_test_top.drv [simple_driver] 카운터 값: 4
UVM_INFO @ 55: uvm_test_top.drv [simple_driver] 카운터 값: 5
</code></pre><blockquote>
<p><strong>성취감 포인트</strong>: 축하합니다! UVM 클래스에서 DUT의 실제 신호를 읽고 제어할 수 있게 되었습니다. virtual interface + config_db 조합이 바로 UVM에서 DUT를 연결하는 표준 방법입니다.</p>
</blockquote>
<blockquote>
<p><strong>참고</strong>: 예상 출력의 타임스탬프는 시뮬레이터와 클럭 설정에 따라 다를 수 있습니다. 카운터 값이 1, 2, 3, 4, 5로 증가하면 정상입니다.</p>
</blockquote>
<hr>
<h2 id="5-4-드라이버와-모니터-기초">5.4 드라이버와 모니터 기초</h2>
<blockquote>
<p><strong>이 절의 목표</strong>: 드라이버(신호 구동)와 모니터(신호 관찰)의 역할을 이해하고, virtual interface를 사용하여 기본 동작을 구현합니다.</p>
</blockquote>
<h3 id="5-4-1-드라이버-신호를-보내는-역할">5.4.1 드라이버 = 신호를 보내는 역할</h3>
<p>드라이버는 테스트 시나리오에 따라 DUT의 입력 신호를 **구동(drive)**합니다:</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-keyword">class</span> counter_driver <span class="hljs-keyword">extends</span> uvm_component;
  `uvm_component_utils(counter_driver)

  <span class="hljs-keyword">virtual</span> counter_if vif;

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);
    <span class="hljs-keyword">if</span> (!uvm_config_db<span class="hljs-variable">#(virtual counter_if)::get(this, &quot;&quot;, &quot;vif&quot;, vif))</span>
      `uvm_fatal(get_type_name(), <span class="hljs-string">&quot;vif를 찾을 수 없습니다!&quot;</span>)
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-comment">// 리셋 태스크</span>
  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> reset_dut();
    vif<span class="hljs-variable">.rst_n</span>  = <span class="hljs-number">0</span>;
    vif<span class="hljs-variable">.enable</span> = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">repeat</span>(<span class="hljs-number">2</span>) @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>);
    vif<span class="hljs-variable">.rst_n</span>  = <span class="hljs-number">1</span>;
    @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>);
    `uvm_info(get_type_name(), <span class="hljs-string">&quot;DUT 리셋 완료&quot;</span>, UVM_MEDIUM)
  <span class="hljs-keyword">endtask</span>

  <span class="hljs-comment">// 카운트 활성화 태스크</span>
  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> drive_count(<span class="hljs-keyword">int</span> num_clocks);
    vif<span class="hljs-variable">.enable</span> = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">repeat</span>(num_clocks) @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>);
    vif<span class="hljs-variable">.enable</span> = <span class="hljs-number">0</span>;
    `uvm_info(get_type_name(),
      <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;%0d 클럭 동안 카운트 완료&quot;</span>, num_clocks), UVM_MEDIUM)
  <span class="hljs-keyword">endtask</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> run_phase(uvm_phase phase);
    phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);

    reset_dut();
    drive_count(<span class="hljs-number">10</span>);  <span class="hljs-comment">// 10클럭 동안 카운트</span>

    #<span class="hljs-number">20</span>;  <span class="hljs-comment">// 안정화 대기</span>
    phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>
</code></pre><blockquote>
<p><strong>실무 참고</strong>: 실제 프로젝트에서 드라이버는 Sequencer로부터 트랜잭션을 받아서 신호로 변환합니다 (Chapter 6-7에서 배움). 지금은 run_phase에서 직접 구동하는 단순한 형태입니다.</p>
</blockquote>
<h3 id="5-4-2-모니터-신호를-관찰하는-역할">5.4.2 모니터 = 신호를 관찰하는 역할</h3>
<p>모니터는 DUT의 출력 신호를 **관찰(monitor)**하고 기록합니다. 모니터는 신호를 바꾸지 않고 읽기만 합니다:</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-keyword">class</span> counter_monitor <span class="hljs-keyword">extends</span> uvm_component;
  `uvm_component_utils(counter_monitor)

  <span class="hljs-keyword">virtual</span> counter_if vif;

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);
    <span class="hljs-keyword">if</span> (!uvm_config_db<span class="hljs-variable">#(virtual counter_if)::get(this, &quot;&quot;, &quot;vif&quot;, vif))</span>
      `uvm_fatal(get_type_name(), <span class="hljs-string">&quot;vif를 찾을 수 없습니다!&quot;</span>)
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> run_phase(uvm_phase phase);
    <span class="hljs-comment">// 모니터는 objection을 raise하지 않음 (관찰자이므로)</span>
    <span class="hljs-keyword">forever</span> <span class="hljs-keyword">begin</span>
      @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>);
      <span class="hljs-keyword">if</span> (vif<span class="hljs-variable">.rst_n</span> &amp;&amp; vif<span class="hljs-variable">.enable</span>) <span class="hljs-keyword">begin</span>
        `uvm_info(get_type_name(),
          <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;[관찰] enable=%0b, count=%0d&quot;</span>,
                    vif<span class="hljs-variable">.enable</span>, vif<span class="hljs-variable">.count</span>), UVM_HIGH)
      <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>
</code></pre><blockquote>
<p><strong>핵심 차이</strong>:</p>
<table>
<thead>
<tr>
<th>항목</th>
<th>드라이버</th>
<th>모니터</th>
</tr>
</thead>
<tbody><tr>
<td>역할</td>
<td>DUT 입력 신호 구동</td>
<td>DUT 신호 관찰/기록</td>
</tr>
<tr>
<td>신호 접근</td>
<td>읽기 + 쓰기</td>
<td>읽기만</td>
</tr>
<tr>
<td>objection</td>
<td>raise/drop 함</td>
<td>하지 않음 (관찰자)</td>
</tr>
<tr>
<td>비유</td>
<td>실험자 (자극을 줌)</td>
<td>기록원 (결과를 적음)</td>
</tr>
</tbody></table>
</blockquote>
<h3 id="5-4-3-에이전트-드라이버-모니터-묶음">5.4.3 에이전트 = 드라이버 + 모니터 묶음</h3>
<p>Chapter 4에서 배운 것처럼, 에이전트는 드라이버와 모니터를 하나로 묶는 컨테이너입니다:</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-keyword">class</span> counter_agent <span class="hljs-keyword">extends</span> uvm_agent;
  `uvm_component_utils(counter_agent)

  counter_driver  drv;
  counter_monitor mon;

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);
    drv = counter_driver::type_id::create(<span class="hljs-string">&quot;drv&quot;</span>, <span class="hljs-keyword">this</span>);
    mon = counter_monitor::type_id::create(<span class="hljs-string">&quot;mon&quot;</span>, <span class="hljs-keyword">this</span>);
    `uvm_info(get_type_name(), <span class="hljs-string">&quot;에이전트: 드라이버 + 모니터 생성&quot;</span>, UVM_MEDIUM)
  <span class="hljs-keyword">endfunction</span>
<span class="hljs-keyword">endclass</span>
</code></pre><hr>
<h2 id="5-5-종합-첫-완전한-uvm-테스트벤치">5.5 종합: 첫 완전한 UVM 테스트벤치</h2>
<blockquote>
<p><strong>이 절의 목표</strong>: 지금까지 배운 모든 것을 합쳐서 DUT를 검증하는 완전한 UVM 테스트벤치를 만듭니다. Chapter 4의 뼈대에 virtual interface와 DUT를 연결합니다.</p>
</blockquote>
<h3 id="5-5-1-전체-구조-한눈에-보기">5.5.1 전체 구조 한눈에 보기</h3>
<p>Chapter 4에서 만든 뼈대에 두 가지가 추가됩니다:</p>
<ol>
<li><strong>Virtual interface</strong>: DUT와 UVM 클래스를 연결</li>
<li><strong>config_db</strong>: virtual interface를 컴포넌트에 전달</li>
</ol>

<div class="svg-diagram">
<svg viewBox="0 0 720 480" xmlns="http://www.w3.org/2000/svg" style="max-width:720px;width:100%">
  
  <style>
    .diagram-box { fill: #ffffff; stroke: #334155; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-accent { fill: #eff6ff; stroke: #2563eb; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-highlight { fill: #fef3c7; stroke: #f59e0b; stroke-width: 2.5; rx: 10; ry: 10; }
    .diagram-box-dark { fill: #1e293b; stroke: #1e293b; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-run { fill: #fef3c7; stroke: #f59e0b; stroke-width: 3; rx: 10; ry: 10; }
    .diagram-box-green { fill: #ecfdf5; stroke: #10b981; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-purple { fill: #f5f3ff; stroke: #7c3aed; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-red { fill: #fef2f2; stroke: #ef4444; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-gray { fill: #f8fafc; stroke: #94a3b8; stroke-width: 1.5; rx: 8; ry: 8; }
    .diagram-text { font-family: 'Noto Sans KR', sans-serif; fill: #1e293b; }
    .diagram-text-white { font-family: 'Noto Sans KR', sans-serif; fill: #ffffff; }
    .diagram-text-accent { font-family: 'Noto Sans KR', sans-serif; fill: #2563eb; }
    .diagram-text-small { font-family: 'Noto Sans KR', sans-serif; fill: #64748b; font-size: 12px; }
    .diagram-text-code { font-family: 'Fira Code', 'JetBrains Mono', monospace; fill: #1e293b; }
    .diagram-arrow { fill: none; stroke: #64748b; stroke-width: 1.5; }
    .diagram-arrow-accent { fill: none; stroke: #2563eb; stroke-width: 1.5; }
    .diagram-line { stroke: #cbd5e1; stroke-width: 1.5; stroke-dasharray: 6,3; }
  </style>
  <defs>
    <marker id="arrowhead" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#64748b" />
    </marker>
    <marker id="arrowhead-accent" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#2563eb" />
    </marker>
    <marker id="arrowhead-dark" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#1e293b" />
    </marker>
    <marker id="arrowhead-orange" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#f59e0b" />
    </marker>
    <filter id="shadow" x="-5%" y="-5%" width="115%" height="115%">
      <feDropShadow dx="0" dy="2" stdDeviation="3" flood-color="#000" flood-opacity="0.1"/>
    </filter>
  </defs>


  <!-- Top module outer box -->
  <rect x="10" y="10" width="700" height="460" rx="14" ry="14" fill="#f8fafc" stroke="#94a3b8" stroke-width="2"/>
  <text x="30" y="34" class="diagram-text" font-size="13" font-weight="bold" fill="#64748b">top 모듈</text>

  <!-- counter_test box -->
  <rect x="30" y="50" width="560" height="280" rx="12" ry="12" fill="#fef3c7" stroke="#f59e0b" stroke-width="2"/>
  <text x="50" y="74" class="diagram-text-code" font-size="12" font-weight="bold">counter_test (uvm_test)</text>

  <!-- counter_env box -->
  <rect x="50" y="88" width="520" height="228" rx="10" ry="10" fill="#eff6ff" stroke="#2563eb" stroke-width="1.5"/>
  <text x="70" y="110" class="diagram-text-code" font-size="11" font-weight="bold" fill="#2563eb">counter_env (uvm_env)</text>

  <!-- counter_agent box -->
  <rect x="70" y="122" width="480" height="180" rx="8" ry="8" fill="#ecfdf5" stroke="#10b981" stroke-width="1.5"/>
  <text x="90" y="142" class="diagram-text-code" font-size="11" font-weight="bold" fill="#10b981">counter_agent (uvm_agent)</text>

  <!-- counter_driver -->
  <rect x="95" y="158" width="200" height="60" class="diagram-box-green" filter="url(#shadow)"/>
  <text x="195" y="182" text-anchor="middle" class="diagram-text-code" font-size="12" font-weight="bold">counter_driver</text>
  <text x="195" y="204" text-anchor="middle" class="diagram-text-code" font-size="10" fill="#10b981">vif (write)</text>

  <!-- counter_monitor -->
  <rect x="325" y="158" width="200" height="60" class="diagram-box-purple" filter="url(#shadow)"/>
  <text x="425" y="182" text-anchor="middle" class="diagram-text-code" font-size="12" font-weight="bold">counter_monitor</text>
  <text x="425" y="204" text-anchor="middle" class="diagram-text-code" font-size="10" fill="#7c3aed">vif (read)</text>

  <!-- config_db arrow -->
  <rect x="95" y="240" width="430" height="28" rx="6" ry="6" fill="#dbeafe" stroke="#2563eb" stroke-width="1.5" stroke-dasharray="4,3"/>
  <text x="310" y="259" text-anchor="middle" class="diagram-text-code" font-size="10" fill="#2563eb">config_db (vif) 전달 경로</text>

  <!-- Dashed lines from driver/monitor to config_db bar -->
  <line x1="195" y1="218" x2="195" y2="240" stroke="#2563eb" stroke-width="1.5" stroke-dasharray="3,3"/>
  <line x1="425" y1="218" x2="425" y2="240" stroke="#2563eb" stroke-width="1.5" stroke-dasharray="3,3"/>

  <!-- Interface bar -->
  <rect x="140" y="350" width="440" height="40" class="diagram-box-accent" filter="url(#shadow)"/>
  <text x="360" y="375" text-anchor="middle" class="diagram-text-code" font-size="12" font-weight="bold">counter_if (Interface)</text>

  <!-- Config_db arrow from top to interface area -->
  <line x1="310" y1="268" x2="310" y2="350" stroke="#2563eb" stroke-width="1.5" marker-end="url(#arrowhead)" stroke-dasharray="6,3"/>
  <text x="330" y="315" class="diagram-text-small" font-size="9" fill="#2563eb">config_db</text>

  <!-- DUT box -->
  <rect x="200" y="410" width="320" height="44" class="diagram-box-gray" filter="url(#shadow)"/>
  <text x="360" y="437" text-anchor="middle" class="diagram-text-code" font-size="13" font-weight="bold">counter (DUT)</text>

  <!-- Arrow Interface to DUT -->
  <line x1="360" y1="390" x2="360" y2="410" stroke="#64748b" stroke-width="1.5" marker-end="url(#arrowhead)"/>

  <!-- config_db set source -->
  <rect x="610" y="120" width="80" height="60" rx="8" ry="8" fill="#fef3c7" stroke="#f59e0b" stroke-width="1.5"/>
  <text x="650" y="147" text-anchor="middle" class="diagram-text-code" font-size="10" font-weight="bold">set()</text>
  <text x="650" y="167" text-anchor="middle" class="diagram-text-small" font-size="9">top 모듈</text>

  <!-- Arrow from set() to config_db bar -->
  <path d="M 610 155 L 530 255" stroke="#f59e0b" stroke-width="1.5" fill="none" marker-end="url(#arrowhead)" stroke-dasharray="4,3"/>
</svg>
</div><h3 id="5-5-2-단계별-빌드업">5.5.2 단계별 빌드업</h3>
<p>이제 전체 코드를 단계별로 조립합니다. 각 단계에서 무엇을 하는지 확인하면서 따라오세요.</p>
<p><strong>[예제 5-2] 완전한 UVM 테스트벤치</strong></p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// 파일: testbench.sv (EDA Playground)</span>
<span class="hljs-comment">// [예제 5-2] 첫 완전한 UVM 테스트벤치</span>
<span class="hljs-comment">// 목적: DUT(4비트 카운터)를 UVM으로 검증하는 완전한 환경</span>
<span class="hljs-comment">// 시뮬레이터 설정: SystemVerilog, UVM 1.2</span>

<span class="hljs-meta">`<span class="hljs-keyword">include</span> &quot;uvm_macros.svh&quot;</span>
<span class="hljs-keyword">import</span> uvm_pkg::*;

<span class="hljs-comment">// ══════════════════════════════════════</span>
<span class="hljs-comment">// 1단계: DUT (검증 대상)</span>
<span class="hljs-comment">// ══════════════════════════════════════</span>
<span class="hljs-keyword">module</span> counter (
  <span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span>       clk,
  <span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span>       rst_n,
  <span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span>       enable,
  <span class="hljs-keyword">output</span> <span class="hljs-keyword">logic</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] count
);
  <span class="hljs-keyword">always_ff</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> rst_n) <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (!rst_n) count &lt;= <span class="hljs-number">4&#x27;b0</span>;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (enable) count &lt;= count + <span class="hljs-number">1</span>;
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>

<span class="hljs-comment">// ══════════════════════════════════════</span>
<span class="hljs-comment">// 2단계: Interface (DUT-TB 연결 통로)</span>
<span class="hljs-comment">// ══════════════════════════════════════</span>
<span class="hljs-keyword">interface</span> counter_if (<span class="hljs-keyword">input</span> <span class="hljs-keyword">logic</span> clk);
  <span class="hljs-keyword">logic</span>       rst_n;
  <span class="hljs-keyword">logic</span>       enable;
  <span class="hljs-keyword">logic</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] count;
<span class="hljs-keyword">endinterface</span>

<span class="hljs-comment">// ══════════════════════════════════════</span>
<span class="hljs-comment">// 3단계: 드라이버 (DUT 입력 신호 구동)</span>
<span class="hljs-comment">// ══════════════════════════════════════</span>
<span class="hljs-keyword">class</span> counter_driver <span class="hljs-keyword">extends</span> uvm_component;
  `uvm_component_utils(counter_driver)

  <span class="hljs-keyword">virtual</span> counter_if vif;

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);
    <span class="hljs-keyword">if</span> (!uvm_config_db<span class="hljs-variable">#(virtual counter_if)::get(this, &quot;&quot;, &quot;vif&quot;, vif))</span>
      `uvm_fatal(get_type_name(), <span class="hljs-string">&quot;vif를 찾을 수 없습니다!&quot;</span>)
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> reset_dut();
    vif<span class="hljs-variable">.rst_n</span>  = <span class="hljs-number">0</span>;
    vif<span class="hljs-variable">.enable</span> = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">repeat</span>(<span class="hljs-number">2</span>) @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>);
    vif<span class="hljs-variable">.rst_n</span>  = <span class="hljs-number">1</span>;
    @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>);
    `uvm_info(get_type_name(), <span class="hljs-string">&quot;리셋 완료&quot;</span>, UVM_MEDIUM)
  <span class="hljs-keyword">endtask</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> drive_count(<span class="hljs-keyword">int</span> num_clocks);
    vif<span class="hljs-variable">.enable</span> = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">repeat</span>(num_clocks) @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>);
    vif<span class="hljs-variable">.enable</span> = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">endtask</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> run_phase(uvm_phase phase);
    phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);

    <span class="hljs-comment">// 테스트 시나리오 1: 리셋 후 10클럭 카운트</span>
    reset_dut();
    `uvm_info(get_type_name(), <span class="hljs-string">&quot;=== 시나리오 1: 10클럭 카운트 ===&quot;</span>, UVM_MEDIUM)
    drive_count(<span class="hljs-number">10</span>);

    <span class="hljs-comment">// 테스트 시나리오 2: 카운트 멈추고 재개</span>
    `uvm_info(get_type_name(), <span class="hljs-string">&quot;=== 시나리오 2: 정지 후 재개 ===&quot;</span>, UVM_MEDIUM)
    <span class="hljs-keyword">repeat</span>(<span class="hljs-number">3</span>) @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>);  <span class="hljs-comment">// 3클럭 정지</span>
    drive_count(<span class="hljs-number">5</span>);                 <span class="hljs-comment">// 5클럭 추가 카운트</span>

    #<span class="hljs-number">20</span>;
    phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>

<span class="hljs-comment">// ══════════════════════════════════════</span>
<span class="hljs-comment">// 4단계: 모니터 (DUT 출력 관찰)</span>
<span class="hljs-comment">// ══════════════════════════════════════</span>
<span class="hljs-keyword">class</span> counter_monitor <span class="hljs-keyword">extends</span> uvm_component;
  `uvm_component_utils(counter_monitor)

  <span class="hljs-keyword">virtual</span> counter_if vif;
  <span class="hljs-keyword">int</span> expected_count;  <span class="hljs-comment">// 예상 카운트 값 (간단한 자체 검증용)</span>

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
    expected_count = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);
    <span class="hljs-keyword">if</span> (!uvm_config_db<span class="hljs-variable">#(virtual counter_if)::get(this, &quot;&quot;, &quot;vif&quot;, vif))</span>
      `uvm_fatal(get_type_name(), <span class="hljs-string">&quot;vif를 찾을 수 없습니다!&quot;</span>)
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> run_phase(uvm_phase phase);
    <span class="hljs-comment">// 리셋 해제 대기</span>
    @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.rst_n</span>);

    <span class="hljs-keyword">forever</span> <span class="hljs-keyword">begin</span>
      @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>);
      #<span class="hljs-number">1</span>;  <span class="hljs-comment">// 신호 안정화 대기 (Ch.7에서 clocking block으로 개선)</span>

      <span class="hljs-keyword">if</span> (!vif<span class="hljs-variable">.rst_n</span>) <span class="hljs-keyword">begin</span>
        expected_count = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vif<span class="hljs-variable">.enable</span>) <span class="hljs-keyword">begin</span>
        expected_count = (expected_count + <span class="hljs-number">1</span>) % <span class="hljs-number">16</span>;  <span class="hljs-comment">// 4비트 오버플로</span>

        <span class="hljs-comment">// 간단한 자체 검증</span>
        <span class="hljs-keyword">if</span> (vif<span class="hljs-variable">.count</span> !== expected_count) <span class="hljs-keyword">begin</span>
          `uvm_error(get_type_name(),
            <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;불일치! 예상=%0d, 실제=%0d&quot;</span>,
                      expected_count, vif<span class="hljs-variable">.count</span>))
        <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
          `uvm_info(get_type_name(),
            <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;일치: count=%0d&quot;</span>, vif<span class="hljs-variable">.count</span>), UVM_HIGH)
        <span class="hljs-keyword">end</span>
      <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>

<span class="hljs-comment">// ══════════════════════════════════════</span>
<span class="hljs-comment">// 5단계: 에이전트 (드라이버 + 모니터)</span>
<span class="hljs-comment">// ══════════════════════════════════════</span>
<span class="hljs-keyword">class</span> counter_agent <span class="hljs-keyword">extends</span> uvm_agent;
  `uvm_component_utils(counter_agent)

  counter_driver  drv;
  counter_monitor mon;

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);
    drv = counter_driver::type_id::create(<span class="hljs-string">&quot;drv&quot;</span>, <span class="hljs-keyword">this</span>);
    mon = counter_monitor::type_id::create(<span class="hljs-string">&quot;mon&quot;</span>, <span class="hljs-keyword">this</span>);
  <span class="hljs-keyword">endfunction</span>
<span class="hljs-keyword">endclass</span>

<span class="hljs-comment">// ══════════════════════════════════════</span>
<span class="hljs-comment">// 6단계: 환경 (에이전트 컨테이너)</span>
<span class="hljs-comment">// ══════════════════════════════════════</span>
<span class="hljs-keyword">class</span> counter_env <span class="hljs-keyword">extends</span> uvm_env;
  `uvm_component_utils(counter_env)

  counter_agent agent;

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);
    agent = counter_agent::type_id::create(<span class="hljs-string">&quot;agent&quot;</span>, <span class="hljs-keyword">this</span>);
  <span class="hljs-keyword">endfunction</span>
<span class="hljs-keyword">endclass</span>

<span class="hljs-comment">// ══════════════════════════════════════</span>
<span class="hljs-comment">// 7단계: 테스트 (최상위 — 시나리오 정의)</span>
<span class="hljs-comment">// ══════════════════════════════════════</span>
<span class="hljs-keyword">class</span> counter_test <span class="hljs-keyword">extends</span> uvm_test;
  `uvm_component_utils(counter_test)

  counter_env env;

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);
    env = counter_env::type_id::create(<span class="hljs-string">&quot;env&quot;</span>, <span class="hljs-keyword">this</span>);
    `uvm_info(get_type_name(), <span class="hljs-string">&quot;=== 카운터 검증 테스트 시작 ===&quot;</span>, UVM_MEDIUM)
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> report_phase(uvm_phase phase);
    uvm_report_server svr = uvm_report_server::get_server();
    <span class="hljs-keyword">if</span> (svr<span class="hljs-variable">.get_severity_count</span>(UVM_ERROR) == <span class="hljs-number">0</span>)
      `uvm_info(get_type_name(), <span class="hljs-string">&quot;=== 테스트 통과! (PASS) ===&quot;</span>, UVM_NONE)
    <span class="hljs-keyword">else</span>
      `uvm_error(get_type_name(), <span class="hljs-string">&quot;=== 테스트 실패! (FAIL) ===&quot;</span>)
  <span class="hljs-keyword">endfunction</span>
<span class="hljs-keyword">endclass</span>

<span class="hljs-comment">// ══════════════════════════════════════</span>
<span class="hljs-comment">// 8단계: Top 모듈 (DUT + Interface + UVM 연결)</span>
<span class="hljs-comment">// ══════════════════════════════════════</span>
<span class="hljs-keyword">module</span> top;
  <span class="hljs-keyword">logic</span> clk;

  <span class="hljs-comment">// 클럭 생성: 10ns 주기 (100MHz)</span>
  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span>
    clk = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">forever</span> #<span class="hljs-number">5</span> clk = ~clk;
  <span class="hljs-keyword">end</span>

  <span class="hljs-comment">// Interface 인스턴스</span>
  counter_if vif(clk);

  <span class="hljs-comment">// DUT 연결</span>
  counter dut (
    <span class="hljs-variable">.clk</span>    (clk),
    <span class="hljs-variable">.rst_n</span>  (vif<span class="hljs-variable">.rst_n</span>),
    <span class="hljs-variable">.enable</span> (vif<span class="hljs-variable">.enable</span>),
    <span class="hljs-variable">.count</span>  (vif<span class="hljs-variable">.count</span>)
  );

  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span>
    <span class="hljs-comment">// config_db에 virtual interface 저장</span>
    uvm_config_db<span class="hljs-variable">#(virtual counter_if)::set(null, &quot;*&quot;, &quot;vif&quot;, vif)</span>;
    run_test(<span class="hljs-string">&quot;counter_test&quot;</span>);
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</code></pre><p><strong>예상 출력</strong>:</p>
<pre><code>UVM_INFO @ 0: uvm_test_top [counter_test] === 카운터 검증 테스트 시작 ===
UVM_INFO @ 25: uvm_test_top.env.agent.drv [counter_driver] 리셋 완료
UVM_INFO @ 25: uvm_test_top.env.agent.drv [counter_driver] === 시나리오 1: 10클럭 카운트 ===
UVM_INFO @ 125: uvm_test_top.env.agent.drv [counter_driver] === 시나리오 2: 정지 후 재개 ===
UVM_INFO @ 0: uvm_test_top [counter_test] === 테스트 통과! (PASS) ===
</code></pre><blockquote>
<p><strong>관찰 포인트</strong>:</p>
<ol>
<li>컴포넌트 경로: <code>uvm_test_top.env.agent.drv</code> — Chapter 4에서 배운 트리 구조!</li>
<li>모니터가 에러를 보고하지 않았으므로 &quot;테스트 통과&quot; 출력</li>
<li>시나리오 1(10클럭)과 시나리오 2(정지+재개)가 순서대로 실행됨</li>
</ol>
</blockquote>
<h3 id="5-5-3-코드-구조-정리">5.5.3 코드 구조 정리</h3>
<p>전체 코드의 빌드업 구조를 다시 정리합니다:</p>
<pre><code>파일: testbench.sv

1. DUT (counter)           — 검증할 대상
2. Interface (counter_if)  — DUT-TB 연결 통로
3. Driver (counter_driver) — DUT 입력 신호 구동
4. Monitor (counter_monitor) — DUT 출력 관찰+검증
5. Agent (counter_agent)   — 드라이버 + 모니터
6. Env (counter_env)       — 에이전트 컨테이너
7. Test (counter_test)     — 테스트 시나리오 정의
8. Top (module top)        — 모든 것을 연결

계층 구조:
top
 ├── vif (counter_if)
 ├── dut (counter)
 └── counter_test (UVM)
      └── env
           └── agent
                ├── drv  ──→ vif (config_db로 받음)
                └── mon  ──→ vif (config_db로 받음)
</code></pre><blockquote>
<p><strong>성취감 포인트</strong>: 지금 만든 테스트벤치는 실무에서 사용하는 UVM 테스트벤치와 <strong>동일한 구조</strong>입니다! 실무에서는 여기에 Sequence(Ch.6), TLM 포트(Ch.7), Scoreboard(Ch.8)가 추가되지만, 뼈대는 지금과 같습니다.</p>
</blockquote>
<blockquote>
<p><strong>면접 빈출</strong>: &quot;UVM 테스트벤치의 전체 구조를 설명하세요&quot;라는 질문에 &quot;test → env → agent → driver/monitor 계층 구조이며, virtual interface를 config_db로 전달하여 DUT와 연결한다&quot;고 답하면 됩니다.</p>
</blockquote>
<hr>
<h2 id="5-6-체크포인트">5.6 체크포인트</h2>
<h3 id="셀프-체크">셀프 체크</h3>
<p>아래 질문에 답할 수 있다면 이 챕터를 충분히 이해한 것입니다:</p>
<ol>
<li>Virtual interface가 필요한 이유는?</li>
</ol>
<details>
<summary>정답 확인</summary>

<p>UVM의 드라이버/모니터는 class이고, DUT의 신호는 module/interface 영역에 있습니다. SystemVerilog에서 class는 module의 신호를 직접 참조할 수 없으므로, interface에 대한 참조(핸들)인 virtual interface를 사용하여 class에서 DUT 신호에 접근합니다.</p>
</details>

<ol start="2">
<li><code>uvm_config_db</code>의 <code>set()</code>과 <code>get()</code>에서 반드시 같아야 하는 것 2가지는?</li>
</ol>
<details>
<summary>정답 확인</summary>

<p>(1) <strong>타입</strong>: <code>uvm_config_db#(virtual counter_if)</code> — set과 get의 # 안에 있는 타입이 동일해야 합니다.
(2) <strong>이름</strong>: set에서 <code>&quot;vif&quot;</code>로 저장했으면 get에서도 <code>&quot;vif&quot;</code>로 찾아야 합니다.</p>
</details>

<ol start="3">
<li>드라이버와 모니터의 역할 차이는?</li>
</ol>
<details>
<summary>정답 확인</summary>

<p>드라이버는 DUT의 입력 신호를 구동(write)하는 역할이고, 모니터는 DUT의 신호를 관찰(read only)하는 역할입니다. 드라이버는 run_phase에서 objection을 raise/drop하지만, 모니터는 관찰자이므로 objection을 raise하지 않습니다.</p>
</details>

<ol start="4">
<li>config_db의 get()이 실패하면 확인해야 할 3가지는?</li>
</ol>
<details>
<summary>정답 확인</summary>

<p>(1) top 모듈에서 <code>set()</code>을 호출했는가?
(2) set()과 get()의 <strong>이름</strong>(&quot;vif&quot;)이 동일한가?
(3) set()과 get()의 <strong>타입</strong>(virtual counter_if)이 동일한가?</p>
</details>

<ol start="5">
<li>top 모듈에서 config_db::set()을 run_test() 이전에 호출해야 하는 이유는?</li>
</ol>
<details>
<summary>정답 확인</summary>

<p>run_test()가 UVM 테스트를 시작하면 build_phase가 실행되고, 드라이버/모니터의 build_phase에서 config_db::get()을 호출합니다. set()이 run_test() 이후에 호출되면 get() 시점에 아직 값이 저장되지 않아서 실패합니다.</p>
</details>

<ol start="6">
<li>UVM 테스트벤치의 계층 구조를 위에서 아래 순서로 나열하면?</li>
</ol>
<details>
<summary>정답 확인</summary>

<p>test → env → agent → driver / monitor</p>
<ul>
<li>test: 테스트 시나리오 정의, 환경 생성</li>
<li>env: 에이전트(들)를 담는 컨테이너</li>
<li>agent: 드라이버 + 모니터를 묶는 단위</li>
<li>driver: DUT 입력 신호 구동</li>
<li>monitor: DUT 신호 관찰</details></li>
</ul>
<h3 id="연습문제">연습문제</h3>
<p><strong>[실습 5-1] 리셋 검증 추가 (쉬움)</strong> — 약 10분</p>
<p>[예제 5-2]의 counter_driver에 리셋 중 카운트가 0인지 확인하는 시나리오를 추가하세요. 리셋 활성화 후 count가 0인지 모니터에서 검증합니다.</p>
<details>
<summary>힌트</summary>

<p>드라이버의 run_phase에서 <code>reset_dut()</code> 호출 직후, <code>vif.count</code>가 0인지 확인하는 <code>uvm_info</code> 또는 assertion을 추가하세요.</p>
</details>

<details>
<summary>모범 답안</summary>

<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// counter_driver의 run_phase에 추가:</span>
<span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> run_phase(uvm_phase phase);
  phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);

  <span class="hljs-comment">// 시나리오 0: 리셋 검증</span>
  `uvm_info(get_type_name(), <span class="hljs-string">&quot;=== 시나리오 0: 리셋 검증 ===&quot;</span>, UVM_MEDIUM)
  reset_dut();
  @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>);
  #<span class="hljs-number">1</span>;
  <span class="hljs-keyword">if</span> (vif<span class="hljs-variable">.count</span> !== <span class="hljs-number">4&#x27;b0</span>)
    `uvm_error(get_type_name(),
      <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;리셋 실패! count=%0d (예상: 0)&quot;</span>, vif<span class="hljs-variable">.count</span>))
  <span class="hljs-keyword">else</span>
    `uvm_info(get_type_name(), <span class="hljs-string">&quot;리셋 검증 통과: count=0&quot;</span>, UVM_MEDIUM)

  <span class="hljs-comment">// 기존 시나리오 계속...</span>
  drive_count(<span class="hljs-number">10</span>);
  <span class="hljs-comment">// ...</span>

  phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);
<span class="hljs-keyword">endtask</span>
</code></pre></details>

<p><strong>[실습 5-2] 오버플로 검증 (보통)</strong> — 약 15분</p>
<p>4비트 카운터는 15(4&#39;hF) 이후 0으로 돌아와야 합니다. 드라이버에서 20클럭 동안 카운트한 후, 모니터에서 오버플로(15→0 전환)가 정상적으로 발생하는지 검증하세요.</p>
<details>
<summary>힌트</summary>

<p>모니터의 run_phase에서 <code>expected_count</code>가 이미 모듈로 16 연산을 하고 있으므로, 드라이버에서 <code>drive_count(20)</code>을 호출하면 자연스럽게 오버플로 검증이 됩니다. 추가로, 오버플로 시점을 명시적으로 로그에 남겨보세요.</p>
</details>

<details>
<summary>모범 답안</summary>

<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// counter_monitor의 run_phase를 수정하여 오버플로 감지:</span>
<span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> run_phase(uvm_phase phase);
  @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.rst_n</span>);
  <span class="hljs-keyword">forever</span> <span class="hljs-keyword">begin</span>
    @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>);
    #<span class="hljs-number">1</span>;
    <span class="hljs-keyword">if</span> (!vif<span class="hljs-variable">.rst_n</span>) <span class="hljs-keyword">begin</span>
      expected_count = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vif<span class="hljs-variable">.enable</span>) <span class="hljs-keyword">begin</span>
      <span class="hljs-keyword">int</span> prev_count = expected_count;
      expected_count = (expected_count + <span class="hljs-number">1</span>) % <span class="hljs-number">16</span>;

      <span class="hljs-comment">// 오버플로 감지</span>
      <span class="hljs-keyword">if</span> (prev_count == <span class="hljs-number">15</span> &amp;&amp; expected_count == <span class="hljs-number">0</span>)
        `uvm_info(get_type_name(),
          <span class="hljs-string">&quot;오버플로 감지! 15 → 0 전환 정상&quot;</span>, UVM_MEDIUM)

      <span class="hljs-keyword">if</span> (vif<span class="hljs-variable">.count</span> !== expected_count)
        `uvm_error(get_type_name(),
          <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;불일치! 예상=%0d, 실제=%0d&quot;</span>,
                    expected_count, vif<span class="hljs-variable">.count</span>))
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endtask</span>

<span class="hljs-comment">// counter_driver의 run_phase에 추가:</span>
<span class="hljs-comment">// 시나리오 3: 오버플로 검증</span>
`uvm_info(get_type_name(), <span class="hljs-string">&quot;=== 시나리오 3: 오버플로 검증 ===&quot;</span>, UVM_MEDIUM)
reset_dut();
drive_count(<span class="hljs-number">20</span>);  <span class="hljs-comment">// 20클럭: 0→1→...→15→0→1→2→3</span>
</code></pre></details>

<p><strong>[실습 5-3] 환경에 두 번째 에이전트 추가 (도전)</strong> — 약 20분</p>
<p><code>counter_env</code>에 두 번째 에이전트(<code>counter_agent agent2</code>)를 추가하세요. 두 에이전트 모두 동일한 virtual interface를 공유하고, 각각 다른 테스트 시나리오를 실행합니다. 컴포넌트 트리(<code>print_topology()</code>)에서 agent2가 보이는지 확인하세요.</p>
<details>
<summary>힌트</summary>

<p><code>counter_env</code>의 build_phase에서 <code>agent2 = counter_agent::type_id::create(&quot;agent2&quot;, this);</code>를 추가합니다. 두 에이전트의 드라이버가 동시에 같은 신호를 구동하면 충돌하므로, agent2의 드라이버는 신호를 구동하지 않고 모니터만 동작하도록 합니다.</p>
</details>

<details>
<summary>모범 답안</summary>

<pre><code class="hljs language-systemverilog"><span class="hljs-keyword">class</span> counter_env <span class="hljs-keyword">extends</span> uvm_env;
  `uvm_component_utils(counter_env)

  counter_agent agent;
  counter_agent agent2;  <span class="hljs-comment">// 추가!</span>

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);
    agent  = counter_agent::type_id::create(<span class="hljs-string">&quot;agent&quot;</span>, <span class="hljs-keyword">this</span>);
    agent2 = counter_agent::type_id::create(<span class="hljs-string">&quot;agent2&quot;</span>, <span class="hljs-keyword">this</span>);
  <span class="hljs-keyword">endfunction</span>
<span class="hljs-keyword">endclass</span>

<span class="hljs-comment">// 주의: agent2의 드라이버가 신호를 구동하면 agent1과 충돌합니다.</span>
<span class="hljs-comment">// 실무에서는 agent의 is_active 플래그를 사용하여 드라이버를</span>
<span class="hljs-comment">// 비활성화합니다 (Chapter 7에서 배울 예정).</span>
</code></pre></details>

<h3 id="흔한-에러와-해결법">흔한 에러와 해결법</h3>
<table>
<thead>
<tr>
<th>에러 메시지</th>
<th>원인</th>
<th>해결</th>
</tr>
</thead>
<tbody><tr>
<td><code>UVM_FATAL ... vif를 찾을 수 없습니다</code></td>
<td>config_db set() 누락 또는 이름 불일치</td>
<td>top 모듈의 set()과 get()의 이름/타입 확인</td>
</tr>
<tr>
<td><code>Bad handle or reference (SIGSEGV)</code></td>
<td>virtual interface가 null (연결 안 됨)</td>
<td>build_phase에서 config_db get() 확인</td>
</tr>
<tr>
<td>카운터 값이 증가하지 않음</td>
<td>enable 신호를 구동하지 않음</td>
<td>드라이버에서 <code>vif.enable = 1</code> 확인</td>
</tr>
<tr>
<td>모니터에서 불일치 에러</td>
<td>리셋 타이밍 문제 또는 <code>#1</code> 안정화 대기 누락</td>
<td>모니터에서 <code>#1</code> 추가, 리셋 후 대기 확인</td>
</tr>
<tr>
<td>config_db set() 후에도 get() 실패</td>
<td>set()이 run_test() 이후에 호출됨</td>
<td>set()을 run_test() 이전에 호출</td>
</tr>
</tbody></table>
<h3 id="용어-정리">용어 정리</h3>
<table>
<thead>
<tr>
<th>한글 용어</th>
<th>영어</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>가상 인터페이스</td>
<td>Virtual Interface</td>
<td>class에서 module의 interface에 접근하기 위한 참조(핸들)</td>
</tr>
<tr>
<td>설정 데이터베이스</td>
<td>config_db</td>
<td>UVM 컴포넌트 간 설정값을 전달하는 글로벌 저장소</td>
</tr>
<tr>
<td>드라이버</td>
<td>Driver</td>
<td>DUT의 입력 신호를 구동하는 컴포넌트</td>
</tr>
<tr>
<td>모니터</td>
<td>Monitor</td>
<td>DUT의 신호를 관찰하고 기록하는 컴포넌트</td>
</tr>
<tr>
<td>에이전트</td>
<td>Agent</td>
<td>드라이버 + 모니터를 묶는 컨테이너 컴포넌트</td>
</tr>
<tr>
<td>환경</td>
<td>Environment (Env)</td>
<td>에이전트(들)를 담는 최상위 검증 환경</td>
</tr>
<tr>
<td>클럭킹 블록</td>
<td>Clocking Block</td>
<td>타이밍 안정성을 위한 SystemVerilog 구문</td>
</tr>
</tbody></table>
<h3 id="다음-챕터-미리보기">다음 챕터 미리보기</h3>
<blockquote>
<p>Chapter 6에서는 다음 내용을 학습합니다:</p>
<ul>
<li><code>uvm_sequence</code>와 <code>uvm_sequencer</code>로 테스트 시나리오를 체계적으로 생성</li>
<li><code>uvm_sequence_item</code>(트랜잭션)을 정의하고 시퀀스에서 사용</li>
<li>드라이버가 시퀀서로부터 트랜잭션을 받아 처리하는 메커니즘</li>
<li>run_phase의 하드코딩된 구동을 시퀀스 기반으로 리팩토링</li>
</ul>
<p>이 챕터에서 만든 counter 테스트벤치가 Chapter 6의 기반입니다!</p>
</blockquote>

    <nav class="chapter-nav"><a href="chapter-04-final.html" class="nav-prev">
      <span class="nav-label">이전 챕터</span>
      <span class="nav-title">Ch.4 UVM 기본 컴포넌트</span>
    </a><a href="chapter-06-final.html" class="nav-next">
      <span class="nav-label">다음 챕터</span>
      <span class="nav-title">Ch.6 시퀀스 & 시퀀서</span>
    </a></nav>
  </div>

  <footer class="book-footer">
    <p>팹리스 검증 엔지니어가 되기 위한 UVM 완전정복</p>
    <p>Published by UVM Book Publisher Agent</p>
  </footer>

  <!-- Back to Top Button -->
  <button class="back-to-top" id="backToTop" onclick="window.scrollTo({top:0,behavior:'smooth'})">↑</button>

  <script>
    // Reading progress bar
    window.addEventListener('scroll', () => {
      const h = document.documentElement;
      const pct = (h.scrollTop / (h.scrollHeight - h.clientHeight)) * 100;
      document.getElementById('progressBar').style.width = pct + '%';
      document.getElementById('backToTop').classList.toggle('visible', h.scrollTop > 400);
    });

    // Language labels for code blocks
    document.querySelectorAll('pre').forEach(pre => {
      const code = pre.querySelector('code');
      if (code) {
        const cls = code.className || '';
        const m = cls.match(/language-(\w+)/);
        if (m) {
          const map = {
            systemverilog:'SystemVerilog', sv:'SystemVerilog', verilog:'Verilog',
            bash:'Bash', shell:'Shell', tcl:'TCL', makefile:'Makefile',
            python:'Python', javascript:'JavaScript', text:'Output'
          };
          pre.setAttribute('data-lang', map[m[1]] || m[1]);
        }
      }
    });

    // Smart labels for plain code blocks
    document.querySelectorAll('pre code:not([class*="language-"])').forEach(code => {
      const pre = code.parentElement;
      if (!pre.getAttribute('data-lang')) {
        const t = code.textContent || '';
        if (t.includes('UVM_INFO') || t.includes('UVM_WARNING')) {
          pre.setAttribute('data-lang', 'Simulation Output');
        } else if (t.includes('[채용') || t.includes('필수 자격')) {
          pre.setAttribute('data-lang', '');
        } else if (t.includes('Step') || t.includes('패널') || t.includes('편집기')) {
          pre.setAttribute('data-lang', 'Setup Guide');
        } else {
          pre.setAttribute('data-lang', 'Info');
        }
      }
    });

    // Smooth scroll for TOC links
    document.querySelectorAll('.toc a').forEach(a => {
      a.addEventListener('click', e => {
        e.preventDefault();
        const id = a.getAttribute('href').slice(1);
        const target = document.getElementById(id);
        if (target) target.scrollIntoView({ behavior: 'smooth', block: 'start' });
      });
    });
  </script>
</body>
</html>