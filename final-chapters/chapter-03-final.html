<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chapter 3: SystemVerilog 핵심 | 팹리스 검증 엔지니어가 되기 위한 UVM 완전정복</title>
  <style>
    /* =============================================
       UVM Book Publisher - Stylesheet
       Generated by Publisher Agent
       ============================================= */

    @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;600;700&display=swap');

    :root {
      --bg: #ffffff;
      --text: #1a1a2e;
      --accent: #2563eb;
      --accent-light: #2563eb18;
      --code-bg: #1e1e2e;
      --code-text: #cdd6f4;
      --border: #e2e8f0;
      --blockquote-bg: #f0f9ff;
      --blockquote-border: #3b82f6;
      --table-header: #1e293b;
      --table-stripe: #f8fafc;
      --warning-bg: #fef3c7;
      --warning-border: #f59e0b;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: 'Noto Sans KR', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      line-height: 1.85;
      color: var(--text);
      background: var(--bg);
      font-size: 16px;
    }

    /* === Reading Progress Bar === */
    .progress-bar {
      position: fixed;
      top: 0;
      left: 0;
      width: 0%;
      height: 3px;
      background: linear-gradient(90deg, var(--accent), #2563ebcc);
      z-index: 9999;
      transition: width 0.1s;
    }

    /* === Cover Header === */
    .cover-header {
      background: linear-gradient(135deg, #2563eb08, #2563eb15);
      border-bottom: 3px solid var(--accent);
      padding: 32px 24px 24px;
      text-align: center;
      margin-bottom: 0;
    }
    .cover-part {
      display: inline-block;
      background: var(--accent);
      color: white;
      padding: 4px 16px;
      border-radius: 20px;
      font-size: 0.85em;
      font-weight: 600;
      letter-spacing: 0.5px;
      margin-bottom: 12px;
    }
    .cover-chapter-num {
      font-size: 2em;
      font-weight: 300;
      color: var(--accent);
      letter-spacing: 2px;
      opacity: 0.6;
    }

    /* === Main Content === */
    .content {
      max-width: 860px;
      margin: 0 auto;
      padding: 32px 24px 60px;
    }

    /* === TOC === */
    .toc {
      background: #f8fafc;
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 20px 28px;
      margin: 24px 0 32px;
    }
    .toc-title {
      font-size: 1.1em;
      color: var(--accent);
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 2px solid var(--border);
    }
    .toc ul { list-style: none; padding: 0; }
    .toc li { margin: 6px 0; }
    .toc li a {
      color: var(--text);
      text-decoration: none;
      font-weight: 500;
      font-size: 0.95em;
      padding: 4px 8px;
      border-radius: 4px;
      display: inline-block;
      transition: background 0.15s;
    }
    .toc li a:hover {
      background: var(--accent-light);
      color: var(--accent);
    }
    .toc li.toc-sub { padding-left: 24px; }
    .toc li.toc-sub a {
      font-weight: 400;
      font-size: 0.9em;
      color: #475569;
    }

    /* === Headings === */
    h1 {
      font-size: 2em;
      border-bottom: 3px solid var(--accent);
      padding-bottom: 12px;
      margin: 40px 0 20px;
      color: var(--text);
    }
    h1:first-child { margin-top: 0; }
    h2 {
      font-size: 1.5em;
      color: var(--accent);
      margin: 40px 0 16px;
      padding-bottom: 8px;
      border-bottom: 2px solid var(--border);
      scroll-margin-top: 16px;
    }
    h3 {
      font-size: 1.25em;
      margin: 28px 0 12px;
      color: #334155;
      scroll-margin-top: 16px;
    }
    h4 { font-size: 1.05em; margin: 20px 0 8px; color: #475569; }
    p { margin: 12px 0; }
    a { color: var(--accent); text-decoration: none; }
    a:hover { text-decoration: underline; }
    hr { border: none; border-top: 2px solid var(--border); margin: 32px 0; }
    strong { color: #1e293b; }
    img { max-width: 100%; border-radius: 8px; margin: 16px 0; }

    /* === Code Blocks === */
    pre {
      position: relative;
      background: var(--code-bg);
      border-radius: 12px;
      padding: 0;
      margin: 20px 0;
      overflow: hidden;
      box-shadow: 0 4px 16px rgba(0,0,0,0.12), 0 1px 4px rgba(0,0,0,0.08);
      border: 1px solid #313244;
    }
    pre::before {
      content: attr(data-lang);
      display: block;
      background: #313244;
      color: #a6adc8;
      padding: 8px 16px;
      font-size: 0.8em;
      font-family: 'Fira Code','JetBrains Mono',monospace;
      letter-spacing: 0.5px;
      border-bottom: 1px solid #45475a;
    }
    pre code {
      display: block;
      padding: 16px 20px;
      overflow-x: auto;
      font-family: 'Fira Code','JetBrains Mono','Cascadia Code','D2Coding',monospace;
      font-size: 0.88em;
      line-height: 1.75;
      tab-size: 4;
      color: var(--code-text);
    }
    pre code::-webkit-scrollbar { height: 6px; }
    pre code::-webkit-scrollbar-track { background: #1e1e2e; }
    pre code::-webkit-scrollbar-thumb { background: #45475a; border-radius: 3px; }

    code:not(pre code) {
      background: #f1f5f9;
      color: #be185d;
      padding: 2px 7px;
      border-radius: 5px;
      font-family: 'Fira Code','JetBrains Mono','D2Coding',monospace;
      font-size: 0.86em;
      border: 1px solid #e2e8f0;
    }

    /* Highlight.js Catppuccin */
    .hljs { background: transparent; color: #cdd6f4; }
    .hljs-keyword { color: #cba6f7; font-weight: bold; }
    .hljs-type { color: #f9e2af; }
    .hljs-string { color: #a6e3a1; }
    .hljs-number { color: #fab387; }
    .hljs-comment { color: #6c7086; font-style: italic; }
    .hljs-function, .hljs-title { color: #89b4fa; }
    .hljs-built_in { color: #f38ba8; }
    .hljs-variable { color: #cdd6f4; }
    .hljs-attr { color: #89dceb; }
    .hljs-meta { color: #f5c2e7; }
    .hljs-literal { color: #fab387; }

    /* === SVG Diagrams === */
    .svg-diagram {
      margin: 24px 0;
      padding: 20px;
      background: #fafbfc;
      border: 1px solid var(--border);
      border-radius: 12px;
      text-align: center;
      overflow-x: auto;
    }
    .svg-diagram svg { display: inline-block; }

    /* === Blockquotes === */
    blockquote {
      background: var(--blockquote-bg);
      border-left: 4px solid var(--blockquote-border);
      padding: 16px 20px;
      margin: 16px 0;
      border-radius: 0 8px 8px 0;
    }
    blockquote p:first-child { margin-top: 0; }
    blockquote p:last-child { margin-bottom: 0; }
    blockquote:has(strong:first-child) {
      background: var(--warning-bg);
      border-left-color: var(--warning-border);
    }

    /* === Tables === */
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 1px 4px rgba(0,0,0,0.06);
      border: 1px solid var(--border);
      font-size: 0.95em;
    }
    thead th {
      background: var(--table-header);
      color: white;
      padding: 12px 16px;
      text-align: left;
      font-weight: 600;
      font-size: 0.9em;
    }
    tbody td {
      padding: 10px 16px;
      border-bottom: 1px solid var(--border);
    }
    tbody tr:nth-child(even) { background: var(--table-stripe); }
    tbody tr:hover { background: var(--accent-light); }

    /* === Lists === */
    ul, ol { padding-left: 28px; margin: 12px 0; }
    li { margin: 6px 0; }
    li > ul, li > ol { margin: 4px 0; }

    /* === Details/Summary === */
    details {
      background: #f8fafc;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px 16px;
      margin: 12px 0;
    }
    details summary {
      cursor: pointer;
      font-weight: 600;
      color: var(--accent);
    }
    details[open] summary { margin-bottom: 8px; }

    /* === Plain code blocks === */
    pre:has(code:not(.hljs)) {
      background: #fafbfc;
      border: 2px solid var(--border);
      box-shadow: none;
    }
    pre:has(code:not(.hljs))::before {
      background: #f1f5f9;
      color: #64748b;
      border-bottom-color: var(--border);
    }
    pre:has(code:not(.hljs)) code { color: #334155; }

    /* === Chapter Navigation === */
    .chapter-nav {
      display: flex;
      justify-content: space-between;
      gap: 16px;
      margin: 40px 0 20px;
      padding-top: 24px;
      border-top: 2px solid var(--border);
    }
    .chapter-nav a {
      display: flex;
      flex-direction: column;
      padding: 14px 20px;
      border: 1px solid var(--border);
      border-radius: 10px;
      text-decoration: none;
      transition: all 0.2s;
      min-width: 200px;
    }
    .chapter-nav a:hover {
      border-color: var(--accent);
      background: var(--accent-light);
      text-decoration: none;
    }
    .nav-prev { align-items: flex-start; }
    .nav-next { align-items: flex-end; }
    .nav-label {
      font-size: 0.8em;
      color: #94a3b8;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .nav-title { font-weight: 600; color: var(--accent); margin-top: 2px; }

    /* === Footer === */
    .book-footer {
      text-align: center;
      padding: 20px;
      margin-top: 40px;
      border-top: 1px solid var(--border);
      color: #94a3b8;
      font-size: 0.85em;
    }

    /* === Back to Top === */
    .back-to-top {
      position: fixed;
      bottom: 24px;
      right: 24px;
      width: 44px;
      height: 44px;
      background: var(--accent);
      color: white;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      font-size: 20px;
      display: none;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      transition: opacity 0.3s;
      z-index: 100;
    }
    .back-to-top.visible { display: flex; }

    /* === Print === */
    @media print {
      .progress-bar, .back-to-top, .chapter-nav, .toc { display: none !important; }
      body { font-size: 11pt; }
      .content { max-width: 100%; padding: 0; }
      .cover-header { break-after: page; }
      pre { box-shadow: none; border: 2px solid #ccc; break-inside: avoid; }
      .svg-diagram { break-inside: avoid; border: 1px solid #ccc; }
      table { break-inside: avoid; }
      h2, h3 { break-after: avoid; }
    }

    /* === Responsive === */
    @media (max-width: 640px) {
      .content { padding: 16px 12px 40px; font-size: 15px; }
      h1 { font-size: 1.5em; }
      h2 { font-size: 1.25em; }
      pre code { font-size: 0.8em; padding: 12px; }
      thead th, tbody td { padding: 8px 10px; font-size: 0.88em; }
      .svg-diagram { padding: 10px; }
      .toc { padding: 14px 18px; }
      .chapter-nav { flex-direction: column; }
      .chapter-nav a { min-width: unset; }
      .nav-next { align-items: flex-start; }
      .cover-chapter-num { font-size: 1.5em; }
    }
  </style>
</head>
<body>
  <!-- Reading Progress Bar -->
  <div class="progress-bar" id="progressBar"></div>

  
<header class="cover-header">
  <div class="cover-part" style="--part-color: #2563eb">
    <span class="cover-part-label">Part 1: 시작하기</span>
  </div>
  <div class="cover-chapter-num">Chapter 03</div>
</header>

  <div class="content">
    <nav class="toc">
<h2 class="toc-title">목차</h2>
<ul>
<li><a href="#3-1-왜-systemverilog를-배워야-하는가">3.1 왜 SystemVerilog를 배워야 하는가?</a></li>
  <li class="toc-sub"><a href="#3-1-1-verilog의-한계">3.1.1 Verilog의 한계</a></li>
  <li class="toc-sub"><a href="#3-1-2-이-챕터에서-배울-것">3.1.2 이 챕터에서 배울 것</a></li>
<li><a href="#3-2-클래스-class-와-객체-object">3.2 클래스(Class)와 객체(Object)</a></li>
  <li class="toc-sub"><a href="#3-2-1-module과-class의-차이">3.2.1 module과 class의 차이</a></li>
  <li class="toc-sub"><a href="#3-2-2-첫-번째-클래스-만들기">3.2.2 첫 번째 클래스 만들기</a></li>
  <li class="toc-sub"><a href="#3-2-3-클래스-vs-객체-붕어빵-비유">3.2.3 클래스 vs 객체: 붕어빵 비유</a></li>
  <li class="toc-sub"><a href="#3-2-4-핸들-handle-클래스-변수의-정체">3.2.4 핸들(Handle) — 클래스 변수의 정체</a></li>
  <li class="toc-sub"><a href="#3-2-5-null-참조-에러-가장-흔한-실수">3.2.5 null 참조 에러 — 가장 흔한 실수</a></li>
<li><a href="#3-3-상속-inheritance-과-다형성-polymorphism">3.3 상속(Inheritance)과 다형성(Polymorphism)</a></li>
  <li class="toc-sub"><a href="#3-3-1-상속이란">3.3.1 상속이란?</a></li>
  <li class="toc-sub"><a href="#3-3-2-상속-실습">3.3.2 상속 실습</a></li>
  <li class="toc-sub"><a href="#3-3-3-다형성-polymorphism-왜-virtual이-중요한가">3.3.3 다형성(Polymorphism) — 왜 virtual이 중요한가?</a></li>
  <li class="toc-sub"><a href="#3-3-4-virtual-없이-실행하면">3.3.4 virtual 없이 실행하면?</a></li>
<li><a href="#3-4-인터페이스-interface">3.4 인터페이스(Interface)</a></li>
  <li class="toc-sub"><a href="#3-4-1-인터페이스가-필요한-이유">3.4.1 인터페이스가 필요한 이유</a></li>
  <li class="toc-sub"><a href="#3-4-2-인터페이스-정의와-사용">3.4.2 인터페이스 정의와 사용</a></li>
  <li class="toc-sub"><a href="#3-4-3-인터페이스의-핵심-요소">3.4.3 인터페이스의 핵심 요소</a></li>
<li><a href="#3-5-랜덤화-randomization-와-제약-조건-constraint">3.5 랜덤화(Randomization)와 제약 조건(Constraint)</a></li>
  <li class="toc-sub"><a href="#3-5-1-왜-랜덤-테스트가-필요한가">3.5.1 왜 랜덤 테스트가 필요한가?</a></li>
  <li class="toc-sub"><a href="#3-5-2-rand와-constraint-기본">3.5.2 rand와 constraint 기본</a></li>
  <li class="toc-sub"><a href="#3-5-3-중간-정리-랜덤화-핵심-키워드">3.5.3 중간 정리 — 랜덤화 핵심 키워드</a></li>
  <li class="toc-sub"><a href="#3-5-4-자주-쓰는-제약-조건-패턴">3.5.4 자주 쓰는 제약 조건 패턴</a></li>
  <li class="toc-sub"><a href="#3-5-5-inline-constraint-with절">3.5.5 inline constraint (with절)</a></li>
  <li class="toc-sub"><a href="#3-5-6-randomize-실패-처리">3.5.6 randomize() 실패 처리</a></li>
<li><a href="#3-6-열거형-enum-구조체-struct-타입-정의-typedef">3.6 열거형(Enum), 구조체(Struct), 타입 정의(Typedef)</a></li>
  <li class="toc-sub"><a href="#3-6-1-열거형-enum">3.6.1 열거형(Enum)</a></li>
  <li class="toc-sub"><a href="#3-6-2-구조체-struct-와-타입-정의-typedef">3.6.2 구조체(Struct)와 타입 정의(Typedef)</a></li>
  <li class="toc-sub"><a href="#3-6-3-종합-실습-모든-개념-활용">3.6.3 종합 실습: 모든 개념 활용</a></li>
<li><a href="#3-7-체크포인트">3.7 체크포인트</a></li>
  <li class="toc-sub"><a href="#셀프-체크">셀프 체크</a></li>
  <li class="toc-sub"><a href="#연습문제">연습문제</a></li>
  <li class="toc-sub"><a href="#흔한-컴파일-에러">흔한 컴파일 에러</a></li>
  <li class="toc-sub"><a href="#용어-정리">용어 정리</a></li>
  <li class="toc-sub"><a href="#다음-챕터-미리보기">다음 챕터 미리보기</a></li>
</ul>
</nav>
    <h1>Chapter 3: SystemVerilog 핵심</h1>
<blockquote>
<p><strong>학습 목표</strong></p>
<ul>
<li>SystemVerilog의 클래스(Class)와 객체(Object)의 개념을 이해한다</li>
<li>상속(Inheritance)과 다형성(Polymorphism)을 활용할 수 있다</li>
<li>SystemVerilog 인터페이스(Interface)의 역할과 기본 사용법을 익힌다</li>
<li>랜덤화(Randomization)와 제약 조건(Constraint)으로 테스트 데이터를 생성할 수 있다</li>
<li>열거형(Enum), 구조체(Struct), 타입 정의(Typedef)를 활용할 수 있다</li>
</ul>
</blockquote>
<blockquote>
<p><strong>학습 가이드</strong>: 이 챕터는 내용이 많습니다. 한 번에 다 읽으려 하지 말고 <strong>두 번에 나눠 학습</strong>하는 것을 추천합니다:</p>
<ul>
<li><strong>1일차</strong>: 3.1~3.3 (클래스, 상속, 다형성) — OOP의 핵심</li>
<li><strong>2일차</strong>: 3.4~3.6 (인터페이스, 랜덤화, 기타 타입) — 검증 도구</li>
</ul>
</blockquote>
<hr>
<h2 id="3-1-왜-systemverilog를-배워야-하는가">3.1 왜 SystemVerilog를 배워야 하는가?</h2>
<blockquote>
<p><strong>이 절의 목표</strong>: Verilog와 SystemVerilog의 차이를 이해하고, UVM에 SystemVerilog가 필요한 이유를 납득합니다.</p>
</blockquote>
<h3 id="3-1-1-verilog의-한계">3.1.1 Verilog의 한계</h3>
<p>Chapter 1에서 UVM은 <strong>객체지향(OOP, Object-Oriented Programming)</strong> 기반이라고 배웠습니다. 그런데 기존 Verilog에는 클래스(Class)가 없습니다:</p>
<table>
<thead>
<tr>
<th>기능</th>
<th>Verilog (1995/2001)</th>
<th>SystemVerilog (2005/2012)</th>
</tr>
</thead>
<tbody><tr>
<td>기본 구조</td>
<td>module, always, assign</td>
<td>Verilog 전체 + 아래 확장</td>
</tr>
<tr>
<td>객체지향</td>
<td>없음</td>
<td>클래스, 상속, 다형성</td>
</tr>
<tr>
<td>검증 자동화</td>
<td>없음</td>
<td>랜덤화, 제약 조건</td>
</tr>
<tr>
<td>신호 관리</td>
<td>개별 wire/reg</td>
<td>인터페이스, 어서션</td>
</tr>
<tr>
<td>재사용성</td>
<td>낮음 (module 복사)</td>
<td>높음 (상속, 확장)</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>핵심</strong>: SystemVerilog = Verilog + <strong>검증을 위한 확장 기능</strong>. UVM은 이 확장 기능 위에 만들어져 있으므로, SystemVerilog 기초를 먼저 배워야 합니다.</p>
</blockquote>
<h3 id="3-1-2-이-챕터에서-배울-것">3.1.2 이 챕터에서 배울 것</h3>
<p>UVM에서 가장 많이 쓰는 SystemVerilog 기능만 골라서 배웁니다:</p>
<table>
<thead>
<tr>
<th>기능</th>
<th>UVM에서의 용도</th>
<th>배울 절</th>
</tr>
</thead>
<tbody><tr>
<td>클래스(Class) &amp; 객체(Object)</td>
<td>모든 UVM 컴포넌트의 기반</td>
<td>3.2</td>
</tr>
<tr>
<td>상속(Inheritance) &amp; 다형성(Polymorphism)</td>
<td><code>uvm_test</code>, <code>uvm_driver</code> 등 확장</td>
<td>3.3</td>
</tr>
<tr>
<td>인터페이스(Interface)</td>
<td>DUT와 테스트벤치 연결</td>
<td>3.4</td>
</tr>
<tr>
<td>랜덤화(Randomization) &amp; 제약 조건(Constraint)</td>
<td>테스트 데이터 자동 생성</td>
<td>3.5</td>
</tr>
<tr>
<td>열거형(Enum), 구조체(Struct), 타입 정의(Typedef)</td>
<td>가독성 높은 코드 작성</td>
<td>3.6</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>범위 안내</strong>: 이 챕터는 &quot;UVM을 위한 SystemVerilog&quot;입니다. SystemVerilog의 모든 문법을 다루지 않고, UVM에서 실제로 사용하는 핵심만 집중합니다.</p>
</blockquote>
<blockquote>
<p><strong>실습 환경</strong>: Chapter 2에서 설정한 EDA Playground에서 <code>testbench.sv</code>에 코드를 복사하여 실행하세요. 시뮬레이터 설정(SystemVerilog, UVM 1.2)은 Chapter 2와 동일합니다.</p>
</blockquote>
<p>이제 첫 번째이자 가장 중요한 개념인 클래스를 알아봅시다.</p>
<hr>
<h2 id="3-2-클래스-class-와-객체-object">3.2 클래스(Class)와 객체(Object)</h2>
<blockquote>
<p><strong>이 절의 목표</strong>: 클래스와 객체의 관계를 이해하고, SystemVerilog에서 클래스를 정의하고 사용할 수 있게 됩니다.</p>
</blockquote>
<h3 id="3-2-1-module과-class의-차이">3.2.1 module과 class의 차이</h3>
<p>Verilog에서는 모든 것을 <code>module</code>로 만들었습니다. SystemVerilog에서는 검증용 코드를 <code>class</code>로 만듭니다:</p>
<table>
<thead>
<tr>
<th>비교</th>
<th><code>module</code></th>
<th><code>class</code></th>
</tr>
</thead>
<tbody><tr>
<td>용도</td>
<td><strong>하드웨어 설계</strong> (DUT)</td>
<td><strong>검증 코드</strong> (테스트벤치)</td>
</tr>
<tr>
<td>인스턴스 생성</td>
<td>컴파일 시 고정</td>
<td><strong>실행 중</strong> 동적 생성 가능</td>
</tr>
<tr>
<td>상속</td>
<td>불가능</td>
<td><strong>가능</strong> (extends)</td>
</tr>
<tr>
<td>메모리</td>
<td>정적 할당</td>
<td><strong>동적 할당</strong> (new)</td>
</tr>
<tr>
<td>UVM에서</td>
<td>DUT 작성에만 사용</td>
<td><strong>모든 UVM 컴포넌트</strong>에 사용</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>기억하세요</strong>: 하드웨어 = module, 검증 = class. UVM에서 작성하는 코드는 대부분 class입니다.</p>
</blockquote>
<h3 id="3-2-2-첫-번째-클래스-만들기">3.2.2 첫 번째 클래스 만들기</h3>
<p>C++의 class와 매우 비슷합니다. C++ 경험이 있다면 금방 익숙해질 것입니다:</p>
<p><strong>[예제 3-1] 간단한 패킷 클래스</strong></p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// 파일: testbench.sv (EDA Playground)</span>
<span class="hljs-comment">// [예제 3-1] 간단한 패킷 클래스</span>
<span class="hljs-comment">// 목적: class 정의, new(), 멤버 변수/함수 사용법 이해</span>

<span class="hljs-keyword">module</span> top;

  <span class="hljs-comment">// ── 클래스 정의 ──</span>
  <span class="hljs-comment">// C++: class Packet { ... };</span>
  <span class="hljs-comment">// SV:  class packet; ... endclass</span>
  <span class="hljs-keyword">class</span> packet;
    <span class="hljs-comment">// 멤버 변수 (C++의 멤버 변수와 동일)</span>
    <span class="hljs-keyword">bit</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]  addr;    <span class="hljs-comment">// 주소</span>
    <span class="hljs-keyword">bit</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] data;    <span class="hljs-comment">// 데이터</span>
    <span class="hljs-keyword">bit</span>        write;   <span class="hljs-comment">// 1: 쓰기, 0: 읽기</span>

    <span class="hljs-comment">// 생성자 (C++의 constructor와 동일)</span>
    <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">bit</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] addr, <span class="hljs-keyword">bit</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] data, <span class="hljs-keyword">bit</span> write);
      <span class="hljs-keyword">this</span><span class="hljs-variable">.addr</span>  = addr;    <span class="hljs-comment">// this: 자기 자신을 가리킴 (C++과 동일)</span>
      <span class="hljs-keyword">this</span><span class="hljs-variable">.data</span>  = data;
      <span class="hljs-keyword">this</span><span class="hljs-variable">.write</span> = write;
    <span class="hljs-keyword">endfunction</span>

    <span class="hljs-comment">// 멤버 함수 (C++의 메서드와 동일)</span>
    <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> display();
      <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;  Packet: addr=0x%02h, data=0x%08h, %s&quot;</span>,
               addr, data, write ? <span class="hljs-string">&quot;WRITE&quot;</span> : <span class="hljs-string">&quot;READ&quot;</span>);
    <span class="hljs-keyword">endfunction</span>
  <span class="hljs-keyword">endclass</span>

  <span class="hljs-comment">// ── 객체 생성 및 사용 ──</span>
  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span>
    packet pkt1, pkt2;  <span class="hljs-comment">// 변수 선언 (아직 객체가 아님 — null 상태)</span>

    <span class="hljs-comment">// new()로 객체 생성 (C++과 동일)</span>
    pkt1 = <span class="hljs-keyword">new</span>(<span class="hljs-number">8&#x27;h10</span>, <span class="hljs-number">32&#x27;hDEAD_BEEF</span>, <span class="hljs-number">1</span>);  <span class="hljs-comment">// 쓰기 패킷</span>
    pkt2 = <span class="hljs-keyword">new</span>(<span class="hljs-number">8&#x27;h20</span>, <span class="hljs-number">32&#x27;hCAFE_0000</span>, <span class="hljs-number">0</span>);  <span class="hljs-comment">// 읽기 패킷</span>

    <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;=== 패킷 출력 ===&quot;</span>);
    pkt1<span class="hljs-variable">.display</span>();  <span class="hljs-comment">// 메서드 호출 (C++의 pkt1.display()와 동일)</span>
    pkt2<span class="hljs-variable">.display</span>();
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</code></pre><p><strong>예상 출력</strong>:</p>
<pre><code>=== 패킷 출력 ===
  Packet: addr=0x10, data=0xdeadbeef, WRITE
  Packet: addr=0x20, data=0xcafe0000, READ
</code></pre><blockquote>
<p><strong>참고</strong>: 예상 출력의 세부 형식(대소문자, 줄 번호 등)은 시뮬레이터에 따라 다를 수 있습니다. 핵심 내용이 같으면 정상입니다.</p>
</blockquote>
<blockquote>
<p><strong>C++ 경험자를 위한 비교</strong>:</p>
<table>
<thead>
<tr>
<th>C++</th>
<th>SystemVerilog</th>
<th>비고</th>
</tr>
</thead>
<tbody><tr>
<td><code>class Packet { };</code></td>
<td><code>class packet; endclass</code></td>
<td>세미콜론 위치 다름</td>
</tr>
<tr>
<td><code>Packet* pkt = new Packet();</code></td>
<td><code>pkt = new();</code></td>
<td>SV는 포인터 개념 없이 자동 관리</td>
</tr>
<tr>
<td><code>delete pkt;</code></td>
<td>불필요</td>
<td>SV는 사용하지 않는 객체를 자동으로 정리합니다(가비지 컬렉션, Garbage Collection)</td>
</tr>
<tr>
<td><code>pkt-&gt;display()</code></td>
<td><code>pkt.display()</code></td>
<td>SV는 항상 <code>.</code> 사용</td>
</tr>
</tbody></table>
</blockquote>
<blockquote>
<p><strong>참고</strong>: SystemVerilog의 class 멤버 변수는 기본적으로 <strong>public</strong>(외부에서 접근 가능)입니다. C++이나 Java의 private 기본값과 다르니 주의하세요. <code>local</code>(private에 해당)과 <code>protected</code> 키워드도 있지만, UVM 학습 단계에서는 기본값(public)만 사용합니다.</p>
</blockquote>
<h3 id="3-2-3-클래스-vs-객체-붕어빵-비유">3.2.3 클래스 vs 객체: 붕어빵 비유</h3>

<div class="svg-diagram">
<svg viewBox="0 0 700 260" xmlns="http://www.w3.org/2000/svg" style="max-width:700px;width:100%">
  
  <style>
    .diagram-box { fill: #ffffff; stroke: #334155; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-accent { fill: #eff6ff; stroke: #2563eb; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-highlight { fill: #fef3c7; stroke: #f59e0b; stroke-width: 2.5; rx: 10; ry: 10; }
    .diagram-box-dark { fill: #1e293b; stroke: #1e293b; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-run { fill: #fef3c7; stroke: #f59e0b; stroke-width: 3; rx: 10; ry: 10; }
    .diagram-box-green { fill: #ecfdf5; stroke: #10b981; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-purple { fill: #f5f3ff; stroke: #7c3aed; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-red { fill: #fef2f2; stroke: #ef4444; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-gray { fill: #f8fafc; stroke: #94a3b8; stroke-width: 1.5; rx: 8; ry: 8; }
    .diagram-text { font-family: 'Noto Sans KR', sans-serif; fill: #1e293b; }
    .diagram-text-white { font-family: 'Noto Sans KR', sans-serif; fill: #ffffff; }
    .diagram-text-accent { font-family: 'Noto Sans KR', sans-serif; fill: #2563eb; }
    .diagram-text-small { font-family: 'Noto Sans KR', sans-serif; fill: #64748b; font-size: 12px; }
    .diagram-text-code { font-family: 'Fira Code', 'JetBrains Mono', monospace; fill: #1e293b; }
    .diagram-arrow { fill: none; stroke: #64748b; stroke-width: 1.5; }
    .diagram-arrow-accent { fill: none; stroke: #2563eb; stroke-width: 1.5; }
    .diagram-line { stroke: #cbd5e1; stroke-width: 1.5; stroke-dasharray: 6,3; }
  </style>
  <defs>
    <marker id="arrowhead" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#64748b" />
    </marker>
    <marker id="arrowhead-accent" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#2563eb" />
    </marker>
    <marker id="arrowhead-dark" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#1e293b" />
    </marker>
    <marker id="arrowhead-orange" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#f59e0b" />
    </marker>
    <filter id="shadow" x="-5%" y="-5%" width="115%" height="115%">
      <feDropShadow dx="0" dy="2" stdDeviation="3" flood-color="#000" flood-opacity="0.1"/>
    </filter>
  </defs>

  <!-- Title -->
  <text x="350" y="24" text-anchor="middle" class="diagram-text" font-size="15" font-weight="bold">클래스 vs 객체</text>

  <!-- Class = 붕어빵 틀 (left side) -->
  <rect x="30" y="42" width="260" height="90" class="diagram-box-accent" filter="url(#shadow)"/>
  <rect x="30" y="42" width="260" height="28" rx="10" ry="10" fill="#2563eb"/>
  <rect x="30" y="58" width="260" height="12" fill="#2563eb"/>
  <text x="160" y="62" text-anchor="middle" class="diagram-text-white" font-size="13" font-weight="bold">클래스 (Class)</text>
  <text x="160" y="90" text-anchor="middle" class="diagram-text" font-size="13" font-weight="bold">= 붕어빵 틀</text>
  <text x="160" y="114" text-anchor="middle" class="diagram-text-small" font-size="11">설계도 (하나만 있으면 됨)</text>

  <!-- Arrow -->
  <text x="332" y="86" text-anchor="middle" class="diagram-text" font-size="22">→</text>
  <text x="332" y="108" text-anchor="middle" class="diagram-text-code" font-size="11">new()</text>

  <!-- Object = 실제 붕어빵 (right side, multiple) -->
  <rect x="380" y="42" width="290" height="90" class="diagram-box-green" filter="url(#shadow)"/>
  <rect x="380" y="42" width="290" height="28" rx="10" ry="10" fill="#10b981"/>
  <rect x="380" y="58" width="290" height="12" fill="#10b981"/>
  <text x="525" y="62" text-anchor="middle" class="diagram-text-white" font-size="13" font-weight="bold">객체 (Object)</text>
  <text x="525" y="90" text-anchor="middle" class="diagram-text" font-size="13" font-weight="bold">= 실제 붕어빵</text>
  <text x="525" y="114" text-anchor="middle" class="diagram-text-small" font-size="11">설계도로 찍어낸 실물 (여러 개 가능)</text>

  <!-- Code examples -->
  <rect x="30" y="152" width="300" height="44" class="diagram-box-gray" rx="6" ry="6"/>
  <text x="50" y="178" class="diagram-text-code" font-size="12">packet pkt1 = new(...);</text>
  <text x="340" y="178" class="diagram-text-small" font-size="11">붕어빵 1개</text>

  <rect x="30" y="206" width="300" height="44" class="diagram-box-gray" rx="6" ry="6"/>
  <text x="50" y="232" class="diagram-text-code" font-size="12">packet pkt2 = new(...);</text>
  <text x="340" y="232" class="diagram-text-small" font-size="11">붕어빵 또 1개</text>

  <!-- Note -->
  <text x="520" y="200" text-anchor="middle" class="diagram-text-accent" font-size="12" font-weight="bold" font-style="italic">각각 다른 맛(데이터)을</text>
  <text x="520" y="220" text-anchor="middle" class="diagram-text-accent" font-size="12" font-weight="bold" font-style="italic">가질 수 있음!</text>
</svg>
</div>
<div class="svg-diagram">
<svg viewBox="0 0 600 340" xmlns="http://www.w3.org/2000/svg" style="max-width:600px;width:100%">
  
  <style>
    .diagram-box { fill: #ffffff; stroke: #334155; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-accent { fill: #eff6ff; stroke: #2563eb; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-highlight { fill: #fef3c7; stroke: #f59e0b; stroke-width: 2.5; rx: 10; ry: 10; }
    .diagram-box-dark { fill: #1e293b; stroke: #1e293b; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-run { fill: #fef3c7; stroke: #f59e0b; stroke-width: 3; rx: 10; ry: 10; }
    .diagram-box-green { fill: #ecfdf5; stroke: #10b981; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-purple { fill: #f5f3ff; stroke: #7c3aed; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-red { fill: #fef2f2; stroke: #ef4444; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-gray { fill: #f8fafc; stroke: #94a3b8; stroke-width: 1.5; rx: 8; ry: 8; }
    .diagram-text { font-family: 'Noto Sans KR', sans-serif; fill: #1e293b; }
    .diagram-text-white { font-family: 'Noto Sans KR', sans-serif; fill: #ffffff; }
    .diagram-text-accent { font-family: 'Noto Sans KR', sans-serif; fill: #2563eb; }
    .diagram-text-small { font-family: 'Noto Sans KR', sans-serif; fill: #64748b; font-size: 12px; }
    .diagram-text-code { font-family: 'Fira Code', 'JetBrains Mono', monospace; fill: #1e293b; }
    .diagram-arrow { fill: none; stroke: #64748b; stroke-width: 1.5; }
    .diagram-arrow-accent { fill: none; stroke: #2563eb; stroke-width: 1.5; }
    .diagram-line { stroke: #cbd5e1; stroke-width: 1.5; stroke-dasharray: 6,3; }
  </style>
  <defs>
    <marker id="arrowhead" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#64748b" />
    </marker>
    <marker id="arrowhead-accent" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#2563eb" />
    </marker>
    <marker id="arrowhead-dark" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#1e293b" />
    </marker>
    <marker id="arrowhead-orange" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#f59e0b" />
    </marker>
    <filter id="shadow" x="-5%" y="-5%" width="115%" height="115%">
      <feDropShadow dx="0" dy="2" stdDeviation="3" flood-color="#000" flood-opacity="0.1"/>
    </filter>
  </defs>

  <!-- Class (Blueprint) -->
  <rect x="175" y="10" width="250" height="120" class="diagram-box-accent" filter="url(#shadow)"/>
  <rect x="175" y="10" width="250" height="32" rx="10" ry="10" fill="#2563eb"/>
  <rect x="175" y="30" width="250" height="12" fill="#2563eb"/>
  <text x="300" y="30" text-anchor="middle" class="diagram-text-white" font-size="14" font-weight="bold">class packet</text>
  <text x="440" y="30" text-anchor="end" font-family="'Noto Sans KR',sans-serif" fill="#93c5fd" font-size="11">설계도</text>

  <!-- Class members -->
  <text x="200" y="64" class="diagram-text-code" font-size="12">addr, data, write</text>
  <text x="200" y="84" class="diagram-text-code" font-size="12">display()</text>
  <line x1="195" y1="95" x2="405" y2="95" stroke="#cbd5e1" stroke-width="1"/>
  <text x="200" y="114" class="diagram-text-small" font-size="11" font-style="italic">하나만 정의하면 여러 객체 생성 가능</text>

  <!-- new() arrow splitting -->
  <line x1="300" y1="130" x2="300" y2="170" stroke="#2563eb" stroke-width="2.5"/>
  <text x="320" y="158" class="diagram-text-accent" font-size="12" font-weight="bold">new()</text>

  <!-- Split into two -->
  <line x1="300" y1="170" x2="180" y2="170" stroke="#2563eb" stroke-width="2"/>
  <line x1="300" y1="170" x2="420" y2="170" stroke="#2563eb" stroke-width="2"/>
  <line x1="180" y1="170" x2="180" y2="200" stroke="#2563eb" stroke-width="1.5" marker-end="url(#arrowhead-accent)"/>
  <line x1="420" y1="170" x2="420" y2="200" stroke="#2563eb" stroke-width="1.5" marker-end="url(#arrowhead-accent)"/>

  <!-- pkt1 Object -->
  <rect x="90" y="204" width="180" height="120" class="diagram-box-green" filter="url(#shadow)"/>
  <rect x="90" y="204" width="180" height="28" rx="10" ry="10" fill="#10b981"/>
  <rect x="90" y="222" width="180" height="10" fill="#10b981"/>
  <text x="180" y="224" text-anchor="middle" class="diagram-text-white" font-size="13" font-weight="bold">pkt1</text>
  <text x="115" y="254" class="diagram-text-code" font-size="12">addr = 0x10</text>
  <text x="115" y="274" class="diagram-text-code" font-size="12">data = 0x1111</text>
  <text x="115" y="294" class="diagram-text-code" font-size="12">write = WRITE</text>
  <text x="180" y="318" text-anchor="middle" class="diagram-text-small" font-size="11">객체 1</text>

  <!-- pkt2 Object -->
  <rect x="330" y="204" width="180" height="120" class="diagram-box-purple" filter="url(#shadow)"/>
  <rect x="330" y="204" width="180" height="28" rx="10" ry="10" fill="#7c3aed"/>
  <rect x="330" y="222" width="180" height="10" fill="#7c3aed"/>
  <text x="420" y="224" text-anchor="middle" class="diagram-text-white" font-size="13" font-weight="bold">pkt2</text>
  <text x="355" y="254" class="diagram-text-code" font-size="12">addr = 0x20</text>
  <text x="355" y="274" class="diagram-text-code" font-size="12">data = 0x2222</text>
  <text x="355" y="294" class="diagram-text-code" font-size="12">write = READ</text>
  <text x="420" y="318" text-anchor="middle" class="diagram-text-small" font-size="11">객체 2</text>
</svg>
</div><blockquote>
<p><strong>UVM과의 연결</strong>: Chapter 1에서 본 <code>class hello_test extends uvm_test</code>에서 <code>hello_test</code>가 클래스이고, <code>run_test(&quot;hello_test&quot;)</code>가 호출될 때 UVM이 내부적으로 <code>new()</code>를 호출하여 객체를 만듭니다.</p>
</blockquote>
<h3 id="3-2-4-핸들-handle-클래스-변수의-정체">3.2.4 핸들(Handle) — 클래스 변수의 정체</h3>
<p>클래스 변수는 객체 자체가 아니라 객체를 **가리키는 핸들(참조)**입니다. C++의 포인터와 비슷하지만, SystemVerilog에서는 포인터 연산이 없어 더 안전합니다:</p>
<pre><code class="hljs language-systemverilog">packet pkt1 = <span class="hljs-keyword">new</span>(<span class="hljs-number">8&#x27;h10</span>, <span class="hljs-number">32&#x27;h1111</span>, <span class="hljs-number">1</span>);  <span class="hljs-comment">// 객체 A 생성, pkt1이 가리킴</span>
packet pkt2;

pkt2 = pkt1;  <span class="hljs-comment">// ⚠️ 객체가 복사되는 게 아닙니다!</span>
              <span class="hljs-comment">// pkt2도 같은 객체 A를 가리키게 됩니다</span>

pkt1<span class="hljs-variable">.addr</span> = <span class="hljs-number">8&#x27;hFF</span>;      <span class="hljs-comment">// pkt1을 통해 addr 변경</span>
<span class="hljs-built_in">$display</span>(pkt2<span class="hljs-variable">.addr</span>);    <span class="hljs-comment">// 0xFF가 출력됨! pkt2도 같은 객체를 보고 있으니까</span>
</code></pre>
<div class="svg-diagram">
<svg viewBox="0 0 520 160" xmlns="http://www.w3.org/2000/svg" style="max-width:520px;width:100%">
  
  <style>
    .diagram-box { fill: #ffffff; stroke: #334155; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-accent { fill: #eff6ff; stroke: #2563eb; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-highlight { fill: #fef3c7; stroke: #f59e0b; stroke-width: 2.5; rx: 10; ry: 10; }
    .diagram-box-dark { fill: #1e293b; stroke: #1e293b; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-run { fill: #fef3c7; stroke: #f59e0b; stroke-width: 3; rx: 10; ry: 10; }
    .diagram-box-green { fill: #ecfdf5; stroke: #10b981; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-purple { fill: #f5f3ff; stroke: #7c3aed; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-red { fill: #fef2f2; stroke: #ef4444; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-gray { fill: #f8fafc; stroke: #94a3b8; stroke-width: 1.5; rx: 8; ry: 8; }
    .diagram-text { font-family: 'Noto Sans KR', sans-serif; fill: #1e293b; }
    .diagram-text-white { font-family: 'Noto Sans KR', sans-serif; fill: #ffffff; }
    .diagram-text-accent { font-family: 'Noto Sans KR', sans-serif; fill: #2563eb; }
    .diagram-text-small { font-family: 'Noto Sans KR', sans-serif; fill: #64748b; font-size: 12px; }
    .diagram-text-code { font-family: 'Fira Code', 'JetBrains Mono', monospace; fill: #1e293b; }
    .diagram-arrow { fill: none; stroke: #64748b; stroke-width: 1.5; }
    .diagram-arrow-accent { fill: none; stroke: #2563eb; stroke-width: 1.5; }
    .diagram-line { stroke: #cbd5e1; stroke-width: 1.5; stroke-dasharray: 6,3; }
  </style>
  <defs>
    <marker id="arrowhead" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#64748b" />
    </marker>
    <marker id="arrowhead-accent" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#2563eb" />
    </marker>
    <marker id="arrowhead-dark" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#1e293b" />
    </marker>
    <marker id="arrowhead-orange" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#f59e0b" />
    </marker>
    <filter id="shadow" x="-5%" y="-5%" width="115%" height="115%">
      <feDropShadow dx="0" dy="2" stdDeviation="3" flood-color="#000" flood-opacity="0.1"/>
    </filter>
  </defs>

  <!-- pkt1 handle box -->
  <rect x="20" y="20" width="110" height="44" class="diagram-box-accent" filter="url(#shadow)"/>
  <text x="75" y="47" text-anchor="middle" class="diagram-text-code" font-size="14" font-weight="bold">pkt1</text>

  <!-- pkt2 handle box -->
  <rect x="20" y="90" width="110" height="44" class="diagram-box-purple" filter="url(#shadow)"/>
  <text x="75" y="117" text-anchor="middle" class="diagram-text-code" font-size="14" font-weight="bold">pkt2</text>

  <!-- Arrows converging to object -->
  <line x1="130" y1="42" x2="240" y2="72" stroke="#2563eb" stroke-width="1.5" marker-end="url(#arrowhead-accent)"/>
  <line x1="130" y1="112" x2="240" y2="82" stroke="#7c3aed" stroke-width="1.5" marker-end="url(#arrowhead-accent)"/>

  <!-- Shared object -->
  <rect x="244" y="38" width="250" height="80" class="diagram-box-highlight" filter="url(#shadow)"/>
  <text x="369" y="62" text-anchor="middle" class="diagram-text" font-size="14" font-weight="bold">객체 A</text>
  <text x="369" y="82" text-anchor="middle" class="diagram-text-code" font-size="12">addr = 0xFF</text>
  <text x="369" y="100" text-anchor="middle" class="diagram-text-small" font-size="11">하나의 객체를 둘이 공유</text>

  <!-- Label -->
  <text x="260" y="145" text-anchor="middle" class="diagram-text-small" font-size="11" font-style="italic">pkt2 = pkt1 실행 후</text>
</svg>
</div><blockquote>
<p><strong>주의</strong>: <code>pkt2 = pkt1;</code>은 객체를 복사하는 것이 아니라, <strong>같은 객체를 가리키는 핸들(참조)을 복사</strong>합니다. pkt1의 데이터를 바꾸면 pkt2로 접근해도 바뀐 값이 보입니다. 객체를 독립적으로 복사하려면 Chapter 6에서 배울 <code>copy()</code> 메서드가 필요합니다.</p>
</blockquote>
<h3 id="3-2-5-null-참조-에러-가장-흔한-실수">3.2.5 null 참조 에러 — 가장 흔한 실수</h3>
<pre><code class="hljs language-systemverilog">packet pkt;        <span class="hljs-comment">// 선언만 함 → null 상태 (아무 객체도 가리키지 않음)</span>
pkt<span class="hljs-variable">.display</span>();     <span class="hljs-comment">// 에러! null 핸들의 메서드를 호출하려고 함</span>
</code></pre><pre><code>** Fatal: (SIGSEGV) Bad handle or reference.
</code></pre><p><strong>해결</strong>: 반드시 <code>pkt = new(...);</code>로 객체를 생성한 후 사용하세요. UVM에서는 <code>type_id::create()</code>로 생성합니다.</p>
<blockquote>
<p><strong>실무 참고</strong>: 이 챕터의 예제에서는 편의상 <code>module</code> 안에 class를 정의했지만, 실무와 UVM에서는 class를 <code>package</code> 안에 정의하고 <code>import</code>하여 사용합니다. 이 방식은 Chapter 5에서 실제 프로젝트를 구성할 때 배웁니다.</p>
</blockquote>
<p>클래스의 기본을 익혔으니, 이제 클래스의 진정한 힘인 상속을 배워봅시다.</p>
<hr>
<h2 id="3-3-상속-inheritance-과-다형성-polymorphism">3.3 상속(Inheritance)과 다형성(Polymorphism)</h2>
<blockquote>
<p><strong>이 절의 목표</strong>: extends로 클래스를 확장하고, virtual 함수를 통한 다형성을 이해합니다.</p>
</blockquote>
<h3 id="3-3-1-상속이란">3.3.1 상속이란?</h3>
<p>기존 클래스를 **확장(extends)**하여 새 클래스를 만드는 것입니다. UVM의 모든 컴포넌트가 이 방식으로 만들어집니다:</p>

<div class="svg-diagram">
<svg viewBox="0 0 660 220" xmlns="http://www.w3.org/2000/svg" style="max-width:660px;width:100%">
  
  <style>
    .diagram-box { fill: #ffffff; stroke: #334155; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-accent { fill: #eff6ff; stroke: #2563eb; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-highlight { fill: #fef3c7; stroke: #f59e0b; stroke-width: 2.5; rx: 10; ry: 10; }
    .diagram-box-dark { fill: #1e293b; stroke: #1e293b; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-run { fill: #fef3c7; stroke: #f59e0b; stroke-width: 3; rx: 10; ry: 10; }
    .diagram-box-green { fill: #ecfdf5; stroke: #10b981; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-purple { fill: #f5f3ff; stroke: #7c3aed; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-red { fill: #fef2f2; stroke: #ef4444; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-gray { fill: #f8fafc; stroke: #94a3b8; stroke-width: 1.5; rx: 8; ry: 8; }
    .diagram-text { font-family: 'Noto Sans KR', sans-serif; fill: #1e293b; }
    .diagram-text-white { font-family: 'Noto Sans KR', sans-serif; fill: #ffffff; }
    .diagram-text-accent { font-family: 'Noto Sans KR', sans-serif; fill: #2563eb; }
    .diagram-text-small { font-family: 'Noto Sans KR', sans-serif; fill: #64748b; font-size: 12px; }
    .diagram-text-code { font-family: 'Fira Code', 'JetBrains Mono', monospace; fill: #1e293b; }
    .diagram-arrow { fill: none; stroke: #64748b; stroke-width: 1.5; }
    .diagram-arrow-accent { fill: none; stroke: #2563eb; stroke-width: 1.5; }
    .diagram-line { stroke: #cbd5e1; stroke-width: 1.5; stroke-dasharray: 6,3; }
  </style>
  <defs>
    <marker id="arrowhead" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#64748b" />
    </marker>
    <marker id="arrowhead-accent" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#2563eb" />
    </marker>
    <marker id="arrowhead-dark" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#1e293b" />
    </marker>
    <marker id="arrowhead-orange" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#f59e0b" />
    </marker>
    <filter id="shadow" x="-5%" y="-5%" width="115%" height="115%">
      <feDropShadow dx="0" dy="2" stdDeviation="3" flood-color="#000" flood-opacity="0.1"/>
    </filter>
  </defs>

  <!-- uvm_object (root) -->
  <rect x="245" y="8" width="170" height="40" class="diagram-box-highlight" filter="url(#shadow)"/>
  <text x="330" y="33" text-anchor="middle" class="diagram-text-code" font-size="13" font-weight="bold">uvm_object</text>

  <!-- Arrow down -->
  <line x1="330" y1="48" x2="330" y2="68" stroke="#64748b" stroke-width="1.5" marker-end="url(#arrowhead)"/>

  <!-- uvm_component -->
  <rect x="220" y="72" width="220" height="40" class="diagram-box-accent" filter="url(#shadow)"/>
  <text x="330" y="97" text-anchor="middle" class="diagram-text-code" font-size="13" font-weight="bold">uvm_component</text>

  <!-- Fan-out lines -->
  <line x1="330" y1="112" x2="330" y2="130" stroke="#64748b" stroke-width="2"/>
  <line x1="70" y1="130" x2="590" y2="130" stroke="#64748b" stroke-width="2"/>

  <!-- Drop lines -->
  <line x1="70" y1="130" x2="70" y2="150" stroke="#64748b" stroke-width="1.5"/>
  <line x1="200" y1="130" x2="200" y2="150" stroke="#64748b" stroke-width="1.5"/>
  <line x1="330" y1="130" x2="330" y2="150" stroke="#64748b" stroke-width="1.5"/>
  <line x1="460" y1="130" x2="460" y2="150" stroke="#64748b" stroke-width="1.5"/>
  <line x1="590" y1="130" x2="590" y2="150" stroke="#64748b" stroke-width="1.5"/>

  <!-- uvm_test -->
  <rect x="10" y="152" width="120" height="40" class="diagram-box-green" filter="url(#shadow)"/>
  <text x="70" y="177" text-anchor="middle" class="diagram-text-code" font-size="11" font-weight="bold">uvm_test</text>

  <!-- uvm_env -->
  <rect x="145" y="152" width="110" height="40" class="diagram-box-green" filter="url(#shadow)"/>
  <text x="200" y="177" text-anchor="middle" class="diagram-text-code" font-size="11" font-weight="bold">uvm_env</text>

  <!-- uvm_agent -->
  <rect x="270" y="152" width="120" height="40" class="diagram-box-purple" filter="url(#shadow)"/>
  <text x="330" y="177" text-anchor="middle" class="diagram-text-code" font-size="11" font-weight="bold">uvm_agent</text>

  <!-- uvm_driver -->
  <rect x="402" y="152" width="120" height="40" class="diagram-box-purple" filter="url(#shadow)"/>
  <text x="462" y="177" text-anchor="middle" class="diagram-text-code" font-size="11" font-weight="bold">uvm_driver</text>

  <!-- uvm_monitor -->
  <rect x="534" y="152" width="120" height="40" class="diagram-box-purple" filter="url(#shadow)"/>
  <text x="594" y="177" text-anchor="middle" class="diagram-text-code" font-size="11" font-weight="bold">uvm_monitor</text>

  <!-- Annotations -->
  <text x="70" y="208" text-anchor="middle" class="diagram-text-small" font-size="10">Ch.1-2에서 사용</text>
</svg>
</div><blockquote>
<p><strong>비유</strong>: 상속 = &quot;기본 기능을 물려받고, 나만의 기능을 추가하는 것&quot;. 스마트폰을 생각해보세요 — 기본 전화 기능(부모)은 그대로 가지면서, 각 앱(자식)은 자기만의 기능을 추가합니다.</p>
</blockquote>
<h3 id="3-3-2-상속-실습">3.3.2 상속 실습</h3>
<p><strong>[예제 3-2] 상속으로 클래스 확장하기</strong></p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// 파일: testbench.sv (EDA Playground)</span>
<span class="hljs-comment">// [예제 3-2] 상속(Inheritance) 실습</span>
<span class="hljs-comment">// 목적: extends, super, 메서드 오버라이드 이해</span>

<span class="hljs-keyword">module</span> top;

  <span class="hljs-comment">// ── 부모 클래스: 기본 패킷 ──</span>
  <span class="hljs-keyword">class</span> base_packet;
    <span class="hljs-keyword">bit</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]  addr;
    <span class="hljs-keyword">bit</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] data;

    <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">bit</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] addr, <span class="hljs-keyword">bit</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] data);
      <span class="hljs-keyword">this</span><span class="hljs-variable">.addr</span> = addr;
      <span class="hljs-keyword">this</span><span class="hljs-variable">.data</span> = data;
    <span class="hljs-keyword">endfunction</span>

    <span class="hljs-comment">// virtual: 자식 클래스에서 재정의(오버라이드)할 수 있게 허용</span>
    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> display();
      <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;  [Base] addr=0x%02h, data=0x%08h&quot;</span>, addr, data);
    <span class="hljs-keyword">endfunction</span>

    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">int</span> get_size();
      <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;  <span class="hljs-comment">// 기본 크기: addr(1) + data(4) = 5바이트</span>
    <span class="hljs-keyword">endfunction</span>
  <span class="hljs-keyword">endclass</span>

  <span class="hljs-comment">// ── 자식 클래스: 확장 패킷 ──</span>
  <span class="hljs-comment">// base_packet의 모든 기능을 물려받고, 추가 기능을 넣습니다</span>
  <span class="hljs-keyword">class</span> extended_packet <span class="hljs-keyword">extends</span> base_packet;
    <span class="hljs-keyword">bit</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] checksum;  <span class="hljs-comment">// 추가 필드: 체크섬</span>

    <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">bit</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] addr, <span class="hljs-keyword">bit</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] data, <span class="hljs-keyword">bit</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] checksum);
      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(addr, data);     <span class="hljs-comment">// 부모 생성자 호출 (필수!)</span>
      <span class="hljs-keyword">this</span><span class="hljs-variable">.checksum</span> = checksum;
    <span class="hljs-keyword">endfunction</span>

    <span class="hljs-comment">// 부모의 display()를 재정의 (오버라이드)</span>
    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> display();
      <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;  [Extended] addr=0x%02h, data=0x%08h, checksum=0x%04h&quot;</span>,
               addr, data, checksum);
    <span class="hljs-keyword">endfunction</span>

    <span class="hljs-comment">// 부모의 get_size()를 재정의</span>
    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">int</span> get_size();
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span><span class="hljs-variable">.get_size</span>() + <span class="hljs-number">2</span>;  <span class="hljs-comment">// 부모 크기 + checksum(2바이트)</span>
    <span class="hljs-keyword">endfunction</span>
  <span class="hljs-keyword">endclass</span>

  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span>
    base_packet     bp;
    extended_packet ep;

    bp = <span class="hljs-keyword">new</span>(<span class="hljs-number">8&#x27;hAA</span>, <span class="hljs-number">32&#x27;h1111_2222</span>);
    ep = <span class="hljs-keyword">new</span>(<span class="hljs-number">8&#x27;hBB</span>, <span class="hljs-number">32&#x27;h3333_4444</span>, <span class="hljs-number">16&#x27;hFF00</span>);

    <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;=== 기본 패킷 ===&quot;</span>);
    bp<span class="hljs-variable">.display</span>();
    <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;  크기: %0d 바이트&quot;</span>, bp<span class="hljs-variable">.get_size</span>());

    <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;=== 확장 패킷 ===&quot;</span>);
    ep<span class="hljs-variable">.display</span>();
    <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;  크기: %0d 바이트&quot;</span>, ep<span class="hljs-variable">.get_size</span>());
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</code></pre><p><strong>예상 출력</strong>:</p>
<pre><code>=== 기본 패킷 ===
  [Base] addr=0xaa, data=0x11112222
  크기: 5 바이트
=== 확장 패킷 ===
  [Extended] addr=0xbb, data=0x33334444, checksum=0xff00
  크기: 7 바이트
</code></pre><p><strong>핵심 키워드 정리</strong>:</p>
<table>
<thead>
<tr>
<th>키워드</th>
<th>의미</th>
<th>C++ 대응</th>
<th>UVM에서의 사용</th>
</tr>
</thead>
<tbody><tr>
<td><code>extends</code></td>
<td>부모 클래스를 상속</td>
<td><code>:</code> (콜론)</td>
<td><code>class my_test extends uvm_test</code></td>
</tr>
<tr>
<td><code>super</code></td>
<td>부모 클래스 참조</td>
<td>부모 클래스명 명시</td>
<td><code>super.new(name, parent)</code>, <code>super.build_phase(phase)</code></td>
</tr>
<tr>
<td><code>virtual</code></td>
<td>자식이 재정의할 수 있게 허용</td>
<td><code>virtual</code> (동일)</td>
<td>모든 페이즈 함수에 사용</td>
</tr>
<tr>
<td><code>this</code></td>
<td>자기 자신 참조</td>
<td><code>this</code> (동일)</td>
<td><code>phase.raise_objection(this)</code></td>
</tr>
</tbody></table>
<h3 id="3-3-3-다형성-polymorphism-왜-virtual이-중요한가">3.3.3 다형성(Polymorphism) — 왜 virtual이 중요한가?</h3>
<p>다형성이란 <strong>같은 명령을 내려도 객체마다 다르게 반응하는 것</strong>입니다. &quot;소리 내!&quot;라고 하면 강아지는 멍멍, 고양이는 야옹이라고 합니다. 코드로 표현하면, <strong>부모 타입 변수에 자식 객체를 담아도 자식의 함수가 호출되는 것</strong>입니다:</p>
<p><strong>[예제 3-3] 다형성 체험</strong></p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// 파일: testbench.sv (EDA Playground)</span>
<span class="hljs-comment">// [예제 3-3] 다형성(Polymorphism) 체험</span>
<span class="hljs-comment">// 목적: virtual 함수의 동작 원리 이해</span>

<span class="hljs-keyword">module</span> top;

  <span class="hljs-keyword">class</span> animal;
    <span class="hljs-keyword">string</span> name;
    <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name);
      <span class="hljs-keyword">this</span><span class="hljs-variable">.name</span> = name;
    <span class="hljs-keyword">endfunction</span>

    <span class="hljs-comment">// virtual이 있으면: 실제 객체 타입의 함수가 호출됨</span>
    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> speak();
      <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;  %s: ...(소리 없음)&quot;</span>, name);
    <span class="hljs-keyword">endfunction</span>
  <span class="hljs-keyword">endclass</span>

  <span class="hljs-keyword">class</span> dog <span class="hljs-keyword">extends</span> animal;
    <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name);
      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);
    <span class="hljs-keyword">endfunction</span>
    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> speak();
      <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;  %s: 멍멍!&quot;</span>, name);
    <span class="hljs-keyword">endfunction</span>
  <span class="hljs-keyword">endclass</span>

  <span class="hljs-keyword">class</span> cat <span class="hljs-keyword">extends</span> animal;
    <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name);
      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);
    <span class="hljs-keyword">endfunction</span>
    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> speak();
      <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;  %s: 야옹!&quot;</span>, name);
    <span class="hljs-keyword">endfunction</span>
  <span class="hljs-keyword">endclass</span>

  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span>
    <span class="hljs-comment">// 부모 타입 변수에 자식 객체를 담을 수 있음!</span>
    animal animals[<span class="hljs-number">3</span>];

    <span class="hljs-comment">// 자식 객체를 만들어서 부모 타입 배열에 저장</span>
    dog   d;
    cat   c;

    animals[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;동물&quot;</span>);          <span class="hljs-comment">// animal 객체</span>
    d = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;강아지&quot;</span>);
    c = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;고양이&quot;</span>);
    animals[<span class="hljs-number">1</span>] = d;                    <span class="hljs-comment">// dog 객체를 animal 변수에 저장</span>
    animals[<span class="hljs-number">2</span>] = c;                    <span class="hljs-comment">// cat 객체를 animal 변수에 저장</span>

    <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;=== 다형성 데모 ===&quot;</span>);
    <span class="hljs-keyword">foreach</span> (animals[i])
      animals[i]<span class="hljs-variable">.speak</span>();  <span class="hljs-comment">// 각 객체의 실제 타입에 맞는 함수가 호출됨!</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</code></pre><p><strong>예상 출력</strong>:</p>
<pre><code>=== 다형성 데모 ===
  동물: ...(소리 없음)
  강아지: 멍멍!
  고양이: 야옹!
</code></pre><p>다형성의 동작 원리를 그림으로 보면:</p>

<div class="svg-diagram">
<svg viewBox="0 0 720 250" xmlns="http://www.w3.org/2000/svg" style="max-width:720px;width:100%">
  
  <style>
    .diagram-box { fill: #ffffff; stroke: #334155; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-accent { fill: #eff6ff; stroke: #2563eb; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-highlight { fill: #fef3c7; stroke: #f59e0b; stroke-width: 2.5; rx: 10; ry: 10; }
    .diagram-box-dark { fill: #1e293b; stroke: #1e293b; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-run { fill: #fef3c7; stroke: #f59e0b; stroke-width: 3; rx: 10; ry: 10; }
    .diagram-box-green { fill: #ecfdf5; stroke: #10b981; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-purple { fill: #f5f3ff; stroke: #7c3aed; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-red { fill: #fef2f2; stroke: #ef4444; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-gray { fill: #f8fafc; stroke: #94a3b8; stroke-width: 1.5; rx: 8; ry: 8; }
    .diagram-text { font-family: 'Noto Sans KR', sans-serif; fill: #1e293b; }
    .diagram-text-white { font-family: 'Noto Sans KR', sans-serif; fill: #ffffff; }
    .diagram-text-accent { font-family: 'Noto Sans KR', sans-serif; fill: #2563eb; }
    .diagram-text-small { font-family: 'Noto Sans KR', sans-serif; fill: #64748b; font-size: 12px; }
    .diagram-text-code { font-family: 'Fira Code', 'JetBrains Mono', monospace; fill: #1e293b; }
    .diagram-arrow { fill: none; stroke: #64748b; stroke-width: 1.5; }
    .diagram-arrow-accent { fill: none; stroke: #2563eb; stroke-width: 1.5; }
    .diagram-line { stroke: #cbd5e1; stroke-width: 1.5; stroke-dasharray: 6,3; }
  </style>
  <defs>
    <marker id="arrowhead" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#64748b" />
    </marker>
    <marker id="arrowhead-accent" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#2563eb" />
    </marker>
    <marker id="arrowhead-dark" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#1e293b" />
    </marker>
    <marker id="arrowhead-orange" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#f59e0b" />
    </marker>
    <filter id="shadow" x="-5%" y="-5%" width="115%" height="115%">
      <feDropShadow dx="0" dy="2" stdDeviation="3" flood-color="#000" flood-opacity="0.1"/>
    </filter>
  </defs>

  <!-- Array label -->
  <text x="20" y="28" class="diagram-text-code" font-size="14" font-weight="bold" fill="#2563eb">animal animals[3]</text>

  <!-- Index [0] -->
  <rect x="20" y="45" width="60" height="50" class="diagram-box" filter="url(#shadow)"/>
  <text x="50" y="75" text-anchor="middle" class="diagram-text-code" font-size="12" font-weight="bold">[0]</text>
  <line x1="80" y1="70" x2="160" y2="70" class="diagram-arrow" stroke-width="1.5" marker-end="url(#arrowhead)"/>

  <!-- animal object -->
  <rect x="164" y="45" width="140" height="50" class="diagram-box-gray" filter="url(#shadow)"/>
  <text x="234" y="65" text-anchor="middle" class="diagram-text-code" font-size="12">animal 객체</text>
  <text x="234" y="82" text-anchor="middle" class="diagram-text-small" font-size="10">speak()</text>
  <line x1="304" y1="70" x2="370" y2="70" class="diagram-arrow" stroke-width="1.5" marker-end="url(#arrowhead)"/>

  <!-- result [0] -->
  <rect x="374" y="50" width="220" height="40" class="diagram-box-gray"/>
  <text x="484" y="75" text-anchor="middle" class="diagram-text-code" font-size="12">"...(소리 없음)"</text>

  <!-- Index [1] -->
  <rect x="20" y="110" width="60" height="50" class="diagram-box" filter="url(#shadow)"/>
  <text x="50" y="140" text-anchor="middle" class="diagram-text-code" font-size="12" font-weight="bold">[1]</text>
  <line x1="80" y1="135" x2="160" y2="135" class="diagram-arrow-accent" stroke-width="1.5" marker-end="url(#arrowhead-accent)"/>

  <!-- dog object -->
  <rect x="164" y="110" width="140" height="50" class="diagram-box-green" filter="url(#shadow)"/>
  <text x="234" y="130" text-anchor="middle" class="diagram-text-code" font-size="12" font-weight="bold">dog 객체</text>
  <text x="234" y="147" text-anchor="middle" class="diagram-text-small" font-size="10">speak()</text>
  <line x1="304" y1="135" x2="370" y2="135" class="diagram-arrow-accent" stroke-width="1.5" marker-end="url(#arrowhead-accent)"/>

  <!-- result [1] -->
  <rect x="374" y="115" width="220" height="40" class="diagram-box-green"/>
  <text x="484" y="140" text-anchor="middle" class="diagram-text-code" font-size="13" font-weight="bold">"멍멍!"</text>
  <text x="620" y="140" text-anchor="middle" class="diagram-text-accent" font-size="11" font-weight="bold">virtual 덕분!</text>

  <!-- Index [2] -->
  <rect x="20" y="175" width="60" height="50" class="diagram-box" filter="url(#shadow)"/>
  <text x="50" y="205" text-anchor="middle" class="diagram-text-code" font-size="12" font-weight="bold">[2]</text>
  <line x1="80" y1="200" x2="160" y2="200" class="diagram-arrow-accent" stroke-width="1.5" marker-end="url(#arrowhead-accent)"/>

  <!-- cat object -->
  <rect x="164" y="175" width="140" height="50" class="diagram-box-purple" filter="url(#shadow)"/>
  <text x="234" y="195" text-anchor="middle" class="diagram-text-code" font-size="12" font-weight="bold">cat 객체</text>
  <text x="234" y="212" text-anchor="middle" class="diagram-text-small" font-size="10">speak()</text>
  <line x1="304" y1="200" x2="370" y2="200" class="diagram-arrow-accent" stroke-width="1.5" marker-end="url(#arrowhead-accent)"/>

  <!-- result [2] -->
  <rect x="374" y="180" width="220" height="40" class="diagram-box-purple"/>
  <text x="484" y="205" text-anchor="middle" class="diagram-text-code" font-size="13" font-weight="bold">"야옹!"</text>
  <text x="620" y="205" text-anchor="middle" class="diagram-text-accent" font-size="11" font-weight="bold">virtual 덕분!</text>

  <!-- Bottom note -->
  <text x="360" y="245" text-anchor="middle" class="diagram-text" font-size="12" font-style="italic">모두 animal 타입 변수이지만, 실제 객체에 맞는 함수가 호출됩니다</text>
</svg>
</div><blockquote>
<p><strong>UVM과의 연결</strong>: UVM은 내부적으로 <code>uvm_component</code> 타입의 배열에 다양한 자식 객체(test, env, driver 등)를 저장합니다. <code>virtual</code>이 있기 때문에 각 컴포넌트의 <code>build_phase()</code>, <code>run_phase()</code> 등이 올바르게 호출됩니다. Chapter 1-2에서 <code>virtual task run_phase</code>로 선언한 이유가 바로 이것입니다.</p>
</blockquote>
<h3 id="3-3-4-virtual-없이-실행하면">3.3.4 virtual 없이 실행하면?</h3>
<p><code>virtual</code>을 빼면 <strong>부모의 함수</strong>가 호출됩니다:</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// virtual 없는 경우</span>
<span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> speak();  <span class="hljs-comment">// virtual 키워드 없음</span>
  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;  %s: ...&quot;</span>, name);
<span class="hljs-keyword">endfunction</span>
</code></pre>
<div class="svg-diagram">
<svg viewBox="0 0 620 150" xmlns="http://www.w3.org/2000/svg" style="max-width:620px;width:100%">
  
  <style>
    .diagram-box { fill: #ffffff; stroke: #334155; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-accent { fill: #eff6ff; stroke: #2563eb; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-highlight { fill: #fef3c7; stroke: #f59e0b; stroke-width: 2.5; rx: 10; ry: 10; }
    .diagram-box-dark { fill: #1e293b; stroke: #1e293b; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-run { fill: #fef3c7; stroke: #f59e0b; stroke-width: 3; rx: 10; ry: 10; }
    .diagram-box-green { fill: #ecfdf5; stroke: #10b981; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-purple { fill: #f5f3ff; stroke: #7c3aed; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-red { fill: #fef2f2; stroke: #ef4444; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-gray { fill: #f8fafc; stroke: #94a3b8; stroke-width: 1.5; rx: 8; ry: 8; }
    .diagram-text { font-family: 'Noto Sans KR', sans-serif; fill: #1e293b; }
    .diagram-text-white { font-family: 'Noto Sans KR', sans-serif; fill: #ffffff; }
    .diagram-text-accent { font-family: 'Noto Sans KR', sans-serif; fill: #2563eb; }
    .diagram-text-small { font-family: 'Noto Sans KR', sans-serif; fill: #64748b; font-size: 12px; }
    .diagram-text-code { font-family: 'Fira Code', 'JetBrains Mono', monospace; fill: #1e293b; }
    .diagram-arrow { fill: none; stroke: #64748b; stroke-width: 1.5; }
    .diagram-arrow-accent { fill: none; stroke: #2563eb; stroke-width: 1.5; }
    .diagram-line { stroke: #cbd5e1; stroke-width: 1.5; stroke-dasharray: 6,3; }
  </style>
  <defs>
    <marker id="arrowhead" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#64748b" />
    </marker>
    <marker id="arrowhead-accent" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#2563eb" />
    </marker>
    <marker id="arrowhead-dark" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#1e293b" />
    </marker>
    <marker id="arrowhead-orange" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#f59e0b" />
    </marker>
    <filter id="shadow" x="-5%" y="-5%" width="115%" height="115%">
      <feDropShadow dx="0" dy="2" stdDeviation="3" flood-color="#000" flood-opacity="0.1"/>
    </filter>
  </defs>

  <!-- Title -->
  <rect x="10" y="6" width="160" height="26" rx="6" ry="6" fill="#fef2f2" stroke="#ef4444" stroke-width="1.5"/>
  <text x="90" y="24" text-anchor="middle" class="diagram-text" font-size="12" font-weight="bold" fill="#ef4444">virtual 없는 결과</text>

  <!-- Row 1: 동물 (expected) -->
  <rect x="10" y="40" width="160" height="30" class="diagram-box-gray" rx="6" ry="6"/>
  <text x="90" y="60" text-anchor="middle" class="diagram-text-code" font-size="11">동물: ...</text>
  <text x="186" y="60" class="diagram-text-small" font-size="10" fill="#64748b">정상</text>

  <!-- Row 2: 강아지 (wrong!) -->
  <rect x="10" y="76" width="160" height="30" rx="6" ry="6" fill="#fef2f2" stroke="#ef4444" stroke-width="1.5"/>
  <text x="90" y="96" text-anchor="middle" class="diagram-text-code" font-size="11" fill="#ef4444">강아지: ...</text>
  <text x="186" y="91" class="diagram-text" font-size="11" fill="#ef4444" font-weight="bold">✗</text>
  <text x="202" y="91" class="diagram-text-small" font-size="10" fill="#ef4444">멍멍! 대신 부모의 함수가 호출됨</text>

  <!-- Row 3: 고양이 (wrong!) -->
  <rect x="10" y="112" width="160" height="30" rx="6" ry="6" fill="#fef2f2" stroke="#ef4444" stroke-width="1.5"/>
  <text x="90" y="132" text-anchor="middle" class="diagram-text-code" font-size="11" fill="#ef4444">고양이: ...</text>
  <text x="186" y="127" class="diagram-text" font-size="11" fill="#ef4444" font-weight="bold">✗</text>
  <text x="202" y="127" class="diagram-text-small" font-size="10" fill="#ef4444">야옹! 대신 부모의 함수가 호출됨</text>
</svg>
</div><blockquote>
<p><strong>결론</strong>: UVM에서 모든 페이즈 함수에 <code>virtual</code>을 붙이는 이유는, 부모(uvm_test)가 아니라 <strong>우리가 작성한 자식 클래스의 함수</strong>가 호출되도록 하기 위해서입니다.</p>
</blockquote>
<blockquote>
<p><strong>미리보기</strong>: 부모 타입 변수에서 자식 타입의 고유 멤버에 접근하려면 <code>$cast</code>라는 형변환(타입 캐스팅)이 필요합니다. 이는 Chapter 6에서 시퀀스를 다룰 때 배웁니다.</p>
</blockquote>
<p>상속과 다형성을 이해했으니, 이제 하드웨어와 검증 코드를 연결하는 인터페이스를 배워봅시다.</p>
<hr>
<h2 id="3-4-인터페이스-interface">3.4 인터페이스(Interface)</h2>
<blockquote>
<p><strong>이 절의 목표</strong>: SystemVerilog 인터페이스의 역할을 이해하고, 신호를 묶어서 관리하는 방법을 익힙니다.</p>
</blockquote>
<h3 id="3-4-1-인터페이스가-필요한-이유">3.4.1 인터페이스가 필요한 이유</h3>
<p>DUT(설계)와 테스트벤치를 연결할 때, 신호를 하나하나 연결하면 번거롭습니다:</p>

<div class="svg-diagram">
<svg viewBox="0 0 720 220" xmlns="http://www.w3.org/2000/svg" style="max-width:720px;width:100%">
  
  <style>
    .diagram-box { fill: #ffffff; stroke: #334155; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-accent { fill: #eff6ff; stroke: #2563eb; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-highlight { fill: #fef3c7; stroke: #f59e0b; stroke-width: 2.5; rx: 10; ry: 10; }
    .diagram-box-dark { fill: #1e293b; stroke: #1e293b; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-run { fill: #fef3c7; stroke: #f59e0b; stroke-width: 3; rx: 10; ry: 10; }
    .diagram-box-green { fill: #ecfdf5; stroke: #10b981; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-purple { fill: #f5f3ff; stroke: #7c3aed; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-red { fill: #fef2f2; stroke: #ef4444; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-gray { fill: #f8fafc; stroke: #94a3b8; stroke-width: 1.5; rx: 8; ry: 8; }
    .diagram-text { font-family: 'Noto Sans KR', sans-serif; fill: #1e293b; }
    .diagram-text-white { font-family: 'Noto Sans KR', sans-serif; fill: #ffffff; }
    .diagram-text-accent { font-family: 'Noto Sans KR', sans-serif; fill: #2563eb; }
    .diagram-text-small { font-family: 'Noto Sans KR', sans-serif; fill: #64748b; font-size: 12px; }
    .diagram-text-code { font-family: 'Fira Code', 'JetBrains Mono', monospace; fill: #1e293b; }
    .diagram-arrow { fill: none; stroke: #64748b; stroke-width: 1.5; }
    .diagram-arrow-accent { fill: none; stroke: #2563eb; stroke-width: 1.5; }
    .diagram-line { stroke: #cbd5e1; stroke-width: 1.5; stroke-dasharray: 6,3; }
  </style>
  <defs>
    <marker id="arrowhead" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#64748b" />
    </marker>
    <marker id="arrowhead-accent" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#2563eb" />
    </marker>
    <marker id="arrowhead-dark" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#1e293b" />
    </marker>
    <marker id="arrowhead-orange" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#f59e0b" />
    </marker>
    <filter id="shadow" x="-5%" y="-5%" width="115%" height="115%">
      <feDropShadow dx="0" dy="2" stdDeviation="3" flood-color="#000" flood-opacity="0.1"/>
    </filter>
  </defs>

  <!-- Left: Traditional Verilog (bad) -->
  <rect x="15" y="10" width="310" height="200" class="diagram-box-red" filter="url(#shadow)"/>
  <rect x="15" y="10" width="310" height="30" rx="10" ry="10" fill="#ef4444"/>
  <rect x="15" y="28" width="310" height="12" fill="#ef4444"/>
  <text x="170" y="31" text-anchor="middle" class="diagram-text-white" font-size="13" font-weight="bold">전통적 방식 (Verilog)</text>

  <text x="35" y="64" class="diagram-text-code" font-size="11">wire clk, reset, valid;</text>
  <text x="35" y="84" class="diagram-text-code" font-size="11">wire ready;</text>
  <text x="35" y="104" class="diagram-text-code" font-size="11">wire [7:0] addr;</text>
  <text x="35" y="124" class="diagram-text-code" font-size="11">wire [31:0] data;</text>

  <line x1="35" y1="138" x2="295" y2="138" stroke="#fca5a5" stroke-width="1" stroke-dasharray="4,3"/>
  <text x="170" y="160" text-anchor="middle" class="diagram-text" font-size="12" fill="#ef4444" font-weight="bold">신호가 늘어나면 관리 불가!</text>
  <text x="170" y="180" text-anchor="middle" class="diagram-text" font-size="28" fill="#ef4444">✗</text>

  <!-- VS label -->
  <rect x="340" y="85" width="40" height="40" rx="20" ry="20" fill="#f59e0b" filter="url(#shadow)"/>
  <text x="360" y="111" text-anchor="middle" class="diagram-text-white" font-size="13" font-weight="bold">vs</text>

  <!-- Right: SystemVerilog Interface (good) -->
  <rect x="395" y="10" width="310" height="200" class="diagram-box-green" filter="url(#shadow)"/>
  <rect x="395" y="10" width="310" height="30" rx="10" ry="10" fill="#10b981"/>
  <rect x="395" y="28" width="310" height="12" fill="#10b981"/>
  <text x="550" y="31" text-anchor="middle" class="diagram-text-white" font-size="13" font-weight="bold">인터페이스 방식 (SystemVerilog)</text>

  <text x="415" y="70" class="diagram-text-code" font-size="12" font-weight="bold">simple_if bus_if(clk);</text>

  <line x1="415" y1="84" x2="675" y2="84" stroke="#86efac" stroke-width="1" stroke-dasharray="4,3"/>
  <text x="550" y="110" text-anchor="middle" class="diagram-text" font-size="12" fill="#10b981" font-weight="bold">관련 신호를 하나로 묶기!</text>

  <text x="550" y="152" text-anchor="middle" class="diagram-text" font-size="14" fill="#10b981" font-weight="bold">단 한 줄로 끝!</text>
  <text x="550" y="180" text-anchor="middle" class="diagram-text" font-size="28" fill="#10b981">✓</text>
</svg>
</div><blockquote>
<p><strong>비유</strong>: 인터페이스 = <strong>멀티탭</strong>. 전원 코드 10개를 하나하나 벽에 꽂는 대신, 멀티탭 하나에 모아서 관리하는 것과 같습니다.</p>
</blockquote>
<p>인터페이스가 DUT와 테스트벤치 사이에서 어떤 역할을 하는지 그림으로 봅시다:</p>

<div class="svg-diagram">
<svg viewBox="0 0 700 150" xmlns="http://www.w3.org/2000/svg" style="max-width:700px;width:100%">
  
  <style>
    .diagram-box { fill: #ffffff; stroke: #334155; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-accent { fill: #eff6ff; stroke: #2563eb; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-highlight { fill: #fef3c7; stroke: #f59e0b; stroke-width: 2.5; rx: 10; ry: 10; }
    .diagram-box-dark { fill: #1e293b; stroke: #1e293b; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-run { fill: #fef3c7; stroke: #f59e0b; stroke-width: 3; rx: 10; ry: 10; }
    .diagram-box-green { fill: #ecfdf5; stroke: #10b981; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-purple { fill: #f5f3ff; stroke: #7c3aed; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-red { fill: #fef2f2; stroke: #ef4444; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-gray { fill: #f8fafc; stroke: #94a3b8; stroke-width: 1.5; rx: 8; ry: 8; }
    .diagram-text { font-family: 'Noto Sans KR', sans-serif; fill: #1e293b; }
    .diagram-text-white { font-family: 'Noto Sans KR', sans-serif; fill: #ffffff; }
    .diagram-text-accent { font-family: 'Noto Sans KR', sans-serif; fill: #2563eb; }
    .diagram-text-small { font-family: 'Noto Sans KR', sans-serif; fill: #64748b; font-size: 12px; }
    .diagram-text-code { font-family: 'Fira Code', 'JetBrains Mono', monospace; fill: #1e293b; }
    .diagram-arrow { fill: none; stroke: #64748b; stroke-width: 1.5; }
    .diagram-arrow-accent { fill: none; stroke: #2563eb; stroke-width: 1.5; }
    .diagram-line { stroke: #cbd5e1; stroke-width: 1.5; stroke-dasharray: 6,3; }
  </style>
  <defs>
    <marker id="arrowhead" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#64748b" />
    </marker>
    <marker id="arrowhead-accent" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#2563eb" />
    </marker>
    <marker id="arrowhead-dark" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#1e293b" />
    </marker>
    <marker id="arrowhead-orange" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#f59e0b" />
    </marker>
    <filter id="shadow" x="-5%" y="-5%" width="115%" height="115%">
      <feDropShadow dx="0" dy="2" stdDeviation="3" flood-color="#000" flood-opacity="0.1"/>
    </filter>
  </defs>

  <!-- Testbench -->
  <rect x="20" y="20" width="180" height="100" class="diagram-box-accent" filter="url(#shadow)"/>
  <text x="110" y="50" text-anchor="middle" class="diagram-text" font-size="14" font-weight="bold">테스트벤치</text>
  <text x="110" y="70" text-anchor="middle" class="diagram-text-small" font-size="11">(class 기반)</text>
  <line x1="110" y1="78" x2="110" y2="82" stroke="#cbd5e1" stroke-width="1"/>
  <text x="110" y="98" text-anchor="middle" class="diagram-text-code" font-size="11">드라이버/모니터</text>

  <!-- Bidirectional arrow TB <-> IF -->
  <line x1="200" y1="65" x2="240" y2="65" stroke="#2563eb" stroke-width="1.5" marker-end="url(#arrowhead-accent)"/>
  <line x1="240" y1="75" x2="200" y2="75" stroke="#2563eb" stroke-width="1.5" marker-end="url(#arrowhead-accent)"/>
  <text x="220" y="56" text-anchor="middle" class="diagram-text-small" font-size="10">신호</text>
  <text x="220" y="92" text-anchor="middle" class="diagram-text-small" font-size="10">접근</text>

  <!-- Interface (center, highlighted) -->
  <rect x="244" y="10" width="210" height="120" class="diagram-box-highlight" filter="url(#shadow)"/>
  <text x="349" y="40" text-anchor="middle" class="diagram-text" font-size="14" font-weight="bold">인터페이스</text>
  <text x="349" y="58" text-anchor="middle" class="diagram-text-small" font-size="11">(interface)</text>
  <line x1="280" y1="66" x2="418" y2="66" stroke="#f59e0b" stroke-width="1" stroke-dasharray="4,3"/>
  <text x="349" y="84" text-anchor="middle" class="diagram-text-code" font-size="11">addr, data</text>
  <text x="349" y="102" text-anchor="middle" class="diagram-text-code" font-size="11">valid, ready</text>

  <!-- Bidirectional arrow IF <-> DUT -->
  <line x1="454" y1="65" x2="494" y2="65" stroke="#1e293b" stroke-width="1.5" marker-end="url(#arrowhead-dark)"/>
  <line x1="494" y1="75" x2="454" y2="75" stroke="#1e293b" stroke-width="1.5" marker-end="url(#arrowhead-dark)"/>
  <text x="474" y="56" text-anchor="middle" class="diagram-text-small" font-size="10">신호</text>
  <text x="474" y="92" text-anchor="middle" class="diagram-text-small" font-size="10">연결</text>

  <!-- DUT -->
  <rect x="498" y="20" width="180" height="100" class="diagram-box-gray" filter="url(#shadow)"/>
  <text x="588" y="55" text-anchor="middle" class="diagram-text" font-size="14" font-weight="bold">DUT</text>
  <text x="588" y="75" text-anchor="middle" class="diagram-text-small" font-size="11">(module)</text>
  <text x="588" y="100" text-anchor="middle" class="diagram-text-code" font-size="11">simple_dut</text>
</svg>
</div><h3 id="3-4-2-인터페이스-정의와-사용">3.4.2 인터페이스 정의와 사용</h3>
<p>예제 코드가 길어서, 3개 부분으로 나누어 설명합니다.</p>
<p><strong>[예제 3-4a] 인터페이스 정의</strong></p>
<p>먼저 관련 신호들을 하나로 묶는 인터페이스를 정의합니다:</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// 파일: testbench.sv (EDA Playground)</span>
<span class="hljs-comment">// [예제 3-4] SystemVerilog 인터페이스</span>
<span class="hljs-comment">// 목적: 인터페이스로 신호를 묶어서 관리하는 방법 이해</span>

<span class="hljs-comment">// ── 인터페이스 정의 ──</span>
<span class="hljs-comment">// 관련된 신호들을 하나로 묶습니다</span>
<span class="hljs-keyword">interface</span> simple_if(<span class="hljs-keyword">input</span> <span class="hljs-keyword">logic</span> clk);
  <span class="hljs-keyword">logic</span>       reset;
  <span class="hljs-keyword">logic</span>       valid;
  <span class="hljs-keyword">logic</span>       ready;
  <span class="hljs-keyword">logic</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] addr;
  <span class="hljs-keyword">logic</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] data;

  <span class="hljs-comment">// clocking block: 신호의 타이밍 규칙을 정의하는 블록입니다.</span>
  <span class="hljs-comment">// 드라이버(신호를 보내는 역할)는 output이 많고,</span>
  <span class="hljs-comment">// 모니터(신호를 관찰하는 역할)는 input만 있습니다.</span>
  <span class="hljs-comment">// 지금은 &quot;이런 게 있다&quot; 정도로 알아두세요.</span>
  <span class="hljs-comment">// Chapter 7에서 드라이버와 모니터를 구현할 때 자세히 배웁니다.</span>
  <span class="hljs-keyword">clocking</span> driver_cb @(<span class="hljs-keyword">posedge</span> clk);
    <span class="hljs-keyword">output</span> reset, valid, addr, data;
    <span class="hljs-keyword">input</span>  ready;
  <span class="hljs-keyword">endclocking</span>

  <span class="hljs-keyword">clocking</span> monitor_cb @(<span class="hljs-keyword">posedge</span> clk);
    <span class="hljs-keyword">input</span> reset, valid, ready, addr, data;
  <span class="hljs-keyword">endclocking</span>
<span class="hljs-keyword">endinterface</span>
</code></pre><blockquote>
<p><strong>참고</strong>: 위에서 <code>clocking block</code>을 정의했지만, 아래의 테스트벤치에서는 직접 신호를 구동합니다. clocking block을 통한 신호 구동(<code>bus_if.driver_cb.valid &lt;= 1;</code>)은 UVM 드라이버에서 주로 사용하며, Chapter 7에서 자세히 다룹니다. 지금은 clocking block의 <strong>존재</strong>를 알아두는 것으로 충분합니다.</p>
</blockquote>
<p><strong>[예제 3-4b] 간단한 DUT</strong></p>
<p>인터페이스와 연결할 간단한 DUT입니다. DUT 코드 자체를 외울 필요는 없습니다 — 인터페이스가 어떻게 연결되는지에 집중하세요:</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// ── 간단한 DUT (설계) ──</span>
<span class="hljs-comment">// 이 DUT의 동작: valid가 들어오면 ready를 1로 응답</span>
<span class="hljs-keyword">module</span> simple_dut(
  <span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span>        clk,
  <span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span>        reset,
  <span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span>        valid,
  <span class="hljs-keyword">output</span> <span class="hljs-keyword">logic</span>        ready,
  <span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]  addr,
  <span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] data
);
  <span class="hljs-keyword">always_ff</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (reset)
      ready &lt;= <span class="hljs-number">0</span>;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (valid)
      ready &lt;= <span class="hljs-number">1</span>;
    <span class="hljs-keyword">else</span>
      ready &lt;= <span class="hljs-number">0</span>;
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</code></pre><p><strong>[예제 3-4c] 테스트벤치 — 인터페이스를 통한 연결</strong></p>
<p>이제 인터페이스를 사용하여 DUT와 테스트벤치를 연결합니다:</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// ── 테스트벤치 ──</span>
<span class="hljs-keyword">module</span> top;
  <span class="hljs-keyword">logic</span> clk = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">always</span> #<span class="hljs-number">5</span> clk = ~clk;  <span class="hljs-comment">// 10ns 주기 클럭</span>

  <span class="hljs-comment">// 인터페이스 인스턴스 생성</span>
  simple_if bus_if(clk);

  <span class="hljs-comment">// DUT 연결 — 인터페이스의 신호를 꺼내서 연결</span>
  simple_dut dut(
    <span class="hljs-variable">.clk</span>   (clk),
    <span class="hljs-variable">.reset</span> (bus_if<span class="hljs-variable">.reset</span>),
    <span class="hljs-variable">.valid</span> (bus_if<span class="hljs-variable">.valid</span>),
    <span class="hljs-variable">.ready</span> (bus_if<span class="hljs-variable">.ready</span>),
    <span class="hljs-variable">.addr</span>  (bus_if<span class="hljs-variable">.addr</span>),
    <span class="hljs-variable">.data</span>  (bus_if<span class="hljs-variable">.data</span>)
  );

  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span>
    <span class="hljs-comment">// 리셋</span>
    bus_if<span class="hljs-variable">.reset</span> = <span class="hljs-number">1</span>;
    bus_if<span class="hljs-variable">.valid</span> = <span class="hljs-number">0</span>;
    bus_if<span class="hljs-variable">.addr</span>  = <span class="hljs-number">0</span>;
    bus_if<span class="hljs-variable">.data</span>  = <span class="hljs-number">0</span>;
    #<span class="hljs-number">20</span>;

    bus_if<span class="hljs-variable">.reset</span> = <span class="hljs-number">0</span>;
    #<span class="hljs-number">10</span>;

    <span class="hljs-comment">// 쓰기 요청</span>
    @(<span class="hljs-keyword">posedge</span> clk);
    bus_if<span class="hljs-variable">.valid</span> = <span class="hljs-number">1</span>;
    bus_if<span class="hljs-variable">.addr</span>  = <span class="hljs-number">8&#x27;h42</span>;
    bus_if<span class="hljs-variable">.data</span>  = <span class="hljs-number">32&#x27;hABCD_1234</span>;

    @(<span class="hljs-keyword">posedge</span> clk);
    bus_if<span class="hljs-variable">.valid</span> = <span class="hljs-number">0</span>;

    <span class="hljs-comment">// ready 확인</span>
    @(<span class="hljs-keyword">posedge</span> clk);
    <span class="hljs-keyword">if</span> (bus_if<span class="hljs-variable">.ready</span>)
      <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;SUCCESS: DUT가 ready를 응답했습니다!&quot;</span>);
    <span class="hljs-keyword">else</span>
      <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;FAIL: DUT가 응답하지 않았습니다.&quot;</span>);

    #<span class="hljs-number">50</span>;
    <span class="hljs-built_in">$finish</span>;
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</code></pre><blockquote>
<p><strong>실행 안내</strong>: 위의 3개 코드 블록(인터페이스 + DUT + 테스트벤치)을 모두 하나의 <code>testbench.sv</code> 파일에 순서대로 복사하여 실행하세요.</p>
</blockquote>
<p><strong>예상 출력</strong>:</p>
<pre><code>SUCCESS: DUT가 ready를 응답했습니다!
</code></pre><h3 id="3-4-3-인터페이스의-핵심-요소">3.4.3 인터페이스의 핵심 요소</h3>
<table>
<thead>
<tr>
<th>요소</th>
<th>역할</th>
<th>비유</th>
</tr>
</thead>
<tbody><tr>
<td>신호 선언 (<code>logic</code>)</td>
<td>관련 신호를 묶음</td>
<td>멀티탭의 각 콘센트</td>
</tr>
<tr>
<td><code>clocking block</code></td>
<td>타이밍 동기화 규칙 정의 (Chapter 7에서 상세 학습)</td>
<td>신호등 (언제 읽고 쓸지 규칙)</td>
</tr>
<tr>
<td>모드포트(modport) (이 예제에서는 생략)</td>
<td>방향 제한 — 드라이버는 출력만, 모니터는 입력만 접근하도록 제한 (Chapter 7에서 상세 학습)</td>
<td>입구/출구 구분</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>UVM과의 연결</strong>: Chapter 7에서 배울 드라이버(Driver)와 모니터(Monitor)는 **가상 인터페이스(Virtual Interface)**를 통해 이 인터페이스에 접근합니다. 구체적으로, 드라이버는 이 인터페이스를 통해 DUT에 신호를 보내고, 모니터는 DUT의 응답 신호를 관찰합니다. 지금은 &quot;인터페이스 = 신호 묶음&quot;이라는 것만 기억하세요.</p>
</blockquote>
<blockquote>
<p><strong>주의</strong>: 이 절에서 배운 <code>interface</code>는 SystemVerilog의 하드웨어 연결용 인터페이스입니다. UVM에서 나오는 &quot;virtual interface&quot;는 이 인터페이스를 <strong>클래스 안에서 참조하기 위한 기법</strong>으로, Chapter 7에서 자세히 다룹니다.</p>
</blockquote>
<blockquote>
<p><strong>실무 참고</strong>: 실무에서는 인터페이스(<code>simple_if.sv</code>), DUT(<code>simple_dut.sv</code>), 테스트벤치(<code>tb_top.sv</code>)를 별도 파일로 분리합니다. 이 예제에서는 EDA Playground 제약상 하나의 파일에 넣었습니다.</p>
</blockquote>
<p>인터페이스로 DUT와 테스트벤치의 연결 방법을 배웠습니다. 이제 UVM 검증의 핵심인 랜덤화를 알아봅시다.</p>
<hr>
<h2 id="3-5-랜덤화-randomization-와-제약-조건-constraint">3.5 랜덤화(Randomization)와 제약 조건(Constraint)</h2>
<blockquote>
<p><strong>이 절의 목표</strong>: rand 변수와 constraint를 사용하여 의미 있는 테스트 데이터를 자동 생성할 수 있게 됩니다.</p>
</blockquote>
<h3 id="3-5-1-왜-랜덤-테스트가-필요한가">3.5.1 왜 랜덤 테스트가 필요한가?</h3>
<p>Chapter 1에서 전통적 방식의 수동 테스트가 비효율적이라고 배웠습니다. 랜덤화를 쓰면:</p>

<div class="svg-diagram">
<svg viewBox="0 0 700 120" xmlns="http://www.w3.org/2000/svg" style="max-width:700px;width:100%">
  
  <style>
    .diagram-box { fill: #ffffff; stroke: #334155; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-accent { fill: #eff6ff; stroke: #2563eb; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-highlight { fill: #fef3c7; stroke: #f59e0b; stroke-width: 2.5; rx: 10; ry: 10; }
    .diagram-box-dark { fill: #1e293b; stroke: #1e293b; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-run { fill: #fef3c7; stroke: #f59e0b; stroke-width: 3; rx: 10; ry: 10; }
    .diagram-box-green { fill: #ecfdf5; stroke: #10b981; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-purple { fill: #f5f3ff; stroke: #7c3aed; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-red { fill: #fef2f2; stroke: #ef4444; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-gray { fill: #f8fafc; stroke: #94a3b8; stroke-width: 1.5; rx: 8; ry: 8; }
    .diagram-text { font-family: 'Noto Sans KR', sans-serif; fill: #1e293b; }
    .diagram-text-white { font-family: 'Noto Sans KR', sans-serif; fill: #ffffff; }
    .diagram-text-accent { font-family: 'Noto Sans KR', sans-serif; fill: #2563eb; }
    .diagram-text-small { font-family: 'Noto Sans KR', sans-serif; fill: #64748b; font-size: 12px; }
    .diagram-text-code { font-family: 'Fira Code', 'JetBrains Mono', monospace; fill: #1e293b; }
    .diagram-arrow { fill: none; stroke: #64748b; stroke-width: 1.5; }
    .diagram-arrow-accent { fill: none; stroke: #2563eb; stroke-width: 1.5; }
    .diagram-line { stroke: #cbd5e1; stroke-width: 1.5; stroke-dasharray: 6,3; }
  </style>
  <defs>
    <marker id="arrowhead" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#64748b" />
    </marker>
    <marker id="arrowhead-accent" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#2563eb" />
    </marker>
    <marker id="arrowhead-dark" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#1e293b" />
    </marker>
    <marker id="arrowhead-orange" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#f59e0b" />
    </marker>
    <filter id="shadow" x="-5%" y="-5%" width="115%" height="115%">
      <feDropShadow dx="0" dy="2" stdDeviation="3" flood-color="#000" flood-opacity="0.1"/>
    </filter>
  </defs>

  <!-- Manual test -->
  <rect x="15" y="10" width="320" height="44" class="diagram-box-gray" filter="url(#shadow)"/>
  <text x="30" y="28" class="diagram-text" font-size="11" fill="#ef4444" font-weight="bold">수동 테스트</text>
  <text x="30" y="44" class="diagram-text-code" font-size="11">addr=0x00, 0x01, 0x02, ...</text>
  <text x="345" y="37" text-anchor="start" class="diagram-text-small" font-size="11" fill="#ef4444">직접 100개 작성 😓</text>

  <!-- Random test -->
  <rect x="15" y="66" width="320" height="44" class="diagram-box-green" filter="url(#shadow)"/>
  <text x="30" y="84" class="diagram-text" font-size="11" fill="#10b981" font-weight="bold">랜덤 테스트</text>
  <text x="30" y="100" class="diagram-text-code" font-size="11">addr = random(0x00~0xFF)</text>
  <text x="345" y="93" text-anchor="start" class="diagram-text" font-size="11" fill="#10b981" font-weight="bold">자동으로 1000개 생성! 🚀</text>

  <!-- Comparison arrow -->
  <line x1="520" y1="32" x2="520" y2="66" stroke="#2563eb" stroke-width="1.5" marker-end="url(#arrowhead-accent)"/>
  <text x="570" y="55" text-anchor="middle" class="diagram-text-accent" font-size="11" font-weight="bold">10x 효율</text>
</svg>
</div><p>하지만 완전히 무작위로 값을 넣으면 <strong>의미 없는 테스트</strong>가 될 수 있습니다. 그래서 **제약 조건(Constraint)**으로 &quot;의미 있는 범위&quot;를 지정합니다:</p>

<div class="svg-diagram">
<svg viewBox="0 0 600 240" xmlns="http://www.w3.org/2000/svg" style="max-width:600px;width:100%">
  
  <style>
    .diagram-box { fill: #ffffff; stroke: #334155; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-accent { fill: #eff6ff; stroke: #2563eb; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-highlight { fill: #fef3c7; stroke: #f59e0b; stroke-width: 2.5; rx: 10; ry: 10; }
    .diagram-box-dark { fill: #1e293b; stroke: #1e293b; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-run { fill: #fef3c7; stroke: #f59e0b; stroke-width: 3; rx: 10; ry: 10; }
    .diagram-box-green { fill: #ecfdf5; stroke: #10b981; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-purple { fill: #f5f3ff; stroke: #7c3aed; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-red { fill: #fef2f2; stroke: #ef4444; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-gray { fill: #f8fafc; stroke: #94a3b8; stroke-width: 1.5; rx: 8; ry: 8; }
    .diagram-text { font-family: 'Noto Sans KR', sans-serif; fill: #1e293b; }
    .diagram-text-white { font-family: 'Noto Sans KR', sans-serif; fill: #ffffff; }
    .diagram-text-accent { font-family: 'Noto Sans KR', sans-serif; fill: #2563eb; }
    .diagram-text-small { font-family: 'Noto Sans KR', sans-serif; fill: #64748b; font-size: 12px; }
    .diagram-text-code { font-family: 'Fira Code', 'JetBrains Mono', monospace; fill: #1e293b; }
    .diagram-arrow { fill: none; stroke: #64748b; stroke-width: 1.5; }
    .diagram-arrow-accent { fill: none; stroke: #2563eb; stroke-width: 1.5; }
    .diagram-line { stroke: #cbd5e1; stroke-width: 1.5; stroke-dasharray: 6,3; }
  </style>
  <defs>
    <marker id="arrowhead" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#64748b" />
    </marker>
    <marker id="arrowhead-accent" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#2563eb" />
    </marker>
    <marker id="arrowhead-dark" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#1e293b" />
    </marker>
    <marker id="arrowhead-orange" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#f59e0b" />
    </marker>
    <filter id="shadow" x="-5%" y="-5%" width="115%" height="115%">
      <feDropShadow dx="0" dy="2" stdDeviation="3" flood-color="#000" flood-opacity="0.1"/>
    </filter>
  </defs>

  <!-- Outermost: All possible values -->
  <rect x="10" y="10" width="580" height="220" rx="12" ry="12" fill="#f8fafc" stroke="#94a3b8" stroke-width="2"/>
  <text x="30" y="36" class="diagram-text" font-size="13" font-weight="bold" fill="#64748b">전체 가능한 값</text>
  <text x="30" y="54" class="diagram-text-small" font-size="11">(32비트 = 약 40억개)</text>

  <!-- Middle: Constrained range -->
  <rect x="40" y="68" width="480" height="140" rx="10" ry="10" fill="#eff6ff" stroke="#2563eb" stroke-width="2"/>
  <text x="60" y="92" class="diagram-text-accent" font-size="13" font-weight="bold">제약 조건으로 좁힌 범위</text>

  <!-- Inner: Meaningful test data -->
  <rect x="70" y="104" width="380" height="88" rx="8" ry="8" fill="#ecfdf5" stroke="#10b981" stroke-width="2.5" filter="url(#shadow)"/>
  <text x="90" y="130" class="diagram-text" font-size="14" font-weight="bold" fill="#10b981">의미 있는 테스트 데이터</text>
  <text x="90" y="154" class="diagram-text-code" font-size="12">addr: 0x00 ~ 0xFF</text>
  <text x="90" y="176" class="diagram-text-code" font-size="12">4의 배수만</text>

  <!-- Arrow showing narrowing -->
  <path d="M 530 40 L 530 148 L 455 148" fill="none" stroke="#f59e0b" stroke-width="1.5" marker-end="url(#arrowhead)" stroke-dasharray="6,3"/>
  <text x="545" y="100" class="diagram-text" font-size="11" fill="#f59e0b" font-weight="bold" transform="rotate(90, 545, 100)">constraint로 범위 축소</text>
</svg>
</div><blockquote>
<p><strong>UVM과의 연결</strong>: UVM에서는 시퀀스(Sequence) 안에서 이 랜덤화를 활용하여 테스트 데이터를 자동 생성합니다. Chapter 6에서 시퀀스를, Chapter 9에서 실전 테스트 시나리오를 배웁니다.</p>
</blockquote>
<h3 id="3-5-2-rand와-constraint-기본">3.5.2 rand와 constraint 기본</h3>
<p>이 절에서 배우는 새 키워드가 많습니다. 먼저 핵심 3가지만 기억하세요:</p>
<ul>
<li><code>rand</code>: &quot;이 변수는 랜덤으로 생성하라&quot;</li>
<li><code>constraint</code>: &quot;이 규칙 안에서만 랜덤을 생성하라&quot;</li>
<li><code>randomize()</code>: &quot;지금 랜덤 값을 생성하라&quot;</li>
</ul>
<p><strong>[예제 3-5] 랜덤 패킷 생성</strong></p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// 파일: testbench.sv (EDA Playground)</span>
<span class="hljs-comment">// [예제 3-5] 랜덤화(Randomization) 실습</span>
<span class="hljs-comment">// 목적: rand, constraint, randomize() 사용법 이해</span>

<span class="hljs-keyword">module</span> top;

  <span class="hljs-keyword">class</span> rand_packet;
    <span class="hljs-comment">// rand: 이 변수는 랜덤으로 생성됨</span>
    <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]  addr;
    <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] data;
    <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span>        write;

    <span class="hljs-comment">// randc: 모든 값을 한 번씩 순회하는 순환 랜덤(Cyclic Random)</span>
    <span class="hljs-comment">// 예: 2비트이면 0,1,2,3을 한 번씩 다 돌고 나서 다시 반복</span>
    <span class="hljs-keyword">randc</span> <span class="hljs-keyword">bit</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] <span class="hljs-keyword">priority</span>;

    <span class="hljs-comment">// ── 제약 조건 ──</span>

    <span class="hljs-comment">// 주소 범위 제한</span>
    <span class="hljs-keyword">constraint</span> addr_range_c {
      addr <span class="hljs-keyword">inside</span> {[<span class="hljs-number">8&#x27;h00</span> : <span class="hljs-number">8&#x27;h3F</span>]};  <span class="hljs-comment">// 0~63 범위만 허용</span>
    }

    <span class="hljs-comment">// 데이터 정렬</span>
    <span class="hljs-keyword">constraint</span> data_align_c {
      data % <span class="hljs-number">4</span> == <span class="hljs-number">0</span>;  <span class="hljs-comment">// 4바이트 정렬</span>
    }

    <span class="hljs-comment">// 쓰기/읽기 비율 조정</span>
    <span class="hljs-keyword">constraint</span> write_bias_c {
      write <span class="hljs-keyword">dist</span> {<span class="hljs-number">1</span> := <span class="hljs-number">7</span>, <span class="hljs-number">0</span> := <span class="hljs-number">3</span>};  <span class="hljs-comment">// 쓰기 70%, 읽기 30%</span>
    }

    <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> display(<span class="hljs-keyword">int</span> num);
      <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;  [%0d] addr=0x%02h, data=0x%08h, %s, priority=%0d&quot;</span>,
               num, addr, data, write ? <span class="hljs-string">&quot;WR&quot;</span> : <span class="hljs-string">&quot;RD&quot;</span>, <span class="hljs-keyword">priority</span>);
    <span class="hljs-keyword">endfunction</span>
  <span class="hljs-keyword">endclass</span>

  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span>
    rand_packet pkt = <span class="hljs-keyword">new</span>();

    <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;=== 랜덤 패킷 10개 생성 ===&quot;</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++) <span class="hljs-keyword">begin</span>
      <span class="hljs-comment">// randomize(): 제약 조건 내에서 랜덤 값 생성</span>
      <span class="hljs-keyword">if</span> (!pkt<span class="hljs-variable">.randomize</span>())
        <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;ERROR: 랜덤화 실패!&quot;</span>);
      pkt<span class="hljs-variable">.display</span>(i);
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</code></pre><p><strong>예상 출력 (값은 매번 다름)</strong>:</p>
<pre><code>=== 랜덤 패킷 10개 생성 ===
  [1] addr=0x1a, data=0x0003f2c0, WR, priority=2
  [2] addr=0x2f, data=0x00a81b04, WR, priority=0
  [3] addr=0x05, data=0x004d6438, RD, priority=3
  [4] addr=0x3c, data=0x00c3f850, WR, priority=1
  [5] addr=0x12, data=0x00000210, WR, priority=2
  ...
</code></pre><blockquote>
<p><strong>확인해보세요</strong>: (1) addr가 모두 0x00<del>0x3F 범위인가? (2) data가 모두 4의 배수인가? (3) 쓰기가 약 70%인가? (4) priority가 0</del>3을 순회하는가?</p>
</blockquote>
<h3 id="3-5-3-중간-정리-랜덤화-핵심-키워드">3.5.3 중간 정리 — 랜덤화 핵심 키워드</h3>
<p>여기까지 배운 키워드를 정리합니다:</p>
<table>
<thead>
<tr>
<th>키워드</th>
<th>의미</th>
<th>예시</th>
</tr>
</thead>
<tbody><tr>
<td><code>rand</code></td>
<td>매번 독립적으로 랜덤 값 생성</td>
<td><code>rand bit [7:0] addr;</code></td>
</tr>
<tr>
<td><code>randc</code></td>
<td>가능한 모든 값을 한 번씩 순회 후 반복</td>
<td><code>randc bit [1:0] priority;</code></td>
</tr>
<tr>
<td><code>constraint</code></td>
<td>랜덤 값의 범위/규칙 정의</td>
<td><code>constraint c { addr &lt; 64; }</code></td>
</tr>
<tr>
<td><code>randomize()</code></td>
<td>제약 조건 내에서 랜덤 값 생성 (실행)</td>
<td><code>if (!pkt.randomize()) ...</code></td>
</tr>
</tbody></table>
<p>이 4가지가 핵심입니다. 아래에서 배울 <code>dist</code>, <code>inside</code>, <code>with</code>는 constraint를 더 세밀하게 제어하는 도구입니다.</p>
<h3 id="3-5-4-자주-쓰는-제약-조건-패턴">3.5.4 자주 쓰는 제약 조건 패턴</h3>
<table>
<thead>
<tr>
<th>패턴</th>
<th>코드</th>
<th>의미</th>
</tr>
</thead>
<tbody><tr>
<td>범위 지정</td>
<td><code>addr inside {[0:63]}</code></td>
<td>0~63 사이 값</td>
</tr>
<tr>
<td>특정 값 제외</td>
<td><code>!(addr inside {0, 255})</code></td>
<td>0과 255 제외</td>
</tr>
<tr>
<td>비율 조정</td>
<td><code>write dist {1:=7, 0:=3}</code></td>
<td>1이 70%, 0이 30%</td>
</tr>
<tr>
<td>조건부 제약</td>
<td><code>if (write) data &gt; 0;</code></td>
<td>쓰기 시 data &gt; 0</td>
</tr>
<tr>
<td>정렬</td>
<td><code>addr % 4 == 0</code></td>
<td>4의 배수만 허용</td>
</tr>
<tr>
<td>크기 제한</td>
<td><code>data &lt; 256</code></td>
<td>256 미만</td>
</tr>
</tbody></table>
<h3 id="3-5-5-inline-constraint-with절">3.5.5 inline constraint (with절)</h3>
<p>매번 클래스를 수정하지 않고, <strong>호출 시점에 추가 제약 조건</strong>을 넣을 수 있습니다:</p>
<blockquote>
<p>위 [예제 3-5]의 <code>initial begin</code> 블록에서, <code>pkt.randomize()</code> 호출을 아래처럼 바꿔보세요:</p>
</blockquote>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// 기존 제약 + 추가 제약</span>
pkt<span class="hljs-variable">.randomize</span>() <span class="hljs-keyword">with</span> { addr == <span class="hljs-number">8&#x27;h10</span>; };     <span class="hljs-comment">// addr를 0x10으로 고정</span>
pkt<span class="hljs-variable">.randomize</span>() <span class="hljs-keyword">with</span> { data &lt; <span class="hljs-number">100</span>; };         <span class="hljs-comment">// data를 100 미만으로 추가 제한</span>
pkt<span class="hljs-variable">.randomize</span>() <span class="hljs-keyword">with</span> { write == <span class="hljs-number">1</span>; };         <span class="hljs-comment">// 쓰기만 생성</span>
</code></pre><blockquote>
<p><strong>실무 팁</strong>: <code>with</code> 절은 테스트 시나리오마다 다른 조건을 적용할 때 매우 유용합니다. Chapter 9(테스트 시나리오)에서 실전 활용법을 배웁니다.</p>
</blockquote>
<h3 id="3-5-6-randomize-실패-처리">3.5.6 randomize() 실패 처리</h3>
<p>제약 조건이 서로 모순되면 <code>randomize()</code>가 실패합니다:</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-keyword">constraint</span> impossible_c {
  addr &gt; <span class="hljs-number">200</span>;      <span class="hljs-comment">// addr &gt; 200</span>
  addr &lt; <span class="hljs-number">100</span>;      <span class="hljs-comment">// addr &lt; 100  ← 동시에 만족 불가!</span>
}

<span class="hljs-keyword">if</span> (!pkt<span class="hljs-variable">.randomize</span>())
  <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;ERROR: 제약 조건 충돌! 랜덤화 실패&quot;</span>);
</code></pre><blockquote>
<p><strong>주의</strong>: <code>randomize()</code> 반환값을 항상 확인하세요. UVM에서는 실패 시 <code>`uvm_fatal</code>로 처리하는 것이 일반적입니다. 이 챕터에서는 UVM 매크로 없이 순수 SystemVerilog로 작성하므로 <code>if (!pkt.randomize())</code>로 체크합니다.</p>
</blockquote>
<p>랜덤화로 테스트 데이터를 자동 생성하는 방법을 배웠습니다. 마지막으로, 코드의 가독성을 높여주는 유용한 타입들을 알아봅시다.</p>
<hr>
<h2 id="3-6-열거형-enum-구조체-struct-타입-정의-typedef">3.6 열거형(Enum), 구조체(Struct), 타입 정의(Typedef)</h2>
<blockquote>
<p><strong>이 절의 목표</strong>: enum, struct, typedef를 사용하여 가독성 높은 코드를 작성할 수 있게 됩니다.</p>
</blockquote>
<h3 id="3-6-1-열거형-enum">3.6.1 열거형(Enum)</h3>
<p>숫자 대신 <strong>이름</strong>으로 상태를 표현합니다:</p>
<p><strong>[예제 3-6a] 열거형 기본 사용</strong></p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// 파일: testbench.sv (EDA Playground)</span>
<span class="hljs-comment">// [예제 3-6a] 열거형(Enum) 기본 사용</span>
<span class="hljs-comment">// 목적: enum 정의와 활용법 이해</span>

<span class="hljs-keyword">module</span> top;

  <span class="hljs-comment">// 열거형 정의</span>
  <span class="hljs-comment">// _e 접미사는 enum임을 표시하는 실무 관례</span>
  <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> <span class="hljs-keyword">bit</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] {
    CMD_READ  = <span class="hljs-number">2&#x27;b00</span>,
    CMD_WRITE = <span class="hljs-number">2&#x27;b01</span>,
    CMD_ERASE = <span class="hljs-number">2&#x27;b10</span>,
    CMD_IDLE  = <span class="hljs-number">2&#x27;b11</span>
  } cmd_type_e;

  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span>
    cmd_type_e cmd;

    cmd = CMD_WRITE;
    <span class="hljs-comment">// .name(): 열거형 값의 이름을 문자열로 반환하는 내장 메서드</span>
    <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;명령어: %s (값: %0b)&quot;</span>, cmd<span class="hljs-variable">.name</span>(), cmd);

    cmd = CMD_READ;
    <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;명령어: %s (값: %0b)&quot;</span>, cmd<span class="hljs-variable">.name</span>(), cmd);

    <span class="hljs-comment">// 숫자로 비교 (가독성 나쁨)</span>
    <span class="hljs-comment">// if (cmd == 2&#x27;b00) ...</span>
    <span class="hljs-comment">// 열거형으로 비교 (가독성 좋음)</span>
    <span class="hljs-keyword">if</span> (cmd == CMD_READ)
      <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;읽기 명령입니다!&quot;</span>);
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</code></pre><p><strong>예상 출력</strong>:</p>
<pre><code>명령어: CMD_WRITE (값: 01)
명령어: CMD_READ (값: 00)
읽기 명령입니다!
</code></pre><blockquote>
<p><strong>실무 관례</strong>: 열거형 이름은 <code>_e</code> 접미사, 열거 값은 대문자로 작성합니다. UVM 코드에서도 이 관례를 따릅니다. UVM에서는 상태 머신의 상태, 트랜잭션의 명령 종류 등을 enum으로 표현합니다.</p>
</blockquote>
<h3 id="3-6-2-구조체-struct-와-타입-정의-typedef">3.6.2 구조체(Struct)와 타입 정의(Typedef)</h3>
<p>관련된 데이터를 하나로 묶습니다:</p>
<p><strong>[예제 3-6b] 구조체 기본 사용</strong></p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// 파일: testbench.sv (EDA Playground)</span>
<span class="hljs-comment">// [예제 3-6b] 구조체(Struct) 기본 사용</span>
<span class="hljs-comment">// 목적: typedef struct 정의와 활용법 이해</span>

<span class="hljs-keyword">module</span> top;

  <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> <span class="hljs-keyword">bit</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] {
    CMD_READ  = <span class="hljs-number">2&#x27;b00</span>,
    CMD_WRITE = <span class="hljs-number">2&#x27;b01</span>,
    CMD_ERASE = <span class="hljs-number">2&#x27;b10</span>
  } cmd_type_e;

  <span class="hljs-comment">// typedef로 구조체 정의</span>
  <span class="hljs-comment">// packed: 비트를 연속으로 배치 (하드웨어 레벨에서 하나의 벡터처럼 동작)</span>
  <span class="hljs-comment">// 지금은 &quot;struct 앞에 packed를 관례적으로 붙인다&quot; 정도로 이해하면 됩니다</span>
  <span class="hljs-comment">// _t 접미사는 type임을 표시하는 실무 관례</span>
  <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-keyword">packed</span> {
    <span class="hljs-keyword">bit</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]  addr;
    <span class="hljs-keyword">bit</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] data;
    cmd_type_e cmd;
  } packet_t;

  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span>
    packet_t pkt;

    pkt<span class="hljs-variable">.addr</span> = <span class="hljs-number">8&#x27;h42</span>;
    pkt<span class="hljs-variable">.data</span> = <span class="hljs-number">32&#x27;hDEAD_BEEF</span>;
    pkt<span class="hljs-variable">.cmd</span>  = CMD_WRITE;

    <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;패킷: addr=0x%02h, data=0x%08h, cmd=%s&quot;</span>,
             pkt<span class="hljs-variable">.addr</span>, pkt<span class="hljs-variable">.data</span>, pkt<span class="hljs-variable">.cmd</span><span class="hljs-variable">.name</span>());
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</code></pre><p><strong>예상 출력</strong>:</p>
<pre><code>패킷: addr=0x42, data=0xdeadbeef, cmd=CMD_WRITE
</code></pre><blockquote>
<p><strong>class vs struct</strong>: <code>struct</code>는 단순한 데이터 묶음이고, <code>class</code>는 함수(메서드)와 상속이 가능합니다. UVM에서 컴포넌트와 트랜잭션은 <code>class</code>를 사용하고, 간단한 설정값이나 하드웨어 레벨 데이터는 <code>struct</code>를 사용합니다.</p>
</blockquote>
<h3 id="3-6-3-종합-실습-모든-개념-활용">3.6.3 종합 실습: 모든 개념 활용</h3>
<p>지금까지 배운 것을 한꺼번에 써봅시다. 처음에는 코드 전체를 이해하려 하지 말고, <strong>먼저 실행해서 출력을 확인한 다음</strong> 하나씩 분석해보세요.</p>
<p><strong>[예제 3-7] enum + constraint + 상속 종합 예제</strong></p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// 파일: testbench.sv (EDA Playground)</span>
<span class="hljs-comment">// [예제 3-7] Chapter 3 종합 실습</span>
<span class="hljs-comment">// 목적: enum, class, 상속, rand, constraint를 함께 활용</span>

<span class="hljs-keyword">module</span> top;

  <span class="hljs-comment">// ── 타입 정의 ──</span>
  <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> <span class="hljs-keyword">bit</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] {
    CMD_READ  = <span class="hljs-number">2&#x27;b00</span>,
    CMD_WRITE = <span class="hljs-number">2&#x27;b01</span>,
    CMD_ERASE = <span class="hljs-number">2&#x27;b10</span>
  } cmd_type_e;

  <span class="hljs-comment">// ── 기본 트랜잭션 클래스 ──</span>
  <span class="hljs-keyword">class</span> base_transaction;
    <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]   addr;
    <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>]  data;
    <span class="hljs-keyword">rand</span> cmd_type_e  cmd;

    <span class="hljs-keyword">constraint</span> addr_range_c {
      addr <span class="hljs-keyword">inside</span> {[<span class="hljs-number">0</span>:<span class="hljs-number">127</span>]};
    }

    <span class="hljs-keyword">constraint</span> cmd_dist_c {
      cmd <span class="hljs-keyword">dist</span> { CMD_READ := <span class="hljs-number">4</span>, CMD_WRITE := <span class="hljs-number">5</span>, CMD_ERASE := <span class="hljs-number">1</span> };
    }

    <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>();
    <span class="hljs-keyword">endfunction</span>

    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> display(<span class="hljs-keyword">string</span> prefix = <span class="hljs-string">&quot;&quot;</span>);
      <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;  %s[Base] cmd=%s, addr=0x%02h, data=0x%08h&quot;</span>,
               prefix, cmd<span class="hljs-variable">.name</span>(), addr, data);
    <span class="hljs-keyword">endfunction</span>
  <span class="hljs-keyword">endclass</span>

  <span class="hljs-comment">// ── 확장 트랜잭션: 에러 주입 기능 추가 ──</span>
  <span class="hljs-keyword">class</span> error_transaction <span class="hljs-keyword">extends</span> base_transaction;
    <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span> inject_error;    <span class="hljs-comment">// 에러 주입 여부</span>
    <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] error_type;  <span class="hljs-comment">// 에러 종류</span>

    <span class="hljs-keyword">constraint</span> error_rate_c {
      inject_error <span class="hljs-keyword">dist</span> { <span class="hljs-number">1</span> := <span class="hljs-number">1</span>, <span class="hljs-number">0</span> := <span class="hljs-number">9</span> };  <span class="hljs-comment">// 10% 확률로 에러 주입</span>
    }

    <span class="hljs-keyword">constraint</span> error_type_c {
      <span class="hljs-keyword">if</span> (!inject_error) error_type == <span class="hljs-number">0</span>;
      <span class="hljs-keyword">if</span> (inject_error) error_type <span class="hljs-keyword">inside</span> {[<span class="hljs-number">1</span>:<span class="hljs-number">5</span>]};
    }

    <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>();
      <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>();
    <span class="hljs-keyword">endfunction</span>

    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> display(<span class="hljs-keyword">string</span> prefix = <span class="hljs-string">&quot;&quot;</span>);
      <span class="hljs-keyword">string</span> err_str;
      <span class="hljs-comment">// $sformatf: C의 sprintf와 동일한 기능.</span>
      <span class="hljs-comment">// 포맷에 맞게 문자열을 만들어서 반환합니다.</span>
      err_str = inject_error ?
                <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;ERR_TYPE=%0d&quot;</span>, error_type) : <span class="hljs-string">&quot;OK&quot;</span>;
      <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;  %s[Error] cmd=%s, addr=0x%02h, data=0x%08h, status=%s&quot;</span>,
               prefix, cmd<span class="hljs-variable">.name</span>(), addr, data, err_str);
    <span class="hljs-keyword">endfunction</span>
  <span class="hljs-keyword">endclass</span>

  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span>
    <span class="hljs-comment">// 동적 큐(Queue): C++의 vector와 비슷한 가변 크기 배열.</span>
    <span class="hljs-comment">// [$]로 선언하며, push_back()으로 끝에 추가, pop_front()로 앞에서 제거.</span>
    <span class="hljs-comment">// 크기를 미리 정하지 않아도 됩니다.</span>
    base_transaction  base_q[$];
    error_transaction err_txn;

    <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;=== 에러 트랜잭션 10개 생성 ===&quot;</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) <span class="hljs-keyword">begin</span>
      <span class="hljs-comment">// ⚠️ 중요: 루프 안에서 매번 new()를 호출해야 합니다!</span>
      err_txn = <span class="hljs-keyword">new</span>();
      <span class="hljs-keyword">if</span> (!err_txn<span class="hljs-variable">.randomize</span>())
        <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;ERROR: 랜덤화 실패!&quot;</span>);

      err_txn<span class="hljs-variable">.display</span>(<span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;[%0d] &quot;</span>, i));

      <span class="hljs-comment">// 다형성: 부모 타입 큐에 자식 객체 저장 가능</span>
      base_q<span class="hljs-variable">.push_back</span>(err_txn);
    <span class="hljs-keyword">end</span>

    <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;\n=== 큐에서 다시 출력 (다형성) ===&quot;</span>);
    <span class="hljs-keyword">foreach</span> (base_q[i])
      base_q[i]<span class="hljs-variable">.display</span>(<span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;Q[%0d] &quot;</span>, i));
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</code></pre><blockquote>
<p><strong>주의: 초보자가 자주 하는 실수</strong>
위 코드에서 루프 안에 <code>err_txn = new();</code>가 있습니다. 만약 루프 <strong>밖</strong>에서 한 번만 <code>new()</code>를 호출하고, 루프 안에서 <code>randomize()</code>만 반복하면 어떻게 될까요?</p>
<p>3.2.4절에서 배운 핸들 개념을 떠올려보세요 — 큐에 같은 객체의 핸들(참조)만 쌓이게 되어, <strong>마지막 randomize() 결과만 모든 항목에 반영</strong>됩니다. 매 반복마다 <code>new()</code>로 새 객체를 만들어야 각각 독립적인 데이터를 가집니다.</p>
</blockquote>
<p><strong>예상 출력 (값은 매번 다름)</strong>:</p>
<pre><code>=== 에러 트랜잭션 10개 생성 ===
  [0] [Error] cmd=CMD_WRITE, addr=0x2a, data=0x1f3c8800, status=OK
  [1] [Error] cmd=CMD_READ, addr=0x51, data=0x00a8b0c4, status=OK
  [2] [Error] cmd=CMD_WRITE, addr=0x17, data=0x4d640000, status=ERR_TYPE=3
  ...

=== 큐에서 다시 출력 (다형성) ===
  Q[0] [Error] cmd=CMD_WRITE, addr=0x2a, data=0x1f3c8800, status=OK
  ...
</code></pre><blockquote>
<p><strong>관찰 포인트</strong>: (1) 큐에서 꺼낸 객체가 <code>[Error]</code>로 출력됩니다 — 다형성 덕분에 자식의 display()가 호출됨! (2) 에러 주입은 약 10%만 발생 (3) cmd 분포가 READ:WRITE:ERASE 약 4:5:1</p>
</blockquote>
<hr>
<h2 id="3-7-체크포인트">3.7 체크포인트</h2>
<h3 id="셀프-체크">셀프 체크</h3>
<p>아래 질문에 답할 수 있다면 이 챕터를 충분히 이해한 것입니다:</p>
<ol>
<li>SystemVerilog <code>class</code>와 Verilog <code>module</code>의 가장 큰 차이점은?</li>
</ol>
<details>
<summary>정답 확인</summary>

<p>class는 상속(extends)이 가능하고, 실행 중 동적으로 객체를 생성(new)할 수 있습니다. module은 컴파일 시 인스턴스가 고정됩니다. UVM의 검증 코드는 class로, DUT는 module로 작성합니다.</p>
</details>

<ol start="2">
<li><code>virtual</code> 키워드를 함수에 붙이는 이유는?</li>
</ol>
<details>
<summary>정답 확인</summary>

<p>다형성(Polymorphism)을 위해서입니다. 부모 타입 변수에 자식 객체를 담았을 때, virtual이 있으면 자식의 함수가 호출됩니다. UVM에서 모든 페이즈 함수에 virtual을 붙이는 이유입니다.</p>
</details>

<ol start="3">
<li><code>rand</code>와 <code>randc</code>의 차이점은?</li>
</ol>
<details>
<summary>정답 확인</summary>

<p>rand는 매번 독립적으로 랜덤 값을 생성합니다. randc(순환 랜덤, Cyclic Random)는 가능한 모든 값을 한 번씩 순회한 후 반복합니다. 예를 들어 2비트 randc 변수는 0,1,2,3을 모두 한 번씩 생성한 후 다시 순회합니다.</p>
</details>

<ol start="4">
<li><code>constraint</code>에서 <code>dist</code> 키워드의 역할은?</li>
</ol>
<details>
<summary>정답 확인</summary>

<p>dist는 분포(distribution)를 지정합니다. <code>write dist {1:=7, 0:=3}</code>은 1이 될 확률 가중치 7, 0이 될 확률 가중치 3으로, 약 70% 확률로 1이 생성됩니다.</p>
</details>

<ol start="5">
<li>SystemVerilog <code>interface</code>의 역할은?</li>
</ol>
<details>
<summary>정답 확인</summary>

<p>관련된 신호들을 하나로 묶어서 관리합니다. DUT와 테스트벤치 사이의 연결을 깔끔하게 해줍니다. 멀티탭처럼, 여러 신호를 하나의 bundle로 관리할 수 있습니다.</p>
</details>

<ol start="6">
<li><code>pkt2 = pkt1;</code>을 실행하면 어떤 일이 발생하는가?</li>
</ol>
<details>
<summary>정답 확인</summary>

<p>객체가 복사되는 것이 아니라, pkt2가 pkt1과 같은 객체를 가리키게 됩니다(핸들 복사). 따라서 pkt1을 통해 데이터를 바꾸면 pkt2로 접근해도 바뀐 값이 보입니다. 독립적인 복사를 하려면 copy() 메서드가 필요합니다.</p>
</details>

<h3 id="연습문제">연습문제</h3>
<p><strong>[실습 3-1] 패킷 클래스 확장하기 (쉬움)</strong> — 약 10분</p>
<p>[예제 3-1]의 <code>packet</code> 클래스에 <code>priority</code>(2비트) 멤버 변수를 추가하고, <code>display()</code> 함수에서 함께 출력하세요.</p>
<details>
<summary>힌트</summary>

<p>클래스 안에 <code>bit [1:0] priority;</code>를 추가하고, 생성자와 display 함수를 수정하면 됩니다.</p>
</details>

<details>
<summary>모범 답안</summary>

<pre><code class="hljs language-systemverilog"><span class="hljs-keyword">module</span> top;
  <span class="hljs-keyword">class</span> packet;
    <span class="hljs-keyword">bit</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>]  addr;
    <span class="hljs-keyword">bit</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] data;
    <span class="hljs-keyword">bit</span>        write;
    <span class="hljs-keyword">bit</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>]  <span class="hljs-keyword">priority</span>;  <span class="hljs-comment">// 추가된 필드</span>

    <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">bit</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] addr, <span class="hljs-keyword">bit</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] data, <span class="hljs-keyword">bit</span> write, <span class="hljs-keyword">bit</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] <span class="hljs-keyword">priority</span>);
      <span class="hljs-keyword">this</span><span class="hljs-variable">.addr</span>     = addr;
      <span class="hljs-keyword">this</span><span class="hljs-variable">.data</span>     = data;
      <span class="hljs-keyword">this</span><span class="hljs-variable">.write</span>    = write;
      <span class="hljs-keyword">this</span><span class="hljs-variable">.priority</span> = <span class="hljs-keyword">priority</span>;
    <span class="hljs-keyword">endfunction</span>

    <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> display();
      <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;  Packet: addr=0x%02h, data=0x%08h, %s, priority=%0d&quot;</span>,
               addr, data, write ? <span class="hljs-string">&quot;WRITE&quot;</span> : <span class="hljs-string">&quot;READ&quot;</span>, <span class="hljs-keyword">priority</span>);
    <span class="hljs-keyword">endfunction</span>
  <span class="hljs-keyword">endclass</span>

  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span>
    packet pkt1, pkt2;
    pkt1 = <span class="hljs-keyword">new</span>(<span class="hljs-number">8&#x27;h10</span>, <span class="hljs-number">32&#x27;hDEAD_BEEF</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2&#x27;b11</span>);  <span class="hljs-comment">// 높은 우선순위</span>
    pkt2 = <span class="hljs-keyword">new</span>(<span class="hljs-number">8&#x27;h20</span>, <span class="hljs-number">32&#x27;hCAFE_0000</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2&#x27;b00</span>);  <span class="hljs-comment">// 낮은 우선순위</span>

    <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;=== 패킷 출력 ===&quot;</span>);
    pkt1<span class="hljs-variable">.display</span>();
    pkt2<span class="hljs-variable">.display</span>();
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</code></pre></details>

<p><strong>[실습 3-2] 버스트 패킷 만들기 (보통)</strong> — 약 20분</p>
<p><code>rand_packet</code> 클래스([예제 3-5])를 상속받아 <code>burst_packet</code> 클래스를 만드세요. <code>rand bit [3:0] burst_length;</code> (1~8 범위)와 <code>rand bit [1:0] burst_type;</code> (0: FIXED, 1: INCR, 2: WRAP)을 추가하세요.</p>
<details>
<summary>힌트</summary>

<p><code>class burst_packet extends rand_packet;</code>으로 시작하고, burst_length의 제약 조건은 <code>burst_length inside {[1:8]};</code>로 작성합니다.</p>
</details>

<details>
<summary>모범 답안</summary>

<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// [예제 3-5]의 rand_packet 클래스 아래에 추가</span>

<span class="hljs-keyword">class</span> burst_packet <span class="hljs-keyword">extends</span> rand_packet;
  <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] burst_length;
  <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] burst_type;  <span class="hljs-comment">// 0: FIXED, 1: INCR, 2: WRAP</span>

  <span class="hljs-keyword">constraint</span> burst_length_c {
    burst_length <span class="hljs-keyword">inside</span> {[<span class="hljs-number">1</span>:<span class="hljs-number">8</span>]};
  }

  <span class="hljs-keyword">constraint</span> burst_type_c {
    burst_type <span class="hljs-keyword">inside</span> {[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>]};
  }

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> display(<span class="hljs-keyword">int</span> num);
    <span class="hljs-keyword">string</span> type_str;
    <span class="hljs-keyword">case</span> (burst_type)
      <span class="hljs-number">0</span>: type_str = <span class="hljs-string">&quot;FIXED&quot;</span>;
      <span class="hljs-number">1</span>: type_str = <span class="hljs-string">&quot;INCR&quot;</span>;
      <span class="hljs-number">2</span>: type_str = <span class="hljs-string">&quot;WRAP&quot;</span>;
      <span class="hljs-keyword">default</span>: type_str = <span class="hljs-string">&quot;UNKNOWN&quot;</span>;
    <span class="hljs-keyword">endcase</span>
    <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;  [%0d] addr=0x%02h, data=0x%08h, %s, burst=%s(len=%0d)&quot;</span>,
             num, addr, data, write ? <span class="hljs-string">&quot;WR&quot;</span> : <span class="hljs-string">&quot;RD&quot;</span>, type_str, burst_length);
  <span class="hljs-keyword">endfunction</span>
<span class="hljs-keyword">endclass</span>
</code></pre></details>

<p><strong>[실습 3-3] 조건부 제약 도전 (도전)</strong> — 약 30분</p>
<p><code>burst_packet</code>에 <code>constraint</code> 하나를 추가하세요: &quot;burst_type이 WRAP(2)일 때, burst_length는 2, 4, 8 중 하나여야 한다.&quot; <code>randomize() with</code> 절을 사용하여 WRAP 타입만 생성되도록 테스트하세요.</p>
<details>
<summary>힌트</summary>

<p>조건부 제약 조건: <code>if (burst_type == 2) burst_length inside {2, 4, 8};</code>. with 절: <code>pkt.randomize() with { burst_type == 2; };</code></p>
</details>

<details>
<summary>모범 답안</summary>

<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// burst_packet 클래스에 추가할 제약 조건:</span>
<span class="hljs-keyword">constraint</span> wrap_length_c {
  <span class="hljs-keyword">if</span> (burst_type == <span class="hljs-number">2</span>) burst_length <span class="hljs-keyword">inside</span> {<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>};
}

<span class="hljs-comment">// 테스트 코드 (initial begin 블록에 추가):</span>
burst_packet bpkt = <span class="hljs-keyword">new</span>();
<span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;=== WRAP 버스트만 생성 ===&quot;</span>);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) <span class="hljs-keyword">begin</span>
  <span class="hljs-keyword">if</span> (!bpkt<span class="hljs-variable">.randomize</span>() <span class="hljs-keyword">with</span> { burst_type == <span class="hljs-number">2</span>; })
    <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;ERROR: 랜덤화 실패!&quot;</span>);
  bpkt<span class="hljs-variable">.display</span>(i);
  <span class="hljs-comment">// burst_length가 2, 4, 8 중 하나인지 확인하세요!</span>
<span class="hljs-keyword">end</span>
</code></pre></details>

<h3 id="흔한-컴파일-에러">흔한 컴파일 에러</h3>
<p>코드를 입력하다가 이런 에러가 발생하면:</p>
<table>
<thead>
<tr>
<th>에러 메시지</th>
<th>원인</th>
<th>해결</th>
</tr>
</thead>
<tbody><tr>
<td><code>near &quot;endmodule&quot;: syntax error</code></td>
<td><code>endclass</code>를 빠뜨림</td>
<td>모든 class는 <code>endclass</code>로 닫기</td>
</tr>
<tr>
<td><code>near &quot;extends&quot;: syntax error</code></td>
<td><code>extends</code> 오타 또는 부모 클래스명 오타</td>
<td>철자 확인</td>
</tr>
<tr>
<td><code>null object access</code></td>
<td><code>new()</code> 없이 메서드 호출</td>
<td>객체 생성 후 사용</td>
</tr>
</tbody></table>
<h3 id="용어-정리">용어 정리</h3>
<table>
<thead>
<tr>
<th>한글 용어</th>
<th>영어</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>클래스</td>
<td>Class</td>
<td>데이터와 함수를 묶은 설계도</td>
</tr>
<tr>
<td>객체</td>
<td>Object</td>
<td>클래스로부터 생성된 실체</td>
</tr>
<tr>
<td>핸들</td>
<td>Handle</td>
<td>객체를 가리키는 참조 (C++ 포인터와 유사)</td>
</tr>
<tr>
<td>상속</td>
<td>Inheritance</td>
<td>부모 클래스의 기능을 물려받는 것</td>
</tr>
<tr>
<td>다형성</td>
<td>Polymorphism</td>
<td>부모 타입으로 자식 객체를 다룰 수 있는 성질</td>
</tr>
<tr>
<td>인터페이스</td>
<td>Interface</td>
<td>관련 신호를 묶어서 관리하는 구조</td>
</tr>
<tr>
<td>랜덤화</td>
<td>Randomization</td>
<td>변수 값을 자동으로 랜덤 생성</td>
</tr>
<tr>
<td>순환 랜덤</td>
<td>Cyclic Random</td>
<td>모든 값을 한 번씩 순회 후 반복하는 랜덤</td>
</tr>
<tr>
<td>제약 조건</td>
<td>Constraint</td>
<td>랜덤 값의 범위/규칙을 정의</td>
</tr>
<tr>
<td>열거형</td>
<td>Enum</td>
<td>이름으로 상태를 표현하는 타입</td>
</tr>
<tr>
<td>구조체</td>
<td>Struct</td>
<td>관련 데이터를 하나로 묶은 타입</td>
</tr>
<tr>
<td>타입 정의</td>
<td>Typedef</td>
<td>사용자 정의 타입 이름 부여</td>
</tr>
<tr>
<td>동적 큐</td>
<td>Queue</td>
<td>가변 크기 배열 (<code>[$]</code>로 선언)</td>
</tr>
</tbody></table>
<h3 id="다음-챕터-미리보기">다음 챕터 미리보기</h3>
<blockquote>
<p>Chapter 4에서는 다음 내용을 학습합니다:</p>
<ul>
<li><code>uvm_component</code>와 <code>uvm_object</code>의 차이</li>
<li>팩토리(Factory) 패턴의 동작 원리 — <code>new()</code> 대신 <code>type_id::create()</code>를 쓰는 이유</li>
<li>페이즈(Phase) 메커니즘 심화 — <code>build_phase</code>, <code>connect_phase</code>, <code>run_phase</code>의 실행 순서</li>
</ul>
<p>이 챕터에서 배운 클래스, 상속, 다형성이 Chapter 4의 핵심 기반입니다.</p>
</blockquote>

    <nav class="chapter-nav"><a href="chapter-02-final.html" class="nav-prev">
      <span class="nav-label">이전 챕터</span>
      <span class="nav-title">Ch.2 환경 설정</span>
    </a><a href="chapter-04-final.html" class="nav-next">
      <span class="nav-label">다음 챕터</span>
      <span class="nav-title">Ch.4 UVM 기본 컴포넌트</span>
    </a></nav>
  </div>

  <footer class="book-footer">
    <p>팹리스 검증 엔지니어가 되기 위한 UVM 완전정복</p>
    <p>Published by UVM Book Publisher Agent</p>
  </footer>

  <!-- Back to Top Button -->
  <button class="back-to-top" id="backToTop" onclick="window.scrollTo({top:0,behavior:'smooth'})">↑</button>

  <script>
    // Reading progress bar
    window.addEventListener('scroll', () => {
      const h = document.documentElement;
      const pct = (h.scrollTop / (h.scrollHeight - h.clientHeight)) * 100;
      document.getElementById('progressBar').style.width = pct + '%';
      document.getElementById('backToTop').classList.toggle('visible', h.scrollTop > 400);
    });

    // Language labels for code blocks
    document.querySelectorAll('pre').forEach(pre => {
      const code = pre.querySelector('code');
      if (code) {
        const cls = code.className || '';
        const m = cls.match(/language-(\w+)/);
        if (m) {
          const map = {
            systemverilog:'SystemVerilog', sv:'SystemVerilog', verilog:'Verilog',
            bash:'Bash', shell:'Shell', tcl:'TCL', makefile:'Makefile',
            python:'Python', javascript:'JavaScript', text:'Output'
          };
          pre.setAttribute('data-lang', map[m[1]] || m[1]);
        }
      }
    });

    // Smart labels for plain code blocks
    document.querySelectorAll('pre code:not([class*="language-"])').forEach(code => {
      const pre = code.parentElement;
      if (!pre.getAttribute('data-lang')) {
        const t = code.textContent || '';
        if (t.includes('UVM_INFO') || t.includes('UVM_WARNING')) {
          pre.setAttribute('data-lang', 'Simulation Output');
        } else if (t.includes('[채용') || t.includes('필수 자격')) {
          pre.setAttribute('data-lang', '');
        } else if (t.includes('Step') || t.includes('패널') || t.includes('편집기')) {
          pre.setAttribute('data-lang', 'Setup Guide');
        } else {
          pre.setAttribute('data-lang', 'Info');
        }
      }
    });

    // Smooth scroll for TOC links
    document.querySelectorAll('.toc a').forEach(a => {
      a.addEventListener('click', e => {
        e.preventDefault();
        const id = a.getAttribute('href').slice(1);
        const target = document.getElementById(id);
        if (target) target.scrollIntoView({ behavior: 'smooth', block: 'start' });
      });
    });
  </script>
</body>
</html>