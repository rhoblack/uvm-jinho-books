<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chapter 6: 시퀀스 & 시퀀서 | 팹리스 검증 엔지니어가 되기 위한 UVM 완전정복</title>
  <style>
    /* =============================================
       UVM Book Publisher - Stylesheet
       Generated by Publisher Agent
       ============================================= */

    @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;600;700&display=swap');

    :root {
      --bg: #ffffff;
      --text: #1a1a2e;
      --accent: #10b981;
      --accent-light: #10b98118;
      --code-bg: #1e1e2e;
      --code-text: #cdd6f4;
      --border: #e2e8f0;
      --blockquote-bg: #f0f9ff;
      --blockquote-border: #3b82f6;
      --table-header: #1e293b;
      --table-stripe: #f8fafc;
      --warning-bg: #fef3c7;
      --warning-border: #f59e0b;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: 'Noto Sans KR', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      line-height: 1.85;
      color: var(--text);
      background: var(--bg);
      font-size: 16px;
    }

    /* === Reading Progress Bar === */
    .progress-bar {
      position: fixed;
      top: 0;
      left: 0;
      width: 0%;
      height: 3px;
      background: linear-gradient(90deg, var(--accent), #10b981cc);
      z-index: 9999;
      transition: width 0.1s;
    }

    /* === Cover Header === */
    .cover-header {
      background: linear-gradient(135deg, #10b98108, #10b98115);
      border-bottom: 3px solid var(--accent);
      padding: 32px 24px 24px;
      text-align: center;
      margin-bottom: 0;
    }
    .cover-part {
      display: inline-block;
      background: var(--accent);
      color: white;
      padding: 4px 16px;
      border-radius: 20px;
      font-size: 0.85em;
      font-weight: 600;
      letter-spacing: 0.5px;
      margin-bottom: 12px;
    }
    .cover-chapter-num {
      font-size: 2em;
      font-weight: 300;
      color: var(--accent);
      letter-spacing: 2px;
      opacity: 0.6;
    }

    /* === Main Content === */
    .content {
      max-width: 860px;
      margin: 0 auto;
      padding: 32px 24px 60px;
    }

    /* === TOC === */
    .toc {
      background: #f8fafc;
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 20px 28px;
      margin: 24px 0 32px;
    }
    .toc-title {
      font-size: 1.1em;
      color: var(--accent);
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 2px solid var(--border);
    }
    .toc ul { list-style: none; padding: 0; }
    .toc li { margin: 6px 0; }
    .toc li a {
      color: var(--text);
      text-decoration: none;
      font-weight: 500;
      font-size: 0.95em;
      padding: 4px 8px;
      border-radius: 4px;
      display: inline-block;
      transition: background 0.15s;
    }
    .toc li a:hover {
      background: var(--accent-light);
      color: var(--accent);
    }
    .toc li.toc-sub { padding-left: 24px; }
    .toc li.toc-sub a {
      font-weight: 400;
      font-size: 0.9em;
      color: #475569;
    }

    /* === Headings === */
    h1 {
      font-size: 2em;
      border-bottom: 3px solid var(--accent);
      padding-bottom: 12px;
      margin: 40px 0 20px;
      color: var(--text);
    }
    h1:first-child { margin-top: 0; }
    h2 {
      font-size: 1.5em;
      color: var(--accent);
      margin: 40px 0 16px;
      padding-bottom: 8px;
      border-bottom: 2px solid var(--border);
      scroll-margin-top: 16px;
    }
    h3 {
      font-size: 1.25em;
      margin: 28px 0 12px;
      color: #334155;
      scroll-margin-top: 16px;
    }
    h4 { font-size: 1.05em; margin: 20px 0 8px; color: #475569; }
    p { margin: 12px 0; }
    a { color: var(--accent); text-decoration: none; }
    a:hover { text-decoration: underline; }
    hr { border: none; border-top: 2px solid var(--border); margin: 32px 0; }
    strong { color: #1e293b; }
    img { max-width: 100%; border-radius: 8px; margin: 16px 0; }

    /* === Code Blocks === */
    pre {
      position: relative;
      background: var(--code-bg);
      border-radius: 12px;
      padding: 0;
      margin: 20px 0;
      overflow: hidden;
      box-shadow: 0 4px 16px rgba(0,0,0,0.12), 0 1px 4px rgba(0,0,0,0.08);
      border: 1px solid #313244;
    }
    pre::before {
      content: attr(data-lang);
      display: block;
      background: #313244;
      color: #a6adc8;
      padding: 8px 16px;
      font-size: 0.8em;
      font-family: 'Fira Code','JetBrains Mono',monospace;
      letter-spacing: 0.5px;
      border-bottom: 1px solid #45475a;
    }
    pre code {
      display: block;
      padding: 16px 20px;
      overflow-x: auto;
      font-family: 'Fira Code','JetBrains Mono','Cascadia Code','D2Coding',monospace;
      font-size: 0.88em;
      line-height: 1.75;
      tab-size: 4;
      color: var(--code-text);
    }
    pre code::-webkit-scrollbar { height: 6px; }
    pre code::-webkit-scrollbar-track { background: #1e1e2e; }
    pre code::-webkit-scrollbar-thumb { background: #45475a; border-radius: 3px; }

    code:not(pre code) {
      background: #f1f5f9;
      color: #be185d;
      padding: 2px 7px;
      border-radius: 5px;
      font-family: 'Fira Code','JetBrains Mono','D2Coding',monospace;
      font-size: 0.86em;
      border: 1px solid #e2e8f0;
    }

    /* Highlight.js Catppuccin */
    .hljs { background: transparent; color: #cdd6f4; }
    .hljs-keyword { color: #cba6f7; font-weight: bold; }
    .hljs-type { color: #f9e2af; }
    .hljs-string { color: #a6e3a1; }
    .hljs-number { color: #fab387; }
    .hljs-comment { color: #6c7086; font-style: italic; }
    .hljs-function, .hljs-title { color: #89b4fa; }
    .hljs-built_in { color: #f38ba8; }
    .hljs-variable { color: #cdd6f4; }
    .hljs-attr { color: #89dceb; }
    .hljs-meta { color: #f5c2e7; }
    .hljs-literal { color: #fab387; }

    /* === SVG Diagrams === */
    .svg-diagram {
      margin: 24px 0;
      padding: 20px;
      background: #fafbfc;
      border: 1px solid var(--border);
      border-radius: 12px;
      text-align: center;
      overflow-x: auto;
    }
    .svg-diagram svg { display: inline-block; }

    /* === Blockquotes === */
    blockquote {
      background: var(--blockquote-bg);
      border-left: 4px solid var(--blockquote-border);
      padding: 16px 20px;
      margin: 16px 0;
      border-radius: 0 8px 8px 0;
    }
    blockquote p:first-child { margin-top: 0; }
    blockquote p:last-child { margin-bottom: 0; }
    blockquote:has(strong:first-child) {
      background: var(--warning-bg);
      border-left-color: var(--warning-border);
    }

    /* === Tables === */
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 1px 4px rgba(0,0,0,0.06);
      border: 1px solid var(--border);
      font-size: 0.95em;
    }
    thead th {
      background: var(--table-header);
      color: white;
      padding: 12px 16px;
      text-align: left;
      font-weight: 600;
      font-size: 0.9em;
    }
    tbody td {
      padding: 10px 16px;
      border-bottom: 1px solid var(--border);
    }
    tbody tr:nth-child(even) { background: var(--table-stripe); }
    tbody tr:hover { background: var(--accent-light); }

    /* === Lists === */
    ul, ol { padding-left: 28px; margin: 12px 0; }
    li { margin: 6px 0; }
    li > ul, li > ol { margin: 4px 0; }

    /* === Details/Summary === */
    details {
      background: #f8fafc;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px 16px;
      margin: 12px 0;
    }
    details summary {
      cursor: pointer;
      font-weight: 600;
      color: var(--accent);
    }
    details[open] summary { margin-bottom: 8px; }

    /* === Plain code blocks === */
    pre:has(code:not(.hljs)) {
      background: #fafbfc;
      border: 2px solid var(--border);
      box-shadow: none;
    }
    pre:has(code:not(.hljs))::before {
      background: #f1f5f9;
      color: #64748b;
      border-bottom-color: var(--border);
    }
    pre:has(code:not(.hljs)) code { color: #334155; }

    /* === Chapter Navigation === */
    .chapter-nav {
      display: flex;
      justify-content: space-between;
      gap: 16px;
      margin: 40px 0 20px;
      padding-top: 24px;
      border-top: 2px solid var(--border);
    }
    .chapter-nav a {
      display: flex;
      flex-direction: column;
      padding: 14px 20px;
      border: 1px solid var(--border);
      border-radius: 10px;
      text-decoration: none;
      transition: all 0.2s;
      min-width: 200px;
    }
    .chapter-nav a:hover {
      border-color: var(--accent);
      background: var(--accent-light);
      text-decoration: none;
    }
    .nav-prev { align-items: flex-start; }
    .nav-next { align-items: flex-end; }
    .nav-label {
      font-size: 0.8em;
      color: #94a3b8;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .nav-title { font-weight: 600; color: var(--accent); margin-top: 2px; }

    /* === Footer === */
    .book-footer {
      text-align: center;
      padding: 20px;
      margin-top: 40px;
      border-top: 1px solid var(--border);
      color: #94a3b8;
      font-size: 0.85em;
    }

    /* === Back to Top === */
    .back-to-top {
      position: fixed;
      bottom: 24px;
      right: 24px;
      width: 44px;
      height: 44px;
      background: var(--accent);
      color: white;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      font-size: 20px;
      display: none;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      transition: opacity 0.3s;
      z-index: 100;
    }
    .back-to-top.visible { display: flex; }

    /* === Print === */
    @media print {
      .progress-bar, .back-to-top, .chapter-nav, .toc { display: none !important; }
      body { font-size: 11pt; }
      .content { max-width: 100%; padding: 0; }
      .cover-header { break-after: page; }
      pre { box-shadow: none; border: 2px solid #ccc; break-inside: avoid; }
      .svg-diagram { break-inside: avoid; border: 1px solid #ccc; }
      table { break-inside: avoid; }
      h2, h3 { break-after: avoid; }
    }

    /* === Responsive === */
    @media (max-width: 640px) {
      .content { padding: 16px 12px 40px; font-size: 15px; }
      h1 { font-size: 1.5em; }
      h2 { font-size: 1.25em; }
      pre code { font-size: 0.8em; padding: 12px; }
      thead th, tbody td { padding: 8px 10px; font-size: 0.88em; }
      .svg-diagram { padding: 10px; }
      .toc { padding: 14px 18px; }
      .chapter-nav { flex-direction: column; }
      .chapter-nav a { min-width: unset; }
      .nav-next { align-items: flex-start; }
      .cover-chapter-num { font-size: 1.5em; }
    }
  </style>
</head>
<body>
  <!-- Reading Progress Bar -->
  <div class="progress-bar" id="progressBar"></div>

  
<header class="cover-header">
  <div class="cover-part" style="--part-color: #10b981">
    <span class="cover-part-label">Part 2: 깊이 파기</span>
  </div>
  <div class="cover-chapter-num">Chapter 06</div>
</header>

  <div class="content">
    <nav class="toc">
<h2 class="toc-title">목차</h2>
<ul>
<li><a href="#6-1-왜-시퀀스가-필요한가">6.1 왜 시퀀스가 필요한가</a></li>
  <li class="toc-sub"><a href="#6-1-1-chapter-5-방식의-한계">6.1.1 Chapter 5 방식의 한계</a></li>
  <li class="toc-sub"><a href="#6-1-2-해결-what과-how의-분리">6.1.2 해결: What과 How의 분리</a></li>
  <li class="toc-sub"><a href="#6-1-3-sequence-sequencer-driver-흐름">6.1.3 Sequence-Sequencer-Driver 흐름</a></li>
<li><a href="#6-2-트랜잭션-정의-uvm-sequence-item">6.2 트랜잭션 정의 — uvm_sequence_item</a></li>
  <li class="toc-sub"><a href="#6-2-1-트랜잭션이란">6.2.1 트랜잭션이란?</a></li>
  <li class="toc-sub"><a href="#6-2-2-uvm-sequence-item-작성">6.2.2 uvm_sequence_item 작성</a></li>
  <li class="toc-sub"><a href="#6-2-3-주요-설계-원칙">6.2.3 주요 설계 원칙</a></li>
<li><a href="#6-3-시퀀스-작성-uvm-sequence">6.3 시퀀스 작성 — uvm_sequence</a></li>
  <li class="toc-sub"><a href="#6-3-1-시퀀스란">6.3.1 시퀀스란?</a></li>
  <li class="toc-sub"><a href="#6-3-2-첫-번째-시퀀스-리셋-시퀀스">6.3.2 첫 번째 시퀀스: 리셋 시퀀스</a></li>
  <li class="toc-sub"><a href="#6-3-3-두-번째-시퀀스-카운트-시퀀스">6.3.3 두 번째 시퀀스: 카운트 시퀀스</a></li>
  <li class="toc-sub"><a href="#6-3-4-uvm-do-매크로-간편-표기">6.3.4 `uvm_do 매크로 — 간편 표기</a></li>
  <li class="toc-sub"><a href="#6-3-5-시퀀스-조합-마스터-시퀀스">6.3.5 시퀀스 조합: 마스터 시퀀스</a></li>
<li><a href="#6-4-시퀀서와-드라이버-연결">6.4 시퀀서와 드라이버 연결</a></li>
  <li class="toc-sub"><a href="#6-4-1-시퀀서-uvm-sequencer">6.4.1 시퀀서 (uvm_sequencer)</a></li>
  <li class="toc-sub"><a href="#6-4-2-드라이버-리팩토링-get-next-item-item-done">6.4.2 드라이버 리팩토링: get_next_item()/item_done()</a></li>
  <li class="toc-sub"><a href="#6-4-3-seq-item-port-드라이버와-시퀀서의-연결">6.4.3 seq_item_port — 드라이버와 시퀀서의 연결</a></li>
  <li class="toc-sub"><a href="#6-4-4-시퀀스-실행-test에서-start-호출">6.4.4 시퀀스 실행: test에서 start() 호출</a></li>
<li><a href="#6-5-종합-시퀀스-기반-테스트벤치">6.5 종합: 시퀀스 기반 테스트벤치</a></li>
  <li class="toc-sub"><a href="#6-5-1-before-after-비교">6.5.1 Before → After 비교</a></li>
  <li class="toc-sub"><a href="#6-5-2-완전한-코드">6.5.2 완전한 코드</a></li>
  <li class="toc-sub"><a href="#6-5-3-ch-5-대비-변경-사항-정리">6.5.3 Ch.5 대비 변경 사항 정리</a></li>
  <li class="toc-sub"><a href="#6-5-4-다양한-테스트-만들기">6.5.4 다양한 테스트 만들기</a></li>
  <li class="toc-sub"><a href="#6-5-5-시뮬레이션-실행">6.5.5 시뮬레이션 실행</a></li>
<li><a href="#6-6-체크포인트">6.6 체크포인트</a></li>
  <li class="toc-sub"><a href="#셀프-체크">셀프 체크</a></li>
  <li class="toc-sub"><a href="#연습문제">연습문제</a></li>
  <li class="toc-sub"><a href="#흔한-에러와-해결">흔한 에러와 해결</a></li>
  <li class="toc-sub"><a href="#용어-정리">용어 정리</a></li>
  <li class="toc-sub"><a href="#다음-챕터-예고">다음 챕터 예고</a></li>
</ul>
</nav>
    <h1>Chapter 6: 시퀀스 &amp; 시퀀서</h1>
<blockquote>
<p><strong>학습 목표</strong></p>
<ul>
<li><code>uvm_sequence_item</code>으로 트랜잭션을 정의할 수 있다</li>
<li><code>uvm_sequence</code>의 <code>body()</code>에서 트랜잭션을 생성·전송할 수 있다</li>
<li>Sequence-Sequencer-Driver 연결 구조를 이해한다</li>
<li><code>start_item()</code>/<code>finish_item()</code> 패턴을 사용할 수 있다</li>
<li>여러 시퀀스를 만들어 다양한 테스트 시나리오를 구성할 수 있다</li>
</ul>
</blockquote>
<blockquote>
<p><strong>선수 지식</strong>: Chapter 3에서 배운 class, randomize, constraint를 사용합니다. Chapter 4의 uvm_object, Factory, Phase, Chapter 5의 테스트벤치 구조(driver, monitor, agent)가 핵심 기반입니다.</p>
</blockquote>
<hr>
<h2 id="6-1-왜-시퀀스가-필요한가">6.1 왜 시퀀스가 필요한가</h2>
<blockquote>
<p><strong>이 절의 목표</strong>: Chapter 5 방식의 한계를 이해하고, 시퀀스를 통한 해결 방향을 파악합니다.</p>
</blockquote>
<h3 id="6-1-1-chapter-5-방식의-한계">6.1.1 Chapter 5 방식의 한계</h3>
<p>Chapter 5에서 만든 드라이버를 다시 봅시다:</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// Chapter 5 방식: 드라이버 안에 테스트 시나리오가 하드코딩</span>
<span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> run_phase(uvm_phase phase);
  phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);

  <span class="hljs-comment">// 리셋</span>
  vif<span class="hljs-variable">.rst_n</span> = <span class="hljs-number">0</span>;
  @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>);
  vif<span class="hljs-variable">.rst_n</span> = <span class="hljs-number">1</span>;

  <span class="hljs-comment">// 카운트 5회</span>
  vif<span class="hljs-variable">.enable</span> = <span class="hljs-number">1</span>;
  <span class="hljs-keyword">repeat</span>(<span class="hljs-number">5</span>) @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>);

  <span class="hljs-comment">// 비활성화</span>
  vif<span class="hljs-variable">.enable</span> = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">repeat</span>(<span class="hljs-number">3</span>) @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>);

  phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);
<span class="hljs-keyword">endtask</span>
</code></pre><p>이 방식에는 세 가지 문제가 있습니다:</p>
<p><strong>문제 1: 시나리오 변경이 불가능하다</strong></p>
<p>&quot;카운트 10회&quot; 테스트를 하려면? 드라이버 코드를 수정해야 합니다. &quot;리셋 → 카운트 → 리셋 → 카운트&quot; 패턴은? 또 수정. 테스트 시나리오마다 드라이버를 고치는 것은 비현실적입니다.</p>
<p><strong>문제 2: 드라이버를 재사용할 수 없다</strong></p>
<p>드라이버의 본래 역할은 <strong>신호를 구동하는 것</strong>(How)뿐인데, 지금은 <strong>무엇을 구동할지</strong>(What)까지 결정하고 있습니다. 역할이 섞여 있으면 다른 프로젝트에서 재사용할 수 없습니다.</p>
<p><strong>문제 3: 팀 협업이 어렵다</strong></p>
<p>실무에서는 드라이버를 만드는 사람과 테스트 시나리오를 작성하는 사람이 다릅니다. 코드가 섞여 있으면 서로의 작업에 영향을 줍니다.</p>
<h3 id="6-1-2-해결-what과-how의-분리">6.1.2 해결: What과 How의 분리</h3>

<div class="svg-diagram">
<svg viewBox="0 0 780 340" xmlns="http://www.w3.org/2000/svg" style="max-width:780px;width:100%">
  
  <style>
    .diagram-box { fill: #ffffff; stroke: #334155; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-accent { fill: #eff6ff; stroke: #2563eb; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-highlight { fill: #fef3c7; stroke: #f59e0b; stroke-width: 2.5; rx: 10; ry: 10; }
    .diagram-box-dark { fill: #1e293b; stroke: #1e293b; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-run { fill: #fef3c7; stroke: #f59e0b; stroke-width: 3; rx: 10; ry: 10; }
    .diagram-box-green { fill: #ecfdf5; stroke: #10b981; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-purple { fill: #f5f3ff; stroke: #7c3aed; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-red { fill: #fef2f2; stroke: #ef4444; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-gray { fill: #f8fafc; stroke: #94a3b8; stroke-width: 1.5; rx: 8; ry: 8; }
    .diagram-text { font-family: 'Noto Sans KR', sans-serif; fill: #1e293b; }
    .diagram-text-white { font-family: 'Noto Sans KR', sans-serif; fill: #ffffff; }
    .diagram-text-accent { font-family: 'Noto Sans KR', sans-serif; fill: #2563eb; }
    .diagram-text-small { font-family: 'Noto Sans KR', sans-serif; fill: #64748b; font-size: 12px; }
    .diagram-text-code { font-family: 'Fira Code', 'JetBrains Mono', monospace; fill: #1e293b; }
    .diagram-arrow { fill: none; stroke: #64748b; stroke-width: 1.5; }
    .diagram-arrow-accent { fill: none; stroke: #2563eb; stroke-width: 1.5; }
    .diagram-line { stroke: #cbd5e1; stroke-width: 1.5; stroke-dasharray: 6,3; }
  </style>
  <defs>
    <marker id="arrowhead" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#64748b" />
    </marker>
    <marker id="arrowhead-accent" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#2563eb" />
    </marker>
    <marker id="arrowhead-dark" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#1e293b" />
    </marker>
    <marker id="arrowhead-orange" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#f59e0b" />
    </marker>
    <filter id="shadow" x="-5%" y="-5%" width="115%" height="115%">
      <feDropShadow dx="0" dy="2" stdDeviation="3" flood-color="#000" flood-opacity="0.1"/>
    </filter>
  </defs>

  <!-- Title: Chapter 5 방식 -->
  <text x="390" y="28" text-anchor="middle" class="diagram-text" font-size="15" font-weight="bold">Chapter 5 방식 (모든 것이 드라이버에)</text>
  <!-- Driver box -->
  <rect x="165" y="42" width="450" height="88" class="diagram-box-red" filter="url(#shadow)"/>
  <text x="390" y="62" text-anchor="middle" class="diagram-text" font-size="14" font-weight="bold">Driver</text>
  <!-- Inner What/How box -->
  <rect x="195" y="72" width="390" height="48" rx="6" ry="6" fill="#fef2f2" stroke="#ef4444" stroke-width="1.5"/>
  <text x="280" y="93" text-anchor="middle" class="diagram-text-code" font-size="12">What: 리셋 → 카운트 5회</text>
  <text x="280" y="110" text-anchor="middle" class="diagram-text-code" font-size="12">How:  vif.enable = 1</text>
  <text x="610" y="93" text-anchor="start" class="diagram-text-small" font-size="11">← 시나리오 하드코딩</text>
  <text x="610" y="110" text-anchor="start" class="diagram-text-small" font-size="11">← 신호 구동</text>

  <!-- Divider -->
  <line x1="60" y1="155" x2="720" y2="155" class="diagram-line"/>

  <!-- Title: Chapter 6 방식 -->
  <text x="390" y="185" text-anchor="middle" class="diagram-text" font-size="15" font-weight="bold">Chapter 6 방식 (역할 분리)</text>

  <!-- Sequence box -->
  <rect x="60" y="200" width="180" height="80" class="diagram-box-accent" filter="url(#shadow)"/>
  <text x="150" y="224" text-anchor="middle" class="diagram-text" font-size="14" font-weight="bold">Sequence</text>
  <text x="150" y="244" text-anchor="middle" class="diagram-text-accent" font-size="13">(What)</text>
  <text x="150" y="264" text-anchor="middle" class="diagram-text-code" font-size="11">리셋 → 카운트 5</text>

  <!-- Arrow Seq → Sqr -->
  <line x1="240" y1="240" x2="295" y2="240" class="diagram-arrow-accent" marker-end="url(#arrowhead-accent)" stroke-width="1.5"/>

  <!-- Sequencer box -->
  <rect x="300" y="210" width="160" height="60" class="diagram-box-green" filter="url(#shadow)"/>
  <text x="380" y="236" text-anchor="middle" class="diagram-text" font-size="14" font-weight="bold">Sequencer</text>
  <text x="380" y="254" text-anchor="middle" class="diagram-text-small" font-size="12">(중개자)</text>

  <!-- Arrow Sqr → Drv -->
  <line x1="460" y1="240" x2="515" y2="240" class="diagram-arrow-accent" marker-end="url(#arrowhead-accent)" stroke-width="1.5"/>

  <!-- Driver box -->
  <rect x="520" y="200" width="180" height="80" class="diagram-box-highlight" filter="url(#shadow)"/>
  <text x="610" y="224" text-anchor="middle" class="diagram-text" font-size="14" font-weight="bold">Driver</text>
  <text x="610" y="244" text-anchor="middle" class="diagram-text" font-size="13">(How)</text>
  <text x="610" y="264" text-anchor="middle" class="diagram-text-code" font-size="11">vif.enable = 1</text>

  <!-- Labels -->
  <text x="150" y="300" text-anchor="middle" class="diagram-text-small" font-size="11">시나리오 변경 자유</text>
  <text x="610" y="300" text-anchor="middle" class="diagram-text-small" font-size="11">신호 구동만 담당</text>
</svg>
</div><blockquote>
<p><strong>비유</strong>: 택배 시스템을 생각해보세요</p>
<ul>
<li><strong>Sequence</strong> = 주문서 작성자 — &quot;서울에서 부산으로 5kg 박스를 보내주세요&quot;</li>
<li><strong>Sequence Item</strong> = 주문서 한 장 — 보내는 사람, 받는 사람, 물건 정보</li>
<li><strong>Sequencer</strong> = 택배 회사 본사 — 주문서를 접수하고 배달원에게 전달</li>
<li><strong>Driver</strong> = 배달원 — 주문서대로 물건을 실제로 배달 (신호를 DUT에 구동)</li>
</ul>
<p>핵심은 <strong>주문서 작성자가 바뀌어도 배달원은 그대로</strong>라는 점입니다!</p>
</blockquote>
<h3 id="6-1-3-sequence-sequencer-driver-흐름">6.1.3 Sequence-Sequencer-Driver 흐름</h3>
<p>전체 데이터 흐름을 정리하면:</p>

<div class="svg-diagram">
<svg viewBox="0 0 780 300" xmlns="http://www.w3.org/2000/svg" style="max-width:780px;width:100%">
  
  <style>
    .diagram-box { fill: #ffffff; stroke: #334155; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-accent { fill: #eff6ff; stroke: #2563eb; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-highlight { fill: #fef3c7; stroke: #f59e0b; stroke-width: 2.5; rx: 10; ry: 10; }
    .diagram-box-dark { fill: #1e293b; stroke: #1e293b; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-run { fill: #fef3c7; stroke: #f59e0b; stroke-width: 3; rx: 10; ry: 10; }
    .diagram-box-green { fill: #ecfdf5; stroke: #10b981; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-purple { fill: #f5f3ff; stroke: #7c3aed; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-red { fill: #fef2f2; stroke: #ef4444; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-gray { fill: #f8fafc; stroke: #94a3b8; stroke-width: 1.5; rx: 8; ry: 8; }
    .diagram-text { font-family: 'Noto Sans KR', sans-serif; fill: #1e293b; }
    .diagram-text-white { font-family: 'Noto Sans KR', sans-serif; fill: #ffffff; }
    .diagram-text-accent { font-family: 'Noto Sans KR', sans-serif; fill: #2563eb; }
    .diagram-text-small { font-family: 'Noto Sans KR', sans-serif; fill: #64748b; font-size: 12px; }
    .diagram-text-code { font-family: 'Fira Code', 'JetBrains Mono', monospace; fill: #1e293b; }
    .diagram-arrow { fill: none; stroke: #64748b; stroke-width: 1.5; }
    .diagram-arrow-accent { fill: none; stroke: #2563eb; stroke-width: 1.5; }
    .diagram-line { stroke: #cbd5e1; stroke-width: 1.5; stroke-dasharray: 6,3; }
  </style>
  <defs>
    <marker id="arrowhead" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#64748b" />
    </marker>
    <marker id="arrowhead-accent" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#2563eb" />
    </marker>
    <marker id="arrowhead-dark" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#1e293b" />
    </marker>
    <marker id="arrowhead-orange" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#f59e0b" />
    </marker>
    <filter id="shadow" x="-5%" y="-5%" width="115%" height="115%">
      <feDropShadow dx="0" dy="2" stdDeviation="3" flood-color="#000" flood-opacity="0.1"/>
    </filter>
  </defs>

  <!-- Title -->
  <text x="390" y="28" text-anchor="middle" class="diagram-text" font-size="15" font-weight="bold">Sequence-Sequencer-Driver 데이터 흐름</text>

  <!-- Sequence box -->
  <rect x="40" y="50" width="200" height="210" class="diagram-box-accent" filter="url(#shadow)"/>
  <text x="140" y="74" text-anchor="middle" class="diagram-text" font-size="14" font-weight="bold">Sequence</text>
  <line x1="50" y1="82" x2="230" y2="82" stroke="#2563eb" stroke-width="1"/>
  <text x="60" y="105" text-anchor="start" class="diagram-text-code" font-size="11">body() {</text>
  <text x="70" y="125" text-anchor="start" class="diagram-text-code" font-size="11">item = create()</text>
  <text x="70" y="145" text-anchor="start" class="diagram-text-code" font-size="11">start_item()</text>
  <text x="70" y="165" text-anchor="start" class="diagram-text-code" font-size="11">randomize()</text>
  <text x="70" y="185" text-anchor="start" class="diagram-text-code" font-size="11">finish_item()</text>
  <text x="60" y="205" text-anchor="start" class="diagram-text-code" font-size="11">}</text>

  <!-- Sequencer box -->
  <rect x="300" y="50" width="180" height="210" class="diagram-box-green" filter="url(#shadow)"/>
  <text x="390" y="74" text-anchor="middle" class="diagram-text" font-size="14" font-weight="bold">Sequencer</text>
  <line x1="310" y1="82" x2="470" y2="82" stroke="#10b981" stroke-width="1"/>
  <text x="390" y="130" text-anchor="middle" class="diagram-text" font-size="13">중개자</text>
  <text x="390" y="155" text-anchor="middle" class="diagram-text-small" font-size="12">(대기열)</text>

  <!-- Driver box -->
  <rect x="540" y="50" width="200" height="210" class="diagram-box-highlight" filter="url(#shadow)"/>
  <text x="640" y="74" text-anchor="middle" class="diagram-text" font-size="14" font-weight="bold">Driver</text>
  <line x1="550" y1="82" x2="730" y2="82" stroke="#f59e0b" stroke-width="1"/>
  <text x="560" y="105" text-anchor="start" class="diagram-text-code" font-size="11">run_phase() {</text>
  <text x="570" y="125" text-anchor="start" class="diagram-text-code" font-size="11">get_next_item()</text>
  <text x="570" y="150" text-anchor="start" class="diagram-text-code" font-size="11">drive_item()</text>
  <text x="570" y="175" text-anchor="start" class="diagram-text-code" font-size="11">item_done()</text>
  <text x="560" y="200" text-anchor="start" class="diagram-text-code" font-size="11">}</text>

  <!-- Arrow 1: Seq → Sqr (전달) -->
  <path d="M 240 115 L 295 115" class="diagram-arrow-accent" marker-end="url(#arrowhead-accent)" stroke-width="1.5"/>
  <text x="267" y="108" text-anchor="middle" class="diagram-text-accent" font-size="11" font-weight="bold">①전달</text>

  <!-- Arrow 2: Sqr → Drv (전달) -->
  <path d="M 480 125 L 535 125" class="diagram-arrow" marker-end="url(#arrowhead-dark)" stroke-width="1.5"/>
  <text x="507" y="118" text-anchor="middle" class="diagram-text" font-size="11" font-weight="bold">②전달</text>

  <!-- Arrow 3: Drv → Sqr (완료) -->
  <path d="M 540 185 L 480 185" class="diagram-arrow" marker-end="url(#arrowhead)" stroke-width="1.5" stroke-dasharray="6,3"/>
  <text x="510" y="202" text-anchor="middle" class="diagram-text-small" font-size="11">③완료</text>

  <!-- Arrow 4: Sqr → Seq (다음) -->
  <path d="M 300 195 L 240 195" class="diagram-arrow" marker-end="url(#arrowhead)" stroke-width="1.5" stroke-dasharray="6,3"/>
  <text x="270" y="212" text-anchor="middle" class="diagram-text-small" font-size="11">④다음</text>
</svg>
</div><blockquote>
<p><strong>면접 포인트</strong>: &quot;Sequence와 Driver를 분리하는 이유가 무엇인가요?&quot; — <strong>재사용성</strong>과 <strong>유연성</strong>. 같은 Driver로 다양한 Sequence를 실행할 수 있고, 같은 Sequence를 다른 Driver에서도 사용할 수 있습니다.</p>
</blockquote>
<hr>
<h2 id="6-2-트랜잭션-정의-uvm-sequence-item">6.2 트랜잭션 정의 — uvm_sequence_item</h2>
<blockquote>
<p><strong>이 절의 목표</strong>: DUT와 주고받을 데이터의 구조를 정의하는 방법을 배웁니다. 트랜잭션은 시퀀스 기반 검증의 기본 단위입니다.</p>
</blockquote>
<h3 id="6-2-1-트랜잭션이란">6.2.1 트랜잭션이란?</h3>
<p>트랜잭션(transaction)은 DUT와 한 번 주고받는 데이터의 단위입니다. 택배 비유에서 <strong>주문서 한 장</strong>에 해당합니다.</p>
<p>Chapter 5에서는 <code>vif.enable = 1</code>처럼 개별 신호를 직접 다뤘습니다. 이것을 **신호 수준(signal level)**이라 합니다. 시퀀스 기반에서는 신호들을 묶어 하나의 **트랜잭션 수준(transaction level)**으로 추상화합니다:</p>
<table>
<thead>
<tr>
<th>구분</th>
<th>신호 수준 (Ch.5)</th>
<th>트랜잭션 수준 (Ch.6)</th>
</tr>
</thead>
<tbody><tr>
<td>리셋</td>
<td><code>vif.rst_n = 0</code></td>
<td><code>item.rst_n = 0</code></td>
</tr>
<tr>
<td>활성화</td>
<td><code>vif.enable = 1</code></td>
<td><code>item.enable = 1</code></td>
</tr>
<tr>
<td>단위</td>
<td>개별 신호</td>
<td>트랜잭션 객체</td>
</tr>
<tr>
<td>재사용</td>
<td>불가</td>
<td>가능</td>
</tr>
</tbody></table>
<h3 id="6-2-2-uvm-sequence-item-작성">6.2.2 uvm_sequence_item 작성</h3>
<p>4비트 카운터의 트랜잭션을 정의해봅시다:</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// 파일: counter_seq_item.sv</span>
<span class="hljs-comment">// 4비트 카운터용 트랜잭션 정의</span>

<span class="hljs-keyword">class</span> counter_seq_item <span class="hljs-keyword">extends</span> uvm_sequence_item;

  <span class="hljs-comment">// ① 필드 선언 — DUT 입력에 해당하는 값</span>
  <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span>       rst_n;     <span class="hljs-comment">// 리셋 (0: 리셋, 1: 해제)</span>
  <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span>       enable;    <span class="hljs-comment">// 카운터 활성화</span>
  <span class="hljs-keyword">rand</span> <span class="hljs-keyword">int</span>       cycles;    <span class="hljs-comment">// 이 설정을 유지할 클럭 수</span>

  <span class="hljs-comment">// ② 출력 필드 — DUT 응답 (모니터가 기록)</span>
  <span class="hljs-keyword">logic</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>]    count;     <span class="hljs-comment">// 관찰된 카운트 값</span>

  <span class="hljs-comment">// ③ 제약 조건 — 합리적인 범위 제한</span>
  <span class="hljs-keyword">constraint</span> c_cycles { cycles <span class="hljs-keyword">inside</span> {[<span class="hljs-number">1</span>:<span class="hljs-number">20</span>]}; }

  <span class="hljs-comment">// ④ Factory 등록</span>
  `uvm_object_utils_begin(counter_seq_item)
    `uvm_field_int(rst_n,  UVM_ALL_ON)
    `uvm_field_int(enable, UVM_ALL_ON)
    `uvm_field_int(cycles, UVM_ALL_ON)
    `uvm_field_int(count,  UVM_ALL_ON)
  `uvm_object_utils_end

  <span class="hljs-comment">// ⑤ 생성자</span>
  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;counter_seq_item&quot;</span>);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-comment">// ⑥ 디버그용 문자열 변환</span>
  <span class="hljs-keyword">function</span> <span class="hljs-keyword">string</span> convert2string();
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;rst_n=%0b enable=%0b cycles=%0d count=%0h&quot;</span>,
                     rst_n, enable, cycles, count);
  <span class="hljs-keyword">endfunction</span>

<span class="hljs-keyword">endclass</span>
</code></pre><p>각 부분을 살펴봅시다:</p>
<p><strong>① <code>rand</code> 필드</strong>: <code>rand</code> 키워드가 붙은 필드는 <code>randomize()</code> 호출 시 랜덤 값이 생성됩니다. DUT에 <strong>입력</strong>할 데이터입니다.</p>
<p><strong>② 출력 필드</strong>: <code>rand</code>가 없는 필드는 DUT의 <strong>응답</strong>을 기록하는 용도입니다. 모니터가 관찰한 값을 여기에 저장합니다.</p>
<p><strong>③ <code>constraint</code></strong>: 랜덤 값의 범위를 제한합니다. <code>cycles</code>를 1~20으로 제한하면 비현실적으로 긴 테스트를 방지합니다. Ch.3에서 배운 constraint 문법 그대로입니다.</p>
<p><strong>④ Field 매크로</strong>: <code>uvm_field_int</code> 매크로로 필드를 등록하면 <code>print()</code>, <code>copy()</code>, <code>compare()</code>, <code>pack()/unpack()</code> 기능이 자동으로 제공됩니다. Ch.4에서 배운 <code>convert2string()</code>과 함께 디버깅이 쉬워집니다.</p>
<blockquote>
<p><strong>참고</strong>: <code>uvm_field_*</code> 매크로는 편리하지만, 실무에서 성능이 중요한 환경에서는 직접 구현하기도 합니다. 학습 단계에서는 매크로를 사용하는 것이 효율적입니다.</p>
</blockquote>
<p><strong>⑤ 생성자</strong>: <code>uvm_sequence_item</code>은 <code>uvm_object</code>의 서브클래스이므로, 생성자에 <code>parent</code> 인수가 <strong>없습니다</strong> (Ch.4에서 배운 object vs component 차이).</p>
<p><strong>⑥ <code>convert2string()</code></strong>: 트랜잭션의 내용을 문자열로 출력합니다. 디버깅 시 <code>uvm_info</code>와 함께 사용하면 매우 유용합니다.</p>
<h3 id="6-2-3-주요-설계-원칙">6.2.3 주요 설계 원칙</h3>
<p>트랜잭션을 설계할 때 기억할 3가지:</p>
<ol>
<li><strong>DUT 입력 → <code>rand</code> 필드</strong>: 랜덤화할 수 있도록 <code>rand</code> 키워드 사용</li>
<li><strong>DUT 출력 → 일반 필드</strong>: 모니터가 기록, 랜덤화 불필요</li>
<li><strong>적절한 constraint</strong>: 유효한 범위를 제한하되, 너무 좁히지 않기</li>
</ol>

<div class="svg-diagram">
<svg viewBox="0 0 680 310" xmlns="http://www.w3.org/2000/svg" style="max-width:680px;width:100%">
  
  <style>
    .diagram-box { fill: #ffffff; stroke: #334155; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-accent { fill: #eff6ff; stroke: #2563eb; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-highlight { fill: #fef3c7; stroke: #f59e0b; stroke-width: 2.5; rx: 10; ry: 10; }
    .diagram-box-dark { fill: #1e293b; stroke: #1e293b; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-run { fill: #fef3c7; stroke: #f59e0b; stroke-width: 3; rx: 10; ry: 10; }
    .diagram-box-green { fill: #ecfdf5; stroke: #10b981; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-purple { fill: #f5f3ff; stroke: #7c3aed; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-red { fill: #fef2f2; stroke: #ef4444; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-gray { fill: #f8fafc; stroke: #94a3b8; stroke-width: 1.5; rx: 8; ry: 8; }
    .diagram-text { font-family: 'Noto Sans KR', sans-serif; fill: #1e293b; }
    .diagram-text-white { font-family: 'Noto Sans KR', sans-serif; fill: #ffffff; }
    .diagram-text-accent { font-family: 'Noto Sans KR', sans-serif; fill: #2563eb; }
    .diagram-text-small { font-family: 'Noto Sans KR', sans-serif; fill: #64748b; font-size: 12px; }
    .diagram-text-code { font-family: 'Fira Code', 'JetBrains Mono', monospace; fill: #1e293b; }
    .diagram-arrow { fill: none; stroke: #64748b; stroke-width: 1.5; }
    .diagram-arrow-accent { fill: none; stroke: #2563eb; stroke-width: 1.5; }
    .diagram-line { stroke: #cbd5e1; stroke-width: 1.5; stroke-dasharray: 6,3; }
  </style>
  <defs>
    <marker id="arrowhead" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#64748b" />
    </marker>
    <marker id="arrowhead-accent" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#2563eb" />
    </marker>
    <marker id="arrowhead-dark" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#1e293b" />
    </marker>
    <marker id="arrowhead-orange" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#f59e0b" />
    </marker>
    <filter id="shadow" x="-5%" y="-5%" width="115%" height="115%">
      <feDropShadow dx="0" dy="2" stdDeviation="3" flood-color="#000" flood-opacity="0.1"/>
    </filter>
  </defs>

  <!-- Title -->
  <text x="340" y="28" text-anchor="middle" class="diagram-text" font-size="15" font-weight="bold">트랜잭션 설계 원칙</text>
  <text x="340" y="50" text-anchor="middle" class="diagram-text-code" font-size="13">counter_seq_item</text>

  <!-- Main box outline -->
  <rect x="190" y="62" width="300" height="230" class="diagram-box" filter="url(#shadow)"/>

  <!-- Section 1: DUT 입력 (rand) -->
  <rect x="190" y="62" width="300" height="90" class="diagram-box-accent" rx="10" ry="10"/>
  <rect x="190" y="142" width="300" height="10" fill="#ffffff" stroke="none"/>
  <text x="210" y="88" text-anchor="start" class="diagram-text-code" font-size="12" font-weight="bold">rand</text>
  <text x="250" y="88" text-anchor="start" class="diagram-text-code" font-size="12">bit rst_n</text>
  <text x="210" y="110" text-anchor="start" class="diagram-text-code" font-size="12" font-weight="bold">rand</text>
  <text x="250" y="110" text-anchor="start" class="diagram-text-code" font-size="12">bit enable</text>
  <text x="210" y="132" text-anchor="start" class="diagram-text-code" font-size="12" font-weight="bold">rand</text>
  <text x="250" y="132" text-anchor="start" class="diagram-text-code" font-size="12">int cycles</text>

  <!-- Section 1 label (left) -->
  <text x="175" y="88" text-anchor="end" class="diagram-text" font-size="12" font-weight="bold">DUT 입력</text>
  <text x="175" y="106" text-anchor="end" class="diagram-text-small" font-size="11">(구동 값)</text>

  <!-- Section 1 annotation (right) -->
  <text x="505" y="100" text-anchor="start" class="diagram-text-small" font-size="11">← randomize() 대상</text>

  <!-- Divider 1 -->
  <line x1="200" y1="148" x2="480" y2="148" stroke="#334155" stroke-width="1.5"/>

  <!-- Section 2: DUT 출력 -->
  <rect x="195" y="152" width="290" height="50" rx="4" ry="4" fill="#ecfdf5" stroke="none"/>
  <text x="210" y="180" text-anchor="start" class="diagram-text-code" font-size="12">logic [3:0] count</text>

  <!-- Section 2 label (left) -->
  <text x="175" y="172" text-anchor="end" class="diagram-text" font-size="12" font-weight="bold">DUT 출력</text>
  <text x="175" y="190" text-anchor="end" class="diagram-text-small" font-size="11">(관찰 값)</text>

  <!-- Section 2 annotation (right) -->
  <text x="505" y="180" text-anchor="start" class="diagram-text-small" font-size="11">← 모니터가 기록</text>

  <!-- Divider 2 -->
  <line x1="200" y1="208" x2="480" y2="208" stroke="#334155" stroke-width="1.5"/>

  <!-- Section 3: Constraint -->
  <rect x="195" y="212" width="290" height="70" rx="4" ry="4" fill="#fef3c7" stroke="none"/>
  <text x="210" y="238" text-anchor="start" class="diagram-text-code" font-size="12" font-weight="bold">constraint</text>
  <text x="290" y="238" text-anchor="start" class="diagram-text-code" font-size="12">c_cycles</text>
  <text x="210" y="260" text-anchor="start" class="diagram-text-code" font-size="12">{ cycles inside {[1:20]} }</text>

  <!-- Section 3 label (left) -->
  <text x="175" y="240" text-anchor="end" class="diagram-text" font-size="12" font-weight="bold">제약 조건</text>

  <!-- Section 3 annotation (right) -->
  <text x="505" y="245" text-anchor="start" class="diagram-text-small" font-size="11">← 유효 범위 제한</text>
</svg>
</div><blockquote>
<p><strong>흔한 실수</strong>: <code>uvm_sequence_item</code>을 <code>uvm_component_utils</code>로 등록하면 안 됩니다! sequence_item은 <code>uvm_object</code>이므로 반드시 <code>uvm_object_utils</code>를 사용하세요.</p>
</blockquote>
<hr>
<h2 id="6-3-시퀀스-작성-uvm-sequence">6.3 시퀀스 작성 — uvm_sequence</h2>
<blockquote>
<p><strong>이 절의 목표</strong>: 트랜잭션을 생성하고 전송하는 시퀀스를 작성합니다. <code>body()</code>, <code>start_item()</code>/<code>finish_item()</code> 패턴이 핵심입니다.</p>
</blockquote>
<h3 id="6-3-1-시퀀스란">6.3.1 시퀀스란?</h3>
<p>시퀀스(sequence)는 <strong>트랜잭션의 시나리오</strong>입니다. 택배 비유에서 &quot;이 순서대로 주문서를 보내세요&quot;라는 지시서에 해당합니다.</p>
<p>시퀀스의 핵심 메서드는 <code>body()</code>입니다. 시퀀스가 실행되면 <code>body()</code>가 자동으로 호출되고, 여기서 트랜잭션을 생성하고 전송합니다.</p>
<h3 id="6-3-2-첫-번째-시퀀스-리셋-시퀀스">6.3.2 첫 번째 시퀀스: 리셋 시퀀스</h3>
<p>가장 간단한 시퀀스부터 만들어봅시다 — DUT를 리셋하는 시퀀스:</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// 파일: counter_reset_seq.sv</span>
<span class="hljs-comment">// 리셋 시퀀스: DUT를 리셋 상태로 만듦</span>

<span class="hljs-keyword">class</span> counter_reset_seq <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(counter_seq_item)</span>;
  `uvm_object_utils(counter_reset_seq)

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;counter_reset_seq&quot;</span>);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();
    counter_seq_item item;

    <span class="hljs-comment">// ① 트랜잭션 생성 (Factory 사용)</span>
    item = counter_seq_item::type_id::create(<span class="hljs-string">&quot;item&quot;</span>);

    <span class="hljs-comment">// ② 시퀀서에게 전송 시작 알림</span>
    start_item(item);

    <span class="hljs-comment">// ③ 트랜잭션 값 설정</span>
    item<span class="hljs-variable">.rst_n</span>  = <span class="hljs-number">0</span>;       <span class="hljs-comment">// 리셋 활성화</span>
    item<span class="hljs-variable">.enable</span> = <span class="hljs-number">0</span>;
    item<span class="hljs-variable">.cycles</span> = <span class="hljs-number">2</span>;       <span class="hljs-comment">// 2 클럭 동안 유지</span>

    <span class="hljs-comment">// ④ 시퀀서에게 전송 완료 알림</span>
    finish_item(item);

    `uvm_info(get_type_name(), <span class="hljs-string">&quot;Reset sequence completed&quot;</span>, UVM_MEDIUM)
  <span class="hljs-keyword">endtask</span>

<span class="hljs-keyword">endclass</span>
</code></pre><p><strong><code>start_item()</code> / <code>finish_item()</code> 이해하기</strong>:</p>
<p>이 두 메서드가 시퀀스의 핵심입니다:</p>
<table>
<thead>
<tr>
<th>단계</th>
<th>메서드</th>
<th>하는 일</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><code>create()</code></td>
<td>트랜잭션 객체 생성 (빈 주문서 준비)</td>
</tr>
<tr>
<td>2</td>
<td><code>start_item(item)</code></td>
<td>시퀀서에게 &quot;보낼 거 있어요&quot; 알림 (드라이버가 준비될 때까지 대기)</td>
</tr>
<tr>
<td>3</td>
<td>값 설정 / <code>randomize()</code></td>
<td>트랜잭션에 실제 데이터 기록 (주문서 작성)</td>
</tr>
<tr>
<td>4</td>
<td><code>finish_item(item)</code></td>
<td>트랜잭션을 드라이버에게 전달, 처리 완료까지 대기 (주문서 접수)</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>왜 start_item 다음에 값을 설정하나요?</strong>: <code>start_item()</code>은 드라이버가 이전 트랜잭션 처리를 끝낼 때까지 대기합니다. 이 대기 후에 값을 설정해야 <strong>가장 최신 상태</strong>를 반영할 수 있습니다. 이것은 UVM의 <strong>late randomization</strong> 패턴입니다.</p>
</blockquote>
<blockquote>
<p><strong>안심하세요</strong>: <code>start_item()</code> → 값 설정 → <code>finish_item()</code> 이 3단계 패턴만 외우면 됩니다. 모든 시퀀스가 이 패턴을 따릅니다. 지금은 &quot;왜?&quot; 보다 &quot;이렇게 쓴다&quot;를 먼저 익히세요.</p>
</blockquote>
<h3 id="6-3-3-두-번째-시퀀스-카운트-시퀀스">6.3.3 두 번째 시퀀스: 카운트 시퀀스</h3>
<p>이번에는 랜덤화를 활용하는 시퀀스를 만들어봅시다:</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// 파일: counter_count_seq.sv</span>
<span class="hljs-comment">// 카운트 시퀀스: enable 활성화 후 N회 카운트</span>

<span class="hljs-keyword">class</span> counter_count_seq <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(counter_seq_item)</span>;
  `uvm_object_utils(counter_count_seq)

  <span class="hljs-comment">// 시퀀스 레벨 파라미터</span>
  <span class="hljs-keyword">rand</span> <span class="hljs-keyword">int</span> num_transactions;
  <span class="hljs-keyword">constraint</span> c_num { num_transactions <span class="hljs-keyword">inside</span> {[<span class="hljs-number">3</span>:<span class="hljs-number">10</span>]}; }

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;counter_count_seq&quot;</span>);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();
    counter_seq_item item;

    `uvm_info(get_type_name(),
      <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;Starting count sequence with %0d transactions&quot;</span>, num_transactions),
      UVM_MEDIUM)

    <span class="hljs-comment">// 여러 트랜잭션을 순차적으로 전송</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num_transactions; i++) <span class="hljs-keyword">begin</span>
      item = counter_seq_item::type_id::create(<span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;item_%0d&quot;</span>, i));
      start_item(item);

      <span class="hljs-comment">// ⭐ randomize()로 값 설정 + constraint로 범위 제한</span>
      <span class="hljs-keyword">if</span> (!item<span class="hljs-variable">.randomize</span>() <span class="hljs-keyword">with</span> {
        rst_n  == <span class="hljs-number">1</span>;             <span class="hljs-comment">// 리셋 해제 상태</span>
        enable == <span class="hljs-number">1</span>;             <span class="hljs-comment">// 카운트 활성화</span>
        cycles <span class="hljs-keyword">inside</span> {[<span class="hljs-number">1</span>:<span class="hljs-number">5</span>]};   <span class="hljs-comment">// 1~5 클럭</span>
      }) <span class="hljs-keyword">begin</span>
        `uvm_fatal(get_type_name(), <span class="hljs-string">&quot;Randomization failed!&quot;</span>)
      <span class="hljs-keyword">end</span>

      finish_item(item);
      `uvm_info(get_type_name(),
        <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;  [%0d/%0d] %s&quot;</span>, i+<span class="hljs-number">1</span>, num_transactions, item<span class="hljs-variable">.convert2string</span>()),
        UVM_HIGH)
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">endtask</span>

<span class="hljs-keyword">endclass</span>
</code></pre><p><strong>핵심 패턴: <code>randomize() with {}</code></strong></p>
<p><code>start_item()</code> 다음에 <code>randomize() with {}</code> 구문으로:</p>
<ul>
<li>기본 constraint (클래스에 정의된 <code>c_cycles</code>)와</li>
<li>추가 constraint (inline <code>with {}</code>)를
동시에 적용합니다.</li>
</ul>
<p>이렇게 하면 <strong>시퀀스마다 다른 제약 조건</strong>을 줄 수 있어 유연합니다:</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// 리셋 시퀀스: 항상 rst_n=0</span>
item<span class="hljs-variable">.randomize</span>() <span class="hljs-keyword">with</span> { rst_n == <span class="hljs-number">0</span>; };

<span class="hljs-comment">// 카운트 시퀀스: 항상 rst_n=1, enable=1</span>
item<span class="hljs-variable">.randomize</span>() <span class="hljs-keyword">with</span> { rst_n == <span class="hljs-number">1</span>; enable == <span class="hljs-number">1</span>; };

<span class="hljs-comment">// 완전 랜덤 시퀀스: 제약 없음</span>
item<span class="hljs-variable">.randomize</span>();
</code></pre><h3 id="6-3-4-uvm-do-매크로-간편-표기">6.3.4 `uvm_do 매크로 — 간편 표기</h3>
<p>UVM은 <code>start_item</code>/<code>finish_item</code> 패턴을 간단히 쓸 수 있는 매크로를 제공합니다:</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// 명시적 패턴 (추천)</span>
item = counter_seq_item::type_id::create(<span class="hljs-string">&quot;item&quot;</span>);
start_item(item);
item<span class="hljs-variable">.randomize</span>() <span class="hljs-keyword">with</span> { rst_n == <span class="hljs-number">1</span>; enable == <span class="hljs-number">1</span>; };
finish_item(item);

<span class="hljs-comment">// `uvm_do 매크로 (간편)</span>
`uvm_do(item)                          <span class="hljs-comment">// create + start + randomize + finish</span>

<span class="hljs-comment">// `uvm_do_with 매크로 (간편 + 제약)</span>
`uvm_do_with(item, { rst_n == <span class="hljs-number">1</span>; enable == <span class="hljs-number">1</span>; })
</code></pre><table>
<thead>
<tr>
<th>방식</th>
<th>장점</th>
<th>단점</th>
</tr>
</thead>
<tbody><tr>
<td>명시적 패턴</td>
<td>동작이 명확, 디버깅 쉬움</td>
<td>코드가 길다</td>
</tr>
<tr>
<td>`uvm_do 매크로</td>
<td>코드가 짧다</td>
<td>내부 동작 숨김, late randomization 불가</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>면접 포인트</strong>: &quot;uvm_do와 start_item/finish_item의 차이는?&quot; — <code>uvm_do</code>는 <code>create + start_item + randomize + finish_item</code>을 한 줄로 수행합니다. 명시적 패턴은 <strong>start_item 후에 randomize</strong>할 수 있어 late randomization이 가능합니다. 실무에서는 명시적 패턴을 더 많이 사용합니다.</p>
</blockquote>
<h3 id="6-3-5-시퀀스-조합-마스터-시퀀스">6.3.5 시퀀스 조합: 마스터 시퀀스</h3>
<p>여러 시퀀스를 순서대로 실행하는 마스터 시퀀스를 만들 수 있습니다:</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// 파일: counter_master_seq.sv</span>
<span class="hljs-comment">// 마스터 시퀀스: 리셋 → 카운트 순서로 실행</span>

<span class="hljs-keyword">class</span> counter_master_seq <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(counter_seq_item)</span>;
  `uvm_object_utils(counter_master_seq)

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;counter_master_seq&quot;</span>);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();
    counter_reset_seq reset_seq;
    counter_count_seq count_seq;

    <span class="hljs-comment">// ① 리셋 시퀀스 실행</span>
    `uvm_info(get_type_name(), <span class="hljs-string">&quot;=== Phase 1: Reset ===&quot;</span>, UVM_MEDIUM)
    reset_seq = counter_reset_seq::type_id::create(<span class="hljs-string">&quot;reset_seq&quot;</span>);
    reset_seq<span class="hljs-variable">.start</span>(m_sequencer);  <span class="hljs-comment">// 같은 시퀀서에서 실행</span>

    <span class="hljs-comment">// ② 카운트 시퀀스 실행</span>
    `uvm_info(get_type_name(), <span class="hljs-string">&quot;=== Phase 2: Count ===&quot;</span>, UVM_MEDIUM)
    count_seq = counter_count_seq::type_id::create(<span class="hljs-string">&quot;count_seq&quot;</span>);
    count_seq<span class="hljs-variable">.num_transactions</span> = <span class="hljs-number">5</span>;
    count_seq<span class="hljs-variable">.start</span>(m_sequencer);

    `uvm_info(get_type_name(), <span class="hljs-string">&quot;=== Master sequence completed ===&quot;</span>, UVM_MEDIUM)
  <span class="hljs-keyword">endtask</span>

<span class="hljs-keyword">endclass</span>
</code></pre><p><strong>핵심</strong>: 서브 시퀀스의 <code>start()</code> 호출 시 <code>m_sequencer</code>를 전달합니다. <code>m_sequencer</code>는 현재 시퀀스가 실행 중인 시퀀서를 가리키는 핸들로, 상위 시퀀스에서 <code>start(sequencer)</code> 호출 시 <strong>자동으로 설정</strong>됩니다. 직접 할당할 필요가 없습니다.</p>

<div class="svg-diagram">
<svg viewBox="0 0 600 355" xmlns="http://www.w3.org/2000/svg" style="max-width:600px;width:100%">
  
  <style>
    .diagram-box { fill: #ffffff; stroke: #334155; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-accent { fill: #eff6ff; stroke: #2563eb; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-highlight { fill: #fef3c7; stroke: #f59e0b; stroke-width: 2.5; rx: 10; ry: 10; }
    .diagram-box-dark { fill: #1e293b; stroke: #1e293b; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-run { fill: #fef3c7; stroke: #f59e0b; stroke-width: 3; rx: 10; ry: 10; }
    .diagram-box-green { fill: #ecfdf5; stroke: #10b981; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-purple { fill: #f5f3ff; stroke: #7c3aed; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-red { fill: #fef2f2; stroke: #ef4444; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-gray { fill: #f8fafc; stroke: #94a3b8; stroke-width: 1.5; rx: 8; ry: 8; }
    .diagram-text { font-family: 'Noto Sans KR', sans-serif; fill: #1e293b; }
    .diagram-text-white { font-family: 'Noto Sans KR', sans-serif; fill: #ffffff; }
    .diagram-text-accent { font-family: 'Noto Sans KR', sans-serif; fill: #2563eb; }
    .diagram-text-small { font-family: 'Noto Sans KR', sans-serif; fill: #64748b; font-size: 12px; }
    .diagram-text-code { font-family: 'Fira Code', 'JetBrains Mono', monospace; fill: #1e293b; }
    .diagram-arrow { fill: none; stroke: #64748b; stroke-width: 1.5; }
    .diagram-arrow-accent { fill: none; stroke: #2563eb; stroke-width: 1.5; }
    .diagram-line { stroke: #cbd5e1; stroke-width: 1.5; stroke-dasharray: 6,3; }
  </style>
  <defs>
    <marker id="arrowhead" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#64748b" />
    </marker>
    <marker id="arrowhead-accent" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#2563eb" />
    </marker>
    <marker id="arrowhead-dark" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#1e293b" />
    </marker>
    <marker id="arrowhead-orange" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#f59e0b" />
    </marker>
    <filter id="shadow" x="-5%" y="-5%" width="115%" height="115%">
      <feDropShadow dx="0" dy="2" stdDeviation="3" flood-color="#000" flood-opacity="0.1"/>
    </filter>
  </defs>

  <!-- Title -->
  <text x="300" y="28" text-anchor="middle" class="diagram-text" font-size="15" font-weight="bold">시퀀스 조합 구조</text>

  <!-- Master sequence outer box -->
  <rect x="100" y="45" width="400" height="228" class="diagram-box-accent" filter="url(#shadow)"/>
  <text x="300" y="68" text-anchor="middle" class="diagram-text" font-size="14" font-weight="bold">counter_master_seq</text>
  <text x="120" y="92" text-anchor="start" class="diagram-text-code" font-size="12">body() {</text>

  <!-- Sub-sequence 1: reset -->
  <rect x="150" y="100" width="220" height="40" class="diagram-box-highlight" filter="url(#shadow)"/>
  <text x="260" y="125" text-anchor="middle" class="diagram-text-code" font-size="12">reset_seq.start()</text>

  <!-- Label for reset -->
  <text x="390" y="125" text-anchor="start" class="diagram-text-small" font-size="12">→ 리셋 실행</text>

  <!-- Sequence number ① -->
  <text x="138" y="125" text-anchor="middle" class="diagram-text-accent" font-size="13" font-weight="bold">①</text>

  <!-- Arrow down (thin, proportional) -->
  <line x1="260" y1="140" x2="260" y2="175" class="diagram-arrow-accent" marker-end="url(#arrowhead-accent)" stroke-width="1.5"/>

  <!-- Sub-sequence 2: count -->
  <rect x="150" y="180" width="220" height="40" class="diagram-box-green" filter="url(#shadow)"/>
  <text x="260" y="205" text-anchor="middle" class="diagram-text-code" font-size="12">count_seq.start()</text>

  <!-- Label for count -->
  <text x="390" y="205" text-anchor="start" class="diagram-text-small" font-size="12">→ 카운트 실행</text>

  <!-- Sequence number ② -->
  <text x="138" y="205" text-anchor="middle" class="diagram-text-accent" font-size="13" font-weight="bold">②</text>

  <!-- Closing brace -->
  <text x="120" y="255" text-anchor="start" class="diagram-text-code" font-size="12">}</text>

  <!-- Arrow down to sequencer -->
  <line x1="300" y1="273" x2="300" y2="300" class="diagram-arrow" marker-end="url(#arrowhead-dark)" stroke-width="1.5"/>

  <!-- m_sequencer box -->
  <rect x="175" y="305" width="250" height="38" class="diagram-box-purple" filter="url(#shadow)"/>
  <text x="300" y="329" text-anchor="middle" class="diagram-text" font-size="13" font-weight="bold">m_sequencer (같은 시퀀서)</text>
</svg>
</div><hr>
<h2 id="6-4-시퀀서와-드라이버-연결">6.4 시퀀서와 드라이버 연결</h2>
<blockquote>
<p><strong>이 절의 목표</strong>: 시퀀서의 역할을 이해하고, 드라이버가 시퀀서로부터 트랜잭션을 받아 처리하는 패턴을 배웁니다.</p>
</blockquote>
<h3 id="6-4-1-시퀀서-uvm-sequencer">6.4.1 시퀀서 (uvm_sequencer)</h3>
<p>시퀀서는 시퀀스와 드라이버 사이의 <strong>중개자</strong>입니다. 택배 비유에서 택배 회사 본사에 해당합니다:</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// 파일: counter_sequencer.sv</span>
<span class="hljs-comment">// 시퀀서: 대부분의 경우 이렇게 간단합니다!</span>

<span class="hljs-keyword">class</span> counter_sequencer <span class="hljs-keyword">extends</span> uvm_sequencer <span class="hljs-variable">#(counter_seq_item)</span>;
  `uvm_component_utils(counter_sequencer)

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>
<span class="hljs-keyword">endclass</span>
</code></pre><blockquote>
<p><strong>시퀀서가 이렇게 간단한 이유</strong>: <code>uvm_sequencer</code> 기본 클래스가 대부분의 기능을 이미 제공하기 때문입니다. 시퀀스 큐잉, 중재(arbitration), 드라이버 연결 등이 모두 내장되어 있습니다. 사용자는 <strong>트랜잭션 타입만 지정</strong>하면 됩니다.</p>
</blockquote>
<h3 id="6-4-2-드라이버-리팩토링-get-next-item-item-done">6.4.2 드라이버 리팩토링: get_next_item()/item_done()</h3>
<p>Chapter 5의 드라이버를 시퀀스 기반으로 리팩토링합니다. 핵심 변화는 <strong>시퀀서로부터 트랜잭션을 받아서</strong> 신호를 구동하는 것입니다:</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// 파일: counter_driver.sv</span>
<span class="hljs-comment">// Chapter 6 방식: 시퀀서에서 트랜잭션을 받아 신호 구동</span>

<span class="hljs-keyword">class</span> counter_driver <span class="hljs-keyword">extends</span> uvm_driver <span class="hljs-variable">#(counter_seq_item)</span>;
  `uvm_component_utils(counter_driver)

  <span class="hljs-keyword">virtual</span> counter_if vif;

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);
    <span class="hljs-keyword">if</span> (!uvm_config_db<span class="hljs-variable">#(virtual counter_if)::get(this, &quot;&quot;, &quot;vif&quot;, vif))</span>
      `uvm_fatal(get_type_name(), <span class="hljs-string">&quot;Virtual interface not found!&quot;</span>)
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-comment">// ⭐ 핵심 변경: 무한 루프로 트랜잭션을 계속 받아 처리</span>
  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> run_phase(uvm_phase phase);
    counter_seq_item item;

    <span class="hljs-keyword">forever</span> <span class="hljs-keyword">begin</span>
      <span class="hljs-comment">// ① 시퀀서에서 다음 트랜잭션 가져오기 (대기)</span>
      seq_item_port<span class="hljs-variable">.get_next_item</span>(item);

      <span class="hljs-comment">// ② 트랜잭션 내용대로 신호 구동</span>
      drive_item(item);

      <span class="hljs-comment">// ③ 처리 완료 알림</span>
      seq_item_port<span class="hljs-variable">.item_done</span>();
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">endtask</span>

  <span class="hljs-comment">// 실제 신호 구동 로직</span>
  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> drive_item(counter_seq_item item);
    vif<span class="hljs-variable">.rst_n</span>  &lt;= item<span class="hljs-variable">.rst_n</span>;
    vif<span class="hljs-variable">.enable</span> &lt;= item<span class="hljs-variable">.enable</span>;
    <span class="hljs-keyword">repeat</span>(item<span class="hljs-variable">.cycles</span>) @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>);
  <span class="hljs-keyword">endtask</span>

<span class="hljs-keyword">endclass</span>
</code></pre><p><strong>핵심 패턴: <code>get_next_item()</code> → 구동 → <code>item_done()</code></strong></p>
<table>
<thead>
<tr>
<th>단계</th>
<th>메서드</th>
<th>하는 일</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><code>get_next_item(item)</code></td>
<td>시퀀서에서 트랜잭션을 받아옴 (없으면 대기)</td>
</tr>
<tr>
<td>2</td>
<td><code>drive_item(item)</code></td>
<td>트랜잭션 내용대로 DUT 신호 구동</td>
</tr>
<tr>
<td>3</td>
<td><code>item_done()</code></td>
<td>처리 완료를 시퀀서에게 알림</td>
</tr>
</tbody></table>
<blockquote>
<p><strong><code>forever</code> 루프가 중요한 이유</strong>: 드라이버는 시뮬레이션이 끝날 때까지 계속 트랜잭션을 받아 처리해야 합니다. 시퀀스가 끝나면 <code>get_next_item()</code>에서 자연스럽게 대기합니다.</p>
</blockquote>
<blockquote>
<p><strong>드라이버에 <code>raise_objection</code>이 없는 이유</strong>: objection은 시뮬레이션 종료를 제어합니다. 시퀀스 기반에서는 <strong>test 클래스</strong>가 <code>raise_objection</code>/<code>drop_objection</code>을 관리하므로, 드라이버는 시퀀서에서 트랜잭션을 받아 처리하는 역할만 합니다.</p>
</blockquote>
<blockquote>
<p><strong>주의</strong>: <code>get_next_item()</code>과 <code>item_done()</code>은 반드시 <strong>쌍으로</strong> 호출해야 합니다. <code>item_done()</code>을 빠뜨리면 시퀀서가 영원히 대기합니다!</p>
</blockquote>
<h3 id="6-4-3-seq-item-port-드라이버와-시퀀서의-연결">6.4.3 seq_item_port — 드라이버와 시퀀서의 연결</h3>
<p><code>seq_item_port</code>는 <code>uvm_driver</code> 기본 클래스에 이미 선언되어 있습니다. agent의 <code>connect_phase</code>에서 드라이버와 시퀀서를 연결합니다:</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// agent의 connect_phase에서 연결</span>
<span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> connect_phase(uvm_phase phase);
  <span class="hljs-keyword">super</span><span class="hljs-variable">.connect_phase</span>(phase);
  drv<span class="hljs-variable">.seq_item_port</span><span class="hljs-variable">.connect</span>(sqr<span class="hljs-variable">.seq_item_export</span>);
<span class="hljs-keyword">endfunction</span>
</code></pre><blockquote>
<p><strong>이 한 줄이 전부입니다!</strong> <code>drv.seq_item_port.connect(sqr.seq_item_export)</code> — 이 연결 덕분에 시퀀스가 <code>start_item()</code>/<code>finish_item()</code>으로 보낸 트랜잭션이 드라이버의 <code>get_next_item()</code>으로 전달됩니다. 내부 동작(TLM 포트)은 Chapter 7에서 자세히 다룹니다. 지금은 이 <strong>한 줄 연결 패턴</strong>만 기억하세요.</p>
</blockquote>
<h3 id="6-4-4-시퀀스-실행-test에서-start-호출">6.4.4 시퀀스 실행: test에서 start() 호출</h3>
<p>시퀀스는 test 클래스의 <code>run_phase</code>에서 시작합니다:</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// test의 run_phase에서 시퀀스 실행</span>
<span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> run_phase(uvm_phase phase);
  counter_master_seq master_seq;

  phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);

  master_seq = counter_master_seq::type_id::create(<span class="hljs-string">&quot;master_seq&quot;</span>);
  master_seq<span class="hljs-variable">.start</span>(env<span class="hljs-variable">.agent</span><span class="hljs-variable">.sqr</span>);  <span class="hljs-comment">// ⭐ 시퀀서를 지정하여 실행</span>

  phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);
<span class="hljs-keyword">endtask</span>
</code></pre><p><strong><code>start()</code> 메서드의 인수는 시퀀서</strong>입니다. 이것이 시퀀스와 시퀀서를 연결하는 마지막 고리입니다.</p>

<div class="svg-diagram">
<svg viewBox="0 0 780 350" xmlns="http://www.w3.org/2000/svg" style="max-width:780px;width:100%">
  
  <style>
    .diagram-box { fill: #ffffff; stroke: #334155; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-accent { fill: #eff6ff; stroke: #2563eb; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-highlight { fill: #fef3c7; stroke: #f59e0b; stroke-width: 2.5; rx: 10; ry: 10; }
    .diagram-box-dark { fill: #1e293b; stroke: #1e293b; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-run { fill: #fef3c7; stroke: #f59e0b; stroke-width: 3; rx: 10; ry: 10; }
    .diagram-box-green { fill: #ecfdf5; stroke: #10b981; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-purple { fill: #f5f3ff; stroke: #7c3aed; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-red { fill: #fef2f2; stroke: #ef4444; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-gray { fill: #f8fafc; stroke: #94a3b8; stroke-width: 1.5; rx: 8; ry: 8; }
    .diagram-text { font-family: 'Noto Sans KR', sans-serif; fill: #1e293b; }
    .diagram-text-white { font-family: 'Noto Sans KR', sans-serif; fill: #ffffff; }
    .diagram-text-accent { font-family: 'Noto Sans KR', sans-serif; fill: #2563eb; }
    .diagram-text-small { font-family: 'Noto Sans KR', sans-serif; fill: #64748b; font-size: 12px; }
    .diagram-text-code { font-family: 'Fira Code', 'JetBrains Mono', monospace; fill: #1e293b; }
    .diagram-arrow { fill: none; stroke: #64748b; stroke-width: 1.5; }
    .diagram-arrow-accent { fill: none; stroke: #2563eb; stroke-width: 1.5; }
    .diagram-line { stroke: #cbd5e1; stroke-width: 1.5; stroke-dasharray: 6,3; }
  </style>
  <defs>
    <marker id="arrowhead" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#64748b" />
    </marker>
    <marker id="arrowhead-accent" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#2563eb" />
    </marker>
    <marker id="arrowhead-dark" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#1e293b" />
    </marker>
    <marker id="arrowhead-orange" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#f59e0b" />
    </marker>
    <filter id="shadow" x="-5%" y="-5%" width="115%" height="115%">
      <feDropShadow dx="0" dy="2" stdDeviation="3" flood-color="#000" flood-opacity="0.1"/>
    </filter>
  </defs>

  <!-- Title -->
  <text x="390" y="25" text-anchor="middle" class="diagram-text" font-size="15" font-weight="bold">전체 연결 구조</text>

  <!-- Test.run_phase at top -->
  <rect x="280" y="42" width="220" height="46" class="diagram-box-purple" filter="url(#shadow)"/>
  <text x="390" y="62" text-anchor="middle" class="diagram-text" font-size="13" font-weight="bold">Test.run_phase</text>
  <text x="390" y="80" text-anchor="middle" class="diagram-text-code" font-size="11">seq.start(sqr)</text>

  <!-- Arrow down -->
  <line x1="390" y1="88" x2="390" y2="128" class="diagram-arrow-accent" marker-end="url(#arrowhead-accent)" stroke-width="1.5"/>

  <!-- Sequence box -->
  <rect x="50" y="138" width="200" height="74" class="diagram-box-accent" filter="url(#shadow)"/>
  <text x="150" y="163" text-anchor="middle" class="diagram-text" font-size="14" font-weight="bold">Sequence</text>
  <text x="150" y="181" text-anchor="middle" class="diagram-text-accent" font-size="12">(What)</text>
  <text x="150" y="200" text-anchor="middle" class="diagram-text-code" font-size="10">start_item / finish_item</text>

  <!-- Arrow Seq → Sqr -->
  <line x1="250" y1="172" x2="298" y2="172" class="diagram-arrow-accent" marker-end="url(#arrowhead-accent)" stroke-width="1.5"/>

  <!-- Sequencer box -->
  <rect x="305" y="141" width="170" height="68" class="diagram-box-green" filter="url(#shadow)"/>
  <text x="390" y="168" text-anchor="middle" class="diagram-text" font-size="14" font-weight="bold">Sequencer</text>
  <text x="390" y="190" text-anchor="middle" class="diagram-text-small" font-size="12">(중개자)</text>

  <!-- Arrow Sqr → Drv (forward) -->
  <line x1="475" y1="162" x2="523" y2="162" class="diagram-arrow" marker-end="url(#arrowhead-dark)" stroke-width="1.5"/>
  <text x="499" y="155" text-anchor="middle" class="diagram-text-small" font-size="10">get_next_item</text>

  <!-- Arrow Drv → Sqr (return) -->
  <line x1="530" y1="188" x2="475" y2="188" class="diagram-arrow" marker-end="url(#arrowhead)" stroke-width="1.5" stroke-dasharray="5,3"/>
  <text x="503" y="203" text-anchor="middle" class="diagram-text-small" font-size="10">item_done</text>

  <!-- Driver box -->
  <rect x="530" y="138" width="200" height="74" class="diagram-box-highlight" filter="url(#shadow)"/>
  <text x="630" y="163" text-anchor="middle" class="diagram-text" font-size="14" font-weight="bold">Driver</text>
  <text x="630" y="181" text-anchor="middle" class="diagram-text" font-size="12">(How)</text>
  <text x="630" y="200" text-anchor="middle" class="diagram-text-code" font-size="10">vif.rst_n &lt;= item.rst_n</text>

  <!-- Annotation arrow -->
  <line x1="390" y1="209" x2="390" y2="250" class="diagram-arrow" marker-end="url(#arrowhead)" stroke-width="1.5" stroke-dasharray="4,3"/>

  <!-- Connect phase annotation -->
  <rect x="170" y="256" width="440" height="38" rx="6" ry="6" fill="#f0fdf4" stroke="#10b981" stroke-width="1.5"/>
  <text x="390" y="280" text-anchor="middle" class="diagram-text-code" font-size="11">drv.seq_item_port.connect(sqr.seq_item_export)</text>

  <!-- Label -->
  <text x="390" y="320" text-anchor="middle" class="diagram-text-small" font-size="12">connect_phase에서 연결</text>
</svg>
</div><blockquote>
<p><strong>면접 포인트</strong>: &quot;시퀀스를 실행하는 3단계를 설명하세요&quot; —</p>
<ol>
<li>시퀀스 객체 생성 (<code>type_id::create</code>)</li>
<li>시퀀서 지정하여 실행 (<code>seq.start(sequencer)</code>)</li>
<li>시퀀스의 <code>body()</code>가 자동 호출되어 트랜잭션 전송</li>
</ol>
</blockquote>
<hr>
<h2 id="6-5-종합-시퀀스-기반-테스트벤치">6.5 종합: 시퀀스 기반 테스트벤치</h2>
<blockquote>
<p><strong>이 절의 목표</strong>: Chapter 5의 테스트벤치를 시퀀스 기반으로 리팩토링합니다. 완전한 코드를 단계별로 조립합니다.</p>
</blockquote>
<h3 id="6-5-1-before-after-비교">6.5.1 Before → After 비교</h3>

<div class="svg-diagram">
<svg viewBox="0 0 780 465" xmlns="http://www.w3.org/2000/svg" style="max-width:780px;width:100%">
  
  <style>
    .diagram-box { fill: #ffffff; stroke: #334155; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-accent { fill: #eff6ff; stroke: #2563eb; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-highlight { fill: #fef3c7; stroke: #f59e0b; stroke-width: 2.5; rx: 10; ry: 10; }
    .diagram-box-dark { fill: #1e293b; stroke: #1e293b; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-run { fill: #fef3c7; stroke: #f59e0b; stroke-width: 3; rx: 10; ry: 10; }
    .diagram-box-green { fill: #ecfdf5; stroke: #10b981; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-purple { fill: #f5f3ff; stroke: #7c3aed; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-red { fill: #fef2f2; stroke: #ef4444; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-gray { fill: #f8fafc; stroke: #94a3b8; stroke-width: 1.5; rx: 8; ry: 8; }
    .diagram-text { font-family: 'Noto Sans KR', sans-serif; fill: #1e293b; }
    .diagram-text-white { font-family: 'Noto Sans KR', sans-serif; fill: #ffffff; }
    .diagram-text-accent { font-family: 'Noto Sans KR', sans-serif; fill: #2563eb; }
    .diagram-text-small { font-family: 'Noto Sans KR', sans-serif; fill: #64748b; font-size: 12px; }
    .diagram-text-code { font-family: 'Fira Code', 'JetBrains Mono', monospace; fill: #1e293b; }
    .diagram-arrow { fill: none; stroke: #64748b; stroke-width: 1.5; }
    .diagram-arrow-accent { fill: none; stroke: #2563eb; stroke-width: 1.5; }
    .diagram-line { stroke: #cbd5e1; stroke-width: 1.5; stroke-dasharray: 6,3; }
  </style>
  <defs>
    <marker id="arrowhead" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#64748b" />
    </marker>
    <marker id="arrowhead-accent" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#2563eb" />
    </marker>
    <marker id="arrowhead-dark" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#1e293b" />
    </marker>
    <marker id="arrowhead-orange" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#f59e0b" />
    </marker>
    <filter id="shadow" x="-5%" y="-5%" width="115%" height="115%">
      <feDropShadow dx="0" dy="2" stdDeviation="3" flood-color="#000" flood-opacity="0.1"/>
    </filter>
  </defs>

  <!-- Dividing line -->
  <line x1="390" y1="10" x2="390" y2="455" stroke="#cbd5e1" stroke-width="2" stroke-dasharray="8,4"/>

  <!-- ===== LEFT: Chapter 5 ===== -->
  <text x="195" y="30" text-anchor="middle" class="diagram-text" font-size="15" font-weight="bold">Chapter 5 (하드코딩)</text>

  <!-- Ch5 Test -->
  <rect x="95" y="55" width="200" height="50" class="diagram-box-gray" filter="url(#shadow)"/>
  <text x="195" y="77" text-anchor="middle" class="diagram-text" font-size="13" font-weight="bold">Test</text>
  <text x="195" y="95" text-anchor="middle" class="diagram-text-small" font-size="11">(run_phase 없음)</text>

  <!-- Disconnected indicator -->
  <line x1="195" y1="115" x2="195" y2="195" stroke="#cbd5e1" stroke-width="1.5" stroke-dasharray="5,5"/>
  <text x="195" y="162" text-anchor="middle" class="diagram-text-small" font-size="11" fill="#94a3b8">직접 연결 없음</text>
  <text x="185" y="155" text-anchor="middle" font-size="16" fill="#ef4444" font-weight="bold">✕</text>

  <!-- Ch5 Driver (big, red) -->
  <rect x="70" y="205" width="250" height="100" class="diagram-box-red" filter="url(#shadow)"/>
  <text x="195" y="235" text-anchor="middle" class="diagram-text" font-size="14" font-weight="bold">Driver</text>
  <text x="195" y="257" text-anchor="middle" class="diagram-text-code" font-size="11">시나리오 + 신호 구동</text>
  <text x="195" y="278" text-anchor="middle" class="diagram-text-small" font-size="11">(What + How 혼합)</text>

  <!-- ===== RIGHT: Chapter 6 ===== -->
  <text x="585" y="30" text-anchor="middle" class="diagram-text" font-size="15" font-weight="bold">Chapter 6 (시퀀스 기반)</text>

  <!-- Ch6 Test -->
  <rect x="485" y="55" width="200" height="50" class="diagram-box-purple" filter="url(#shadow)"/>
  <text x="585" y="77" text-anchor="middle" class="diagram-text" font-size="13" font-weight="bold">Test</text>
  <text x="585" y="95" text-anchor="middle" class="diagram-text-code" font-size="11">seq.start(sqr)</text>

  <!-- Arrow Test → Sequence -->
  <line x1="585" y1="105" x2="585" y2="138" class="diagram-arrow-accent" marker-end="url(#arrowhead-accent)" stroke-width="1.5"/>

  <!-- Ch6 Sequence -->
  <rect x="485" y="145" width="200" height="56" class="diagram-box-accent" filter="url(#shadow)"/>
  <text x="585" y="168" text-anchor="middle" class="diagram-text" font-size="13" font-weight="bold">Sequence</text>
  <text x="585" y="188" text-anchor="middle" class="diagram-text-code" font-size="11">start_item / finish_item</text>

  <!-- Arrow Sequence → Sequencer -->
  <line x1="585" y1="201" x2="585" y2="234" class="diagram-arrow-accent" marker-end="url(#arrowhead-accent)" stroke-width="1.5"/>

  <!-- Ch6 Sequencer -->
  <rect x="510" y="241" width="150" height="44" class="diagram-box-green" filter="url(#shadow)"/>
  <text x="585" y="268" text-anchor="middle" class="diagram-text" font-size="13" font-weight="bold">Sequencer</text>

  <!-- Arrow Sequencer → Driver -->
  <line x1="585" y1="285" x2="585" y2="318" class="diagram-arrow" marker-end="url(#arrowhead-dark)" stroke-width="1.5"/>

  <!-- Ch6 Driver -->
  <rect x="485" y="325" width="200" height="56" class="diagram-box-highlight" filter="url(#shadow)"/>
  <text x="585" y="348" text-anchor="middle" class="diagram-text" font-size="13" font-weight="bold">Driver</text>
  <text x="585" y="368" text-anchor="middle" class="diagram-text-code" font-size="11">get_next_item → 신호 구동</text>

  <!-- Labels at bottom -->
  <rect x="70" y="410" width="250" height="36" rx="6" ry="6" fill="#fef2f2" stroke="#ef4444" stroke-width="1.5"/>
  <text x="195" y="433" text-anchor="middle" class="diagram-text" font-size="12">시나리오 변경 = 드라이버 수정</text>

  <rect x="460" y="410" width="250" height="36" rx="6" ry="6" fill="#eff6ff" stroke="#2563eb" stroke-width="1.5"/>
  <text x="585" y="433" text-anchor="middle" class="diagram-text" font-size="12">시나리오 변경 = 새 시퀀스 추가</text>
</svg>
</div><h3 id="6-5-2-완전한-코드">6.5.2 완전한 코드</h3>
<p>이제 모든 부분을 합쳐봅시다. 이 코드는 Chapter 5의 테스트벤치를 시퀀스 기반으로 리팩토링한 것입니다:</p>
<p><strong>[예제 6-1] 시퀀스 기반 완전한 UVM 테스트벤치</strong></p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// ================================================================</span>
<span class="hljs-comment">// [예제 6-1] 시퀀스 기반 UVM 테스트벤치</span>
<span class="hljs-comment">// 파일: counter_seq_tb.sv</span>
<span class="hljs-comment">// Chapter 5의 테스트벤치를 시퀀스 기반으로 리팩토링</span>
<span class="hljs-comment">// ================================================================</span>

<span class="hljs-comment">// ---- Step 1: Interface (Ch.5와 동일) ----</span>
<span class="hljs-keyword">interface</span> counter_if(<span class="hljs-keyword">input</span> <span class="hljs-keyword">logic</span> clk);
  <span class="hljs-keyword">logic</span>       rst_n;
  <span class="hljs-keyword">logic</span>       enable;
  <span class="hljs-keyword">logic</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] count;
<span class="hljs-keyword">endinterface</span>

<span class="hljs-comment">// ---- Step 2: DUT (Ch.5와 동일) ----</span>
<span class="hljs-keyword">module</span> counter (
  <span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span>       clk,
  <span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span>       rst_n,
  <span class="hljs-keyword">input</span>  <span class="hljs-keyword">logic</span>       enable,
  <span class="hljs-keyword">output</span> <span class="hljs-keyword">logic</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] count
);
  <span class="hljs-keyword">always_ff</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> rst_n) <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (!rst_n)
      count &lt;= <span class="hljs-number">4&#x27;b0</span>;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (enable)
      count &lt;= count + <span class="hljs-number">1</span>;
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>

<span class="hljs-comment">// ---- Step 3: 트랜잭션 (NEW!) ----</span>
<span class="hljs-keyword">class</span> counter_seq_item <span class="hljs-keyword">extends</span> uvm_sequence_item;
  <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span>       rst_n;
  <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span>       enable;
  <span class="hljs-keyword">rand</span> <span class="hljs-keyword">int</span>       cycles;
  <span class="hljs-keyword">logic</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>]    count;

  <span class="hljs-keyword">constraint</span> c_cycles { cycles <span class="hljs-keyword">inside</span> {[<span class="hljs-number">1</span>:<span class="hljs-number">20</span>]}; }

  `uvm_object_utils_begin(counter_seq_item)
    `uvm_field_int(rst_n,  UVM_ALL_ON)
    `uvm_field_int(enable, UVM_ALL_ON)
    `uvm_field_int(cycles, UVM_ALL_ON)
    `uvm_field_int(count,  UVM_ALL_ON)
  `uvm_object_utils_end

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;counter_seq_item&quot;</span>);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">string</span> convert2string();
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;rst_n=%0b enable=%0b cycles=%0d count=%0h&quot;</span>,
                     rst_n, enable, cycles, count);
  <span class="hljs-keyword">endfunction</span>
<span class="hljs-keyword">endclass</span>

<span class="hljs-comment">// ---- Step 4: 리셋 시퀀스 (NEW!) ----</span>
<span class="hljs-keyword">class</span> counter_reset_seq <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(counter_seq_item)</span>;
  `uvm_object_utils(counter_reset_seq)

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;counter_reset_seq&quot;</span>);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();
    counter_seq_item item;
    item = counter_seq_item::type_id::create(<span class="hljs-string">&quot;item&quot;</span>);
    start_item(item);
    item<span class="hljs-variable">.rst_n</span>  = <span class="hljs-number">0</span>;
    item<span class="hljs-variable">.enable</span> = <span class="hljs-number">0</span>;
    item<span class="hljs-variable">.cycles</span> = <span class="hljs-number">2</span>;
    finish_item(item);
    `uvm_info(get_type_name(), <span class="hljs-string">&quot;Reset done&quot;</span>, UVM_MEDIUM)
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>

<span class="hljs-comment">// ---- Step 5: 카운트 시퀀스 (NEW!) ----</span>
<span class="hljs-keyword">class</span> counter_count_seq <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(counter_seq_item)</span>;
  `uvm_object_utils(counter_count_seq)

  <span class="hljs-keyword">rand</span> <span class="hljs-keyword">int</span> num_transactions;
  <span class="hljs-keyword">constraint</span> c_num { num_transactions <span class="hljs-keyword">inside</span> {[<span class="hljs-number">3</span>:<span class="hljs-number">10</span>]}; }

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;counter_count_seq&quot;</span>);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();
    counter_seq_item item;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num_transactions; i++) <span class="hljs-keyword">begin</span>
      item = counter_seq_item::type_id::create(<span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;item_%0d&quot;</span>, i));
      start_item(item);
      <span class="hljs-keyword">if</span> (!item<span class="hljs-variable">.randomize</span>() <span class="hljs-keyword">with</span> {
        rst_n  == <span class="hljs-number">1</span>;
        enable == <span class="hljs-number">1</span>;
        cycles <span class="hljs-keyword">inside</span> {[<span class="hljs-number">1</span>:<span class="hljs-number">5</span>]};
      }) `uvm_fatal(get_type_name(), <span class="hljs-string">&quot;Randomization failed!&quot;</span>)
      finish_item(item);
      `uvm_info(get_type_name(),
        <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;[%0d/%0d] %s&quot;</span>, i+<span class="hljs-number">1</span>, num_transactions, item<span class="hljs-variable">.convert2string</span>()),
        UVM_HIGH)
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>

<span class="hljs-comment">// ---- Step 6: 마스터 시퀀스 (NEW!) ----</span>
<span class="hljs-keyword">class</span> counter_master_seq <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(counter_seq_item)</span>;
  `uvm_object_utils(counter_master_seq)

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;counter_master_seq&quot;</span>);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();
    counter_reset_seq reset_seq;
    counter_count_seq count_seq;

    `uvm_info(get_type_name(), <span class="hljs-string">&quot;=== Phase 1: Reset ===&quot;</span>, UVM_MEDIUM)
    reset_seq = counter_reset_seq::type_id::create(<span class="hljs-string">&quot;reset_seq&quot;</span>);
    reset_seq<span class="hljs-variable">.start</span>(m_sequencer);

    `uvm_info(get_type_name(), <span class="hljs-string">&quot;=== Phase 2: Count ===&quot;</span>, UVM_MEDIUM)
    count_seq = counter_count_seq::type_id::create(<span class="hljs-string">&quot;count_seq&quot;</span>);
    count_seq<span class="hljs-variable">.num_transactions</span> = <span class="hljs-number">5</span>;
    count_seq<span class="hljs-variable">.start</span>(m_sequencer);

    `uvm_info(get_type_name(), <span class="hljs-string">&quot;=== Master sequence done ===&quot;</span>, UVM_MEDIUM)
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>

<span class="hljs-comment">// ---- Step 7: 시퀀서 (NEW!) ----</span>
<span class="hljs-keyword">class</span> counter_sequencer <span class="hljs-keyword">extends</span> uvm_sequencer <span class="hljs-variable">#(counter_seq_item)</span>;
  `uvm_component_utils(counter_sequencer)

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>
<span class="hljs-keyword">endclass</span>

<span class="hljs-comment">// ---- Step 8: 드라이버 (리팩토링!) ----</span>
<span class="hljs-keyword">class</span> counter_driver <span class="hljs-keyword">extends</span> uvm_driver <span class="hljs-variable">#(counter_seq_item)</span>;
  `uvm_component_utils(counter_driver)

  <span class="hljs-keyword">virtual</span> counter_if vif;

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);
    <span class="hljs-keyword">if</span> (!uvm_config_db<span class="hljs-variable">#(virtual counter_if)::get(this, &quot;&quot;, &quot;vif&quot;, vif))</span>
      `uvm_fatal(get_type_name(), <span class="hljs-string">&quot;Virtual interface not found!&quot;</span>)
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> run_phase(uvm_phase phase);
    counter_seq_item item;
    <span class="hljs-keyword">forever</span> <span class="hljs-keyword">begin</span>
      seq_item_port<span class="hljs-variable">.get_next_item</span>(item);
      drive_item(item);
      seq_item_port<span class="hljs-variable">.item_done</span>();
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">endtask</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> drive_item(counter_seq_item item);
    vif<span class="hljs-variable">.rst_n</span>  &lt;= item<span class="hljs-variable">.rst_n</span>;
    vif<span class="hljs-variable">.enable</span> &lt;= item<span class="hljs-variable">.enable</span>;
    <span class="hljs-keyword">repeat</span>(item<span class="hljs-variable">.cycles</span>) @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>);
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>

<span class="hljs-comment">// ---- Step 9: 모니터 (Ch.5와 동일) ----</span>
<span class="hljs-keyword">class</span> counter_monitor <span class="hljs-keyword">extends</span> uvm_monitor;
  `uvm_component_utils(counter_monitor)

  <span class="hljs-keyword">virtual</span> counter_if vif;

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);
    <span class="hljs-keyword">if</span> (!uvm_config_db<span class="hljs-variable">#(virtual counter_if)::get(this, &quot;&quot;, &quot;vif&quot;, vif))</span>
      `uvm_fatal(get_type_name(), <span class="hljs-string">&quot;Virtual interface not found!&quot;</span>)
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> run_phase(uvm_phase phase);
    <span class="hljs-keyword">forever</span> <span class="hljs-keyword">begin</span>
      @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>);
      #<span class="hljs-number">1</span>;  <span class="hljs-comment">// 신호 안정화 대기 (Ch.7에서 clocking block으로 개선)</span>
      `uvm_info(get_type_name(),
        <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;rst_n=%0b enable=%0b count=%0d&quot;</span>,
                  vif<span class="hljs-variable">.rst_n</span>, vif<span class="hljs-variable">.enable</span>, vif<span class="hljs-variable">.count</span>),
        UVM_HIGH)
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>

<span class="hljs-comment">// ---- Step 10: 에이전트 (시퀀서 추가!) ----</span>
<span class="hljs-keyword">class</span> counter_agent <span class="hljs-keyword">extends</span> uvm_agent;
  `uvm_component_utils(counter_agent)

  counter_sequencer sqr;   <span class="hljs-comment">// ⭐ 시퀀서 추가</span>
  counter_driver    drv;
  counter_monitor   mon;

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);
    sqr = counter_sequencer::type_id::create(<span class="hljs-string">&quot;sqr&quot;</span>, <span class="hljs-keyword">this</span>);  <span class="hljs-comment">// ⭐</span>
    drv = counter_driver::type_id::create(<span class="hljs-string">&quot;drv&quot;</span>, <span class="hljs-keyword">this</span>);
    mon = counter_monitor::type_id::create(<span class="hljs-string">&quot;mon&quot;</span>, <span class="hljs-keyword">this</span>);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-comment">// ⭐ 시퀀서와 드라이버 연결</span>
  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> connect_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.connect_phase</span>(phase);
    drv<span class="hljs-variable">.seq_item_port</span><span class="hljs-variable">.connect</span>(sqr<span class="hljs-variable">.seq_item_export</span>);
  <span class="hljs-keyword">endfunction</span>
<span class="hljs-keyword">endclass</span>

<span class="hljs-comment">// ---- Step 11: 환경 (Ch.5와 유사) ----</span>
<span class="hljs-keyword">class</span> counter_env <span class="hljs-keyword">extends</span> uvm_env;
  `uvm_component_utils(counter_env)

  counter_agent agent;

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);
    agent = counter_agent::type_id::create(<span class="hljs-string">&quot;agent&quot;</span>, <span class="hljs-keyword">this</span>);
  <span class="hljs-keyword">endfunction</span>
<span class="hljs-keyword">endclass</span>

<span class="hljs-comment">// ---- Step 12: 테스트 (시퀀스 실행!) ----</span>
<span class="hljs-keyword">class</span> counter_test <span class="hljs-keyword">extends</span> uvm_test;
  `uvm_component_utils(counter_test)

  counter_env env;

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);
    env = counter_env::type_id::create(<span class="hljs-string">&quot;env&quot;</span>, <span class="hljs-keyword">this</span>);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-comment">// ⭐ 핵심 변경: 시퀀스를 생성하고 시퀀서에서 실행</span>
  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> run_phase(uvm_phase phase);
    counter_master_seq seq;

    phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);

    seq = counter_master_seq::type_id::create(<span class="hljs-string">&quot;seq&quot;</span>);
    seq<span class="hljs-variable">.start</span>(env<span class="hljs-variable">.agent</span><span class="hljs-variable">.sqr</span>);  <span class="hljs-comment">// 시퀀서 지정</span>

    #<span class="hljs-number">100</span>;  <span class="hljs-comment">// 추가 관찰 시간</span>
    phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>

<span class="hljs-comment">// ---- Step 13: Top 모듈 (Ch.5와 유사) ----</span>
<span class="hljs-keyword">module</span> top;
  <span class="hljs-keyword">logic</span> clk;

  <span class="hljs-comment">// 클럭 생성</span>
  <span class="hljs-keyword">initial</span> clk = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">always</span> #<span class="hljs-number">5</span> clk = ~clk;

  <span class="hljs-comment">// Interface &amp; DUT</span>
  counter_if vif(clk);
  counter dut(
    <span class="hljs-variable">.clk</span>(clk),
    <span class="hljs-variable">.rst_n</span>(vif<span class="hljs-variable">.rst_n</span>),
    <span class="hljs-variable">.enable</span>(vif<span class="hljs-variable">.enable</span>),
    <span class="hljs-variable">.count</span>(vif<span class="hljs-variable">.count</span>)
  );

  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span>
    <span class="hljs-comment">// Virtual interface를 config_db에 등록</span>
    uvm_config_db<span class="hljs-variable">#(virtual counter_if)::set(null, &quot;*&quot;, &quot;vif&quot;, vif)</span>;
    run_test(<span class="hljs-string">&quot;counter_test&quot;</span>);
  <span class="hljs-keyword">end</span>

  <span class="hljs-comment">// 파형 덤프</span>
  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span>
    <span class="hljs-built_in">$dumpfile</span>(<span class="hljs-string">&quot;counter_seq.vcd&quot;</span>);
    <span class="hljs-built_in">$dumpvars</span>(<span class="hljs-number">0</span>, top);
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</code></pre><h3 id="6-5-3-ch-5-대비-변경-사항-정리">6.5.3 Ch.5 대비 변경 사항 정리</h3>
<table>
<thead>
<tr>
<th>항목</th>
<th>Chapter 5</th>
<th>Chapter 6</th>
</tr>
</thead>
<tbody><tr>
<td>트랜잭션</td>
<td>없음 (직접 신호)</td>
<td><code>counter_seq_item</code> 클래스</td>
</tr>
<tr>
<td>시나리오 위치</td>
<td>드라이버 안에 하드코딩</td>
<td><code>counter_sequence</code> 클래스로 분리</td>
</tr>
<tr>
<td>드라이버 역할</td>
<td>What + How</td>
<td><strong>How만</strong> (<code>get_next_item</code> → 구동)</td>
</tr>
<tr>
<td>시퀀서</td>
<td>없음</td>
<td><code>counter_sequencer</code> 추가</td>
</tr>
<tr>
<td>테스트 변경</td>
<td>드라이버 코드 수정</td>
<td><strong>새 시퀀스 작성</strong>만 하면 됨</td>
</tr>
<tr>
<td>연결</td>
<td>없음</td>
<td><code>connect_phase</code>에서 <code>seq_item_port</code> 연결</td>
</tr>
<tr>
<td>재사용</td>
<td>불가능</td>
<td><strong>드라이버 재사용 가능</strong></td>
</tr>
</tbody></table>
<h3 id="6-5-4-다양한-테스트-만들기">6.5.4 다양한 테스트 만들기</h3>
<p>시퀀스 기반의 가장 큰 장점: <strong>드라이버를 수정하지 않고</strong> 새 시퀀스만 만들면 새 테스트가 됩니다:</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// 테스트 2: 오버플로 테스트 — 16회 이상 카운트</span>
<span class="hljs-keyword">class</span> counter_overflow_test <span class="hljs-keyword">extends</span> counter_test;
  `uvm_component_utils(counter_overflow_test)

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> run_phase(uvm_phase phase);
    counter_reset_seq reset_seq;
    counter_count_seq count_seq;

    phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);

    <span class="hljs-comment">// 리셋</span>
    reset_seq = counter_reset_seq::type_id::create(<span class="hljs-string">&quot;reset_seq&quot;</span>);
    reset_seq<span class="hljs-variable">.start</span>(env<span class="hljs-variable">.agent</span><span class="hljs-variable">.sqr</span>);

    <span class="hljs-comment">// 20회 카운트 — 오버플로 발생!</span>
    count_seq = counter_count_seq::type_id::create(<span class="hljs-string">&quot;count_seq&quot;</span>);
    count_seq<span class="hljs-variable">.num_transactions</span> = <span class="hljs-number">20</span>;
    count_seq<span class="hljs-variable">.start</span>(env<span class="hljs-variable">.agent</span><span class="hljs-variable">.sqr</span>);

    #<span class="hljs-number">50</span>;
    phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>

<span class="hljs-comment">// 테스트 3: 리셋 반복 테스트 — 카운트 중 리셋</span>
<span class="hljs-keyword">class</span> counter_reset_during_count_test <span class="hljs-keyword">extends</span> counter_test;
  `uvm_component_utils(counter_reset_during_count_test)

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> run_phase(uvm_phase phase);
    counter_reset_seq reset_seq;
    counter_count_seq count_seq;

    phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);

    <span class="hljs-comment">// 리셋 → 카운트 → 리셋 → 카운트 (반복)</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> round = <span class="hljs-number">0</span>; round &lt; <span class="hljs-number">3</span>; round++) <span class="hljs-keyword">begin</span>
      `uvm_info(get_type_name(), <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;=== Round %0d ===&quot;</span>, round+<span class="hljs-number">1</span>), UVM_MEDIUM)

      reset_seq = counter_reset_seq::type_id::create(<span class="hljs-string">&quot;reset_seq&quot;</span>);
      reset_seq<span class="hljs-variable">.start</span>(env<span class="hljs-variable">.agent</span><span class="hljs-variable">.sqr</span>);

      count_seq = counter_count_seq::type_id::create(<span class="hljs-string">&quot;count_seq&quot;</span>);
      count_seq<span class="hljs-variable">.num_transactions</span> = <span class="hljs-number">3</span>;
      count_seq<span class="hljs-variable">.start</span>(env<span class="hljs-variable">.agent</span><span class="hljs-variable">.sqr</span>);
    <span class="hljs-keyword">end</span>

    #<span class="hljs-number">50</span>;
    phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>
</code></pre><blockquote>
<p><strong>성취감 포인트</strong>: 드라이버 코드를 <strong>한 줄도 수정하지 않고</strong> 3가지 테스트를 만들었습니다! 이것이 시퀀스 기반 검증의 힘입니다. 실무에서는 이런 방식으로 수십~수백 개의 테스트 시나리오를 만듭니다.</p>
</blockquote>
<h3 id="6-5-5-시뮬레이션-실행">6.5.5 시뮬레이션 실행</h3>
<pre><code class="hljs language-bash"><span class="hljs-comment"># 컴파일 및 실행 (기본 테스트)</span>
vcs -sverilog -ntb_opts uvm counter_seq_tb.sv
./simv +UVM_TESTNAME=counter_test

<span class="hljs-comment"># 오버플로 테스트 실행 — 드라이버 수정 없이!</span>
./simv +UVM_TESTNAME=counter_overflow_test

<span class="hljs-comment"># 리셋 반복 테스트 실행</span>
./simv +UVM_TESTNAME=counter_reset_during_count_test
</code></pre><blockquote>
<p><strong>실무 팁</strong>: <code>+UVM_TESTNAME</code>으로 테스트를 선택하는 패턴은 실무에서도 동일합니다. 회사의 regression 스크립트는 이 방식으로 수백 개 테스트를 자동 실행합니다.</p>
</blockquote>
<p>예상 출력:</p>
<pre><code>UVM_INFO @ 0: reporter [RNTST] Running test counter_test...
UVM_INFO counter_master_seq [counter_master_seq] === Phase 1: Reset ===
UVM_INFO counter_reset_seq [counter_reset_seq] Reset done
UVM_INFO counter_master_seq [counter_master_seq] === Phase 2: Count ===
UVM_INFO counter_master_seq [counter_master_seq] === Master sequence done ===
UVM_INFO @ 200: reporter [TEST_DONE] ** UVM TEST PASSED **
</code></pre><hr>
<h2 id="6-6-체크포인트">6.6 체크포인트</h2>
<h3 id="셀프-체크">셀프 체크</h3>
<p>아래 질문에 스스로 답해보세요. 답이 바로 나오지 않으면 해당 섹션을 다시 읽어보세요:</p>
<p><strong>1. 왜 시퀀스가 필요한가?</strong> (6.1)</p>
<details>
<summary>정답 확인</summary>
Chapter 5 방식은 테스트 시나리오가 드라이버에 하드코딩되어 있어 변경, 재사용, 팀 협업이 어렵습니다. 시퀀스를 사용하면 "무엇을(What)"과 "어떻게(How)"를 분리하여, 드라이버를 수정하지 않고 새 시나리오를 추가할 수 있습니다.
</details>

<p><strong>2. uvm_sequence_item은 uvm_object의 서브클래스입니다. 이것이 의미하는 것은?</strong> (6.2)</p>
<details>
<summary>정답 확인</summary>
uvm_object이므로 ① 컴포넌트 트리에 속하지 않고 ② 생성자에 parent가 없으며 ③ Factory에 `uvm_object_utils`로 등록합니다. `uvm_component_utils`를 사용하면 안 됩니다.
</details>

<p><strong>3. start_item() 다음에 randomize()를 호출하는 이유는?</strong> (6.3)</p>
<details>
<summary>정답 확인</summary>
start_item()은 드라이버가 이전 트랜잭션 처리를 끝낼 때까지 대기합니다. 대기 후에 randomize()를 호출해야 가장 최신 상태를 반영할 수 있습니다. 이것을 "late randomization" 패턴이라 합니다.
</details>

<p><strong>4. 드라이버의 get_next_item()과 item_done()을 쌍으로 호출해야 하는 이유는?</strong> (6.4)</p>
<details>
<summary>정답 확인</summary>
get_next_item()으로 트랜잭션을 가져온 후 item_done()으로 완료를 알려야 시퀀서가 다음 트랜잭션을 전달할 수 있습니다. item_done()을 빠뜨리면 시퀀서가 영원히 대기(hang)합니다.
</details>

<p><strong>5. `uvm_do_with 매크로와 명시적 start_item/finish_item 패턴의 차이는?</strong> (6.3)</p>
<details>
<summary>정답 확인</summary>
`uvm_do_with는 create+start_item+randomize+finish_item을 한 줄로 수행합니다. 명시적 패턴은 start_item 후에 randomize하므로 late randomization이 가능합니다. 실무에서는 명시적 패턴을 더 많이 사용합니다.
</details>

<p><strong>6. 시퀀스 기반에서 새 테스트 시나리오를 추가하려면?</strong> (6.5)</p>
<details>
<summary>정답 확인</summary>
새 시퀀스 클래스를 만들거나, 새 테스트 클래스에서 기존 시퀀스를 다른 순서/파라미터로 조합합니다. 드라이버 코드를 수정할 필요가 없습니다.
</details>

<hr>
<h3 id="연습문제">연습문제</h3>
<p><strong>[실습 6-1] 토글 시퀀스 만들기 (쉬움)</strong> — 약 10분</p>
<p>enable을 0→1→0→1로 토글하는 시퀀스를 만드세요:</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// 힌트: 4개의 트랜잭션을 순서대로 전송</span>
<span class="hljs-comment">// item[0]: enable=0, cycles=2</span>
<span class="hljs-comment">// item[1]: enable=1, cycles=3</span>
<span class="hljs-comment">// item[2]: enable=0, cycles=2</span>
<span class="hljs-comment">// item[3]: enable=1, cycles=3</span>

<span class="hljs-keyword">class</span> counter_toggle_seq <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(counter_seq_item)</span>;
  `uvm_object_utils(counter_toggle_seq)

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;counter_toggle_seq&quot;</span>);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();
    counter_seq_item item;
    <span class="hljs-comment">// 여기에 코드를 작성하세요</span>
    <span class="hljs-comment">// 힌트: for 루프에서 i%2로 enable 토글</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) <span class="hljs-keyword">begin</span>
      item = counter_seq_item::type_id::create(<span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;item_%0d&quot;</span>, i));
      start_item(item);
      <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> rst_n=1, enable=?, cycles=?</span>
      finish_item(item);
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>
</code></pre><p><strong>정답</strong>:</p>
<details>
<summary>정답 확인</summary>

<pre><code class="hljs language-systemverilog"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();
  counter_seq_item item;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) <span class="hljs-keyword">begin</span>
    item = counter_seq_item::type_id::create(<span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;item_%0d&quot;</span>, i));
    start_item(item);
    item<span class="hljs-variable">.rst_n</span>  = <span class="hljs-number">1</span>;
    item<span class="hljs-variable">.enable</span> = (i % <span class="hljs-number">2</span>);      <span class="hljs-comment">// 0, 1, 0, 1 토글</span>
    item<span class="hljs-variable">.cycles</span> = (i % <span class="hljs-number">2</span>) ? <span class="hljs-number">3</span> : <span class="hljs-number">2</span>;  <span class="hljs-comment">// enable일 때 3클럭, 아닐 때 2클럭</span>
    finish_item(item);
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endtask</span>
</code></pre></details>

<hr>
<p><strong>[실습 6-2] 랜덤 스트레스 시퀀스 (보통)</strong> — 약 15분</p>
<p>완전히 랜덤한 트랜잭션을 N회 전송하는 스트레스 시퀀스를 만드세요. <code>rst_n</code>, <code>enable</code>, <code>cycles</code> 모두 랜덤이어야 합니다:</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// 요구사항:</span>
<span class="hljs-comment">// 1. num_items 파라미터로 트랜잭션 수 지정 (기본값 20)</span>
<span class="hljs-comment">// 2. 모든 필드를 randomize()로 생성</span>
<span class="hljs-comment">// 3. 각 트랜잭션 전송 후 convert2string()으로 로그 출력</span>
<span class="hljs-comment">// 4. 시작과 끝에 UVM_MEDIUM 레벨 로그 출력</span>

<span class="hljs-keyword">class</span> counter_stress_seq <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(counter_seq_item)</span>;
  `uvm_object_utils(counter_stress_seq)

  <span class="hljs-keyword">int</span> num_items = <span class="hljs-number">20</span>;

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;counter_stress_seq&quot;</span>);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();
    <span class="hljs-comment">// 여기에 코드를 작성하세요</span>
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>
</code></pre><p><strong>정답</strong>:</p>
<details>
<summary>정답 확인</summary>

<pre><code class="hljs language-systemverilog"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();
  counter_seq_item item;

  `uvm_info(get_type_name(),
    <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;Starting stress sequence with %0d items&quot;</span>, num_items), UVM_MEDIUM)

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num_items; i++) <span class="hljs-keyword">begin</span>
    item = counter_seq_item::type_id::create(<span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;item_%0d&quot;</span>, i));
    start_item(item);
    <span class="hljs-keyword">if</span> (!item<span class="hljs-variable">.randomize</span>())
      `uvm_fatal(get_type_name(), <span class="hljs-string">&quot;Randomization failed!&quot;</span>)
    finish_item(item);
    `uvm_info(get_type_name(),
      <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;[%0d/%0d] %s&quot;</span>, i+<span class="hljs-number">1</span>, num_items, item<span class="hljs-variable">.convert2string</span>()), UVM_HIGH)
  <span class="hljs-keyword">end</span>

  `uvm_info(get_type_name(), <span class="hljs-string">&quot;Stress sequence completed&quot;</span>, UVM_MEDIUM)
<span class="hljs-keyword">endtask</span>
</code></pre></details>

<hr>
<p><strong>[실습 6-3] 시퀀스 조합 테스트 (도전)</strong> — 약 20분</p>
<p>리셋 → 스트레스 → 리셋 → 카운트 순서의 종합 테스트를 만드세요:</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// 요구사항:</span>
<span class="hljs-comment">// 1. counter_test를 상속받는 새 테스트 클래스</span>
<span class="hljs-comment">// 2. run_phase에서 4단계 시퀀스를 순서대로 실행:</span>
<span class="hljs-comment">//    Phase 1: 리셋 (counter_reset_seq)</span>
<span class="hljs-comment">//    Phase 2: 스트레스 10회 (실습 6-2의 counter_stress_seq)</span>
<span class="hljs-comment">//    Phase 3: 리셋 (counter_reset_seq)</span>
<span class="hljs-comment">//    Phase 4: 정상 카운트 5회 (counter_count_seq)</span>
<span class="hljs-comment">// 3. 각 Phase 시작 시 UVM_MEDIUM 레벨 로그</span>

<span class="hljs-keyword">class</span> counter_comprehensive_test <span class="hljs-keyword">extends</span> counter_test;
  `uvm_component_utils(counter_comprehensive_test)

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> run_phase(uvm_phase phase);
    <span class="hljs-comment">// 여기에 코드를 작성하세요</span>
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>
</code></pre><p><strong>정답</strong>:</p>
<details>
<summary>정답 확인</summary>

<pre><code class="hljs language-systemverilog"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> run_phase(uvm_phase phase);
  counter_reset_seq  reset_seq;
  counter_stress_seq stress_seq;
  counter_count_seq  count_seq;

  phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);

  <span class="hljs-comment">// Phase 1: 리셋</span>
  `uvm_info(get_type_name(), <span class="hljs-string">&quot;=== Phase 1: Initial Reset ===&quot;</span>, UVM_MEDIUM)
  reset_seq = counter_reset_seq::type_id::create(<span class="hljs-string">&quot;reset_seq&quot;</span>);
  reset_seq<span class="hljs-variable">.start</span>(env<span class="hljs-variable">.agent</span><span class="hljs-variable">.sqr</span>);

  <span class="hljs-comment">// Phase 2: 스트레스</span>
  `uvm_info(get_type_name(), <span class="hljs-string">&quot;=== Phase 2: Stress Test ===&quot;</span>, UVM_MEDIUM)
  stress_seq = counter_stress_seq::type_id::create(<span class="hljs-string">&quot;stress_seq&quot;</span>);
  stress_seq<span class="hljs-variable">.num_items</span> = <span class="hljs-number">10</span>;
  stress_seq<span class="hljs-variable">.start</span>(env<span class="hljs-variable">.agent</span><span class="hljs-variable">.sqr</span>);

  <span class="hljs-comment">// Phase 3: 리셋</span>
  `uvm_info(get_type_name(), <span class="hljs-string">&quot;=== Phase 3: Mid Reset ===&quot;</span>, UVM_MEDIUM)
  reset_seq = counter_reset_seq::type_id::create(<span class="hljs-string">&quot;reset_seq2&quot;</span>);
  reset_seq<span class="hljs-variable">.start</span>(env<span class="hljs-variable">.agent</span><span class="hljs-variable">.sqr</span>);

  <span class="hljs-comment">// Phase 4: 정상 카운트</span>
  `uvm_info(get_type_name(), <span class="hljs-string">&quot;=== Phase 4: Normal Count ===&quot;</span>, UVM_MEDIUM)
  count_seq = counter_count_seq::type_id::create(<span class="hljs-string">&quot;count_seq&quot;</span>);
  count_seq<span class="hljs-variable">.num_transactions</span> = <span class="hljs-number">5</span>;
  count_seq<span class="hljs-variable">.start</span>(env<span class="hljs-variable">.agent</span><span class="hljs-variable">.sqr</span>);

  #<span class="hljs-number">50</span>;
  phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);
<span class="hljs-keyword">endtask</span>
</code></pre></details>

<hr>
<h3 id="흔한-에러와-해결">흔한 에러와 해결</h3>
<table>
<thead>
<tr>
<th>에러 메시지</th>
<th>원인</th>
<th>해결</th>
</tr>
</thead>
<tbody><tr>
<td><code>Null object access</code> (sequence)</td>
<td>시퀀스 <code>start()</code> 시 시퀀서가 null</td>
<td><code>env.agent.sqr</code> 경로 확인, <code>build_phase</code>에서 시퀀서 생성 확인</td>
</tr>
<tr>
<td><code>item_done() not called</code></td>
<td>드라이버에서 <code>item_done()</code> 누락</td>
<td><code>get_next_item()</code> 후 반드시 <code>item_done()</code> 호출</td>
</tr>
<tr>
<td><code>Sequencer has no driver</code></td>
<td><code>connect_phase</code>에서 연결 누락</td>
<td><code>drv.seq_item_port.connect(sqr.seq_item_export)</code> 확인</td>
</tr>
<tr>
<td><code>Randomization failed</code></td>
<td>constraint 충돌</td>
<td>inline constraint와 클래스 constraint 간 충돌 확인</td>
</tr>
<tr>
<td><code>uvm_component_utils</code> 사용</td>
<td>sequence_item에 잘못된 매크로</td>
<td><code>uvm_object_utils</code> 또는 <code>uvm_object_utils_begin</code> 사용</td>
</tr>
</tbody></table>
<h3 id="용어-정리">용어 정리</h3>
<table>
<thead>
<tr>
<th>용어</th>
<th>영어</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>트랜잭션</td>
<td>Transaction</td>
<td>DUT와 한 번 주고받는 데이터 단위</td>
</tr>
<tr>
<td>시퀀스 아이템</td>
<td>Sequence Item</td>
<td>트랜잭션 클래스 (uvm_sequence_item)</td>
</tr>
<tr>
<td>시퀀스</td>
<td>Sequence</td>
<td>트랜잭션 생성 시나리오 (uvm_sequence)</td>
</tr>
<tr>
<td>시퀀서</td>
<td>Sequencer</td>
<td>시퀀스와 드라이버의 중개자 (uvm_sequencer)</td>
</tr>
<tr>
<td>바디</td>
<td>body()</td>
<td>시퀀스의 핵심 실행 메서드</td>
</tr>
<tr>
<td>레이트 랜덤화</td>
<td>Late Randomization</td>
<td>start_item 후 randomize하는 패턴</td>
</tr>
<tr>
<td>마스터 시퀀스</td>
<td>Master Sequence</td>
<td>여러 서브 시퀀스를 조합하는 시퀀스</td>
</tr>
</tbody></table>
<h3 id="다음-챕터-예고">다음 챕터 예고</h3>
<p>Chapter 7에서는 지금 &quot;마법처럼&quot; 연결한 <code>seq_item_port</code>/<code>seq_item_export</code>의 내부 동작을 다룹니다. <strong>TLM(Transaction Level Modeling)</strong> 포트의 개념과 드라이버/모니터의 심화 기능을 배웁니다.</p>

    <nav class="chapter-nav"><a href="chapter-05-final.html" class="nav-prev">
      <span class="nav-label">이전 챕터</span>
      <span class="nav-title">Ch.5 첫 UVM 테스트벤치</span>
    </a><a href="chapter-07-final.html" class="nav-next">
      <span class="nav-label">다음 챕터</span>
      <span class="nav-title">Ch.7 드라이버 & 모니터</span>
    </a></nav>
  </div>

  <footer class="book-footer">
    <p>팹리스 검증 엔지니어가 되기 위한 UVM 완전정복</p>
    <p>Published by UVM Book Publisher Agent</p>
  </footer>

  <!-- Back to Top Button -->
  <button class="back-to-top" id="backToTop" onclick="window.scrollTo({top:0,behavior:'smooth'})">↑</button>

  <script>
    // Reading progress bar
    window.addEventListener('scroll', () => {
      const h = document.documentElement;
      const pct = (h.scrollTop / (h.scrollHeight - h.clientHeight)) * 100;
      document.getElementById('progressBar').style.width = pct + '%';
      document.getElementById('backToTop').classList.toggle('visible', h.scrollTop > 400);
    });

    // Language labels for code blocks
    document.querySelectorAll('pre').forEach(pre => {
      const code = pre.querySelector('code');
      if (code) {
        const cls = code.className || '';
        const m = cls.match(/language-(\w+)/);
        if (m) {
          const map = {
            systemverilog:'SystemVerilog', sv:'SystemVerilog', verilog:'Verilog',
            bash:'Bash', shell:'Shell', tcl:'TCL', makefile:'Makefile',
            python:'Python', javascript:'JavaScript', text:'Output'
          };
          pre.setAttribute('data-lang', map[m[1]] || m[1]);
        }
      }
    });

    // Smart labels for plain code blocks
    document.querySelectorAll('pre code:not([class*="language-"])').forEach(code => {
      const pre = code.parentElement;
      if (!pre.getAttribute('data-lang')) {
        const t = code.textContent || '';
        if (t.includes('UVM_INFO') || t.includes('UVM_WARNING')) {
          pre.setAttribute('data-lang', 'Simulation Output');
        } else if (t.includes('[채용') || t.includes('필수 자격')) {
          pre.setAttribute('data-lang', '');
        } else if (t.includes('Step') || t.includes('패널') || t.includes('편집기')) {
          pre.setAttribute('data-lang', 'Setup Guide');
        } else {
          pre.setAttribute('data-lang', 'Info');
        }
      }
    });

    // Smooth scroll for TOC links
    document.querySelectorAll('.toc a').forEach(a => {
      a.addEventListener('click', e => {
        e.preventDefault();
        const id = a.getAttribute('href').slice(1);
        const target = document.getElementById(id);
        if (target) target.scrollIntoView({ behavior: 'smooth', block: 'start' });
      });
    });
  </script>
</body>
</html>