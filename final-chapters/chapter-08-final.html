<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chapter 8: 스코어보드 & 커버리지 | 팹리스 검증 엔지니어가 되기 위한 UVM 완전정복</title>
  <style>
    /* =============================================
       UVM Book Publisher - Stylesheet
       Generated by Publisher Agent
       ============================================= */

    @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;600;700&display=swap');

    :root {
      --bg: #ffffff;
      --text: #1a1a2e;
      --accent: #10b981;
      --accent-light: #10b98118;
      --code-bg: #1e1e2e;
      --code-text: #cdd6f4;
      --border: #e2e8f0;
      --blockquote-bg: #f0f9ff;
      --blockquote-border: #3b82f6;
      --table-header: #1e293b;
      --table-stripe: #f8fafc;
      --warning-bg: #fef3c7;
      --warning-border: #f59e0b;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: 'Noto Sans KR', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      line-height: 1.85;
      color: var(--text);
      background: var(--bg);
      font-size: 16px;
    }

    /* === Reading Progress Bar === */
    .progress-bar {
      position: fixed;
      top: 0;
      left: 0;
      width: 0%;
      height: 3px;
      background: linear-gradient(90deg, var(--accent), #10b981cc);
      z-index: 9999;
      transition: width 0.1s;
    }

    /* === Cover Header === */
    .cover-header {
      background: linear-gradient(135deg, #10b98108, #10b98115);
      border-bottom: 3px solid var(--accent);
      padding: 32px 24px 24px;
      text-align: center;
      margin-bottom: 0;
    }
    .cover-part {
      display: inline-block;
      background: var(--accent);
      color: white;
      padding: 4px 16px;
      border-radius: 20px;
      font-size: 0.85em;
      font-weight: 600;
      letter-spacing: 0.5px;
      margin-bottom: 12px;
    }
    .cover-chapter-num {
      font-size: 2em;
      font-weight: 300;
      color: var(--accent);
      letter-spacing: 2px;
      opacity: 0.6;
    }

    /* === Main Content === */
    .content {
      max-width: 860px;
      margin: 0 auto;
      padding: 32px 24px 60px;
    }

    /* === TOC === */
    .toc {
      background: #f8fafc;
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 20px 28px;
      margin: 24px 0 32px;
    }
    .toc-title {
      font-size: 1.1em;
      color: var(--accent);
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 2px solid var(--border);
    }
    .toc ul { list-style: none; padding: 0; }
    .toc li { margin: 6px 0; }
    .toc li a {
      color: var(--text);
      text-decoration: none;
      font-weight: 500;
      font-size: 0.95em;
      padding: 4px 8px;
      border-radius: 4px;
      display: inline-block;
      transition: background 0.15s;
    }
    .toc li a:hover {
      background: var(--accent-light);
      color: var(--accent);
    }
    .toc li.toc-sub { padding-left: 24px; }
    .toc li.toc-sub a {
      font-weight: 400;
      font-size: 0.9em;
      color: #475569;
    }

    /* === Headings === */
    h1 {
      font-size: 2em;
      border-bottom: 3px solid var(--accent);
      padding-bottom: 12px;
      margin: 40px 0 20px;
      color: var(--text);
    }
    h1:first-child { margin-top: 0; }
    h2 {
      font-size: 1.5em;
      color: var(--accent);
      margin: 40px 0 16px;
      padding-bottom: 8px;
      border-bottom: 2px solid var(--border);
      scroll-margin-top: 16px;
    }
    h3 {
      font-size: 1.25em;
      margin: 28px 0 12px;
      color: #334155;
      scroll-margin-top: 16px;
    }
    h4 { font-size: 1.05em; margin: 20px 0 8px; color: #475569; }
    p { margin: 12px 0; }
    a { color: var(--accent); text-decoration: none; }
    a:hover { text-decoration: underline; }
    hr { border: none; border-top: 2px solid var(--border); margin: 32px 0; }
    strong { color: #1e293b; }
    img { max-width: 100%; border-radius: 8px; margin: 16px 0; }

    /* === Code Blocks === */
    pre {
      position: relative;
      background: var(--code-bg);
      border-radius: 12px;
      padding: 0;
      margin: 20px 0;
      overflow: hidden;
      box-shadow: 0 4px 16px rgba(0,0,0,0.12), 0 1px 4px rgba(0,0,0,0.08);
      border: 1px solid #313244;
    }
    pre::before {
      content: attr(data-lang);
      display: block;
      background: #313244;
      color: #a6adc8;
      padding: 8px 16px;
      font-size: 0.8em;
      font-family: 'Fira Code','JetBrains Mono',monospace;
      letter-spacing: 0.5px;
      border-bottom: 1px solid #45475a;
    }
    pre code {
      display: block;
      padding: 16px 20px;
      overflow-x: auto;
      font-family: 'Fira Code','JetBrains Mono','Cascadia Code','D2Coding',monospace;
      font-size: 0.88em;
      line-height: 1.75;
      tab-size: 4;
      color: var(--code-text);
    }
    pre code::-webkit-scrollbar { height: 6px; }
    pre code::-webkit-scrollbar-track { background: #1e1e2e; }
    pre code::-webkit-scrollbar-thumb { background: #45475a; border-radius: 3px; }

    code:not(pre code) {
      background: #f1f5f9;
      color: #be185d;
      padding: 2px 7px;
      border-radius: 5px;
      font-family: 'Fira Code','JetBrains Mono','D2Coding',monospace;
      font-size: 0.86em;
      border: 1px solid #e2e8f0;
    }

    /* Highlight.js Catppuccin */
    .hljs { background: transparent; color: #cdd6f4; }
    .hljs-keyword { color: #cba6f7; font-weight: bold; }
    .hljs-type { color: #f9e2af; }
    .hljs-string { color: #a6e3a1; }
    .hljs-number { color: #fab387; }
    .hljs-comment { color: #6c7086; font-style: italic; }
    .hljs-function, .hljs-title { color: #89b4fa; }
    .hljs-built_in { color: #f38ba8; }
    .hljs-variable { color: #cdd6f4; }
    .hljs-attr { color: #89dceb; }
    .hljs-meta { color: #f5c2e7; }
    .hljs-literal { color: #fab387; }

    /* === SVG Diagrams === */
    .svg-diagram {
      margin: 24px 0;
      padding: 20px;
      background: #fafbfc;
      border: 1px solid var(--border);
      border-radius: 12px;
      text-align: center;
      overflow-x: auto;
    }
    .svg-diagram svg { display: inline-block; }

    /* === Blockquotes === */
    blockquote {
      background: var(--blockquote-bg);
      border-left: 4px solid var(--blockquote-border);
      padding: 16px 20px;
      margin: 16px 0;
      border-radius: 0 8px 8px 0;
    }
    blockquote p:first-child { margin-top: 0; }
    blockquote p:last-child { margin-bottom: 0; }
    blockquote:has(strong:first-child) {
      background: var(--warning-bg);
      border-left-color: var(--warning-border);
    }

    /* === Tables === */
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 1px 4px rgba(0,0,0,0.06);
      border: 1px solid var(--border);
      font-size: 0.95em;
    }
    thead th {
      background: var(--table-header);
      color: white;
      padding: 12px 16px;
      text-align: left;
      font-weight: 600;
      font-size: 0.9em;
    }
    tbody td {
      padding: 10px 16px;
      border-bottom: 1px solid var(--border);
    }
    tbody tr:nth-child(even) { background: var(--table-stripe); }
    tbody tr:hover { background: var(--accent-light); }

    /* === Lists === */
    ul, ol { padding-left: 28px; margin: 12px 0; }
    li { margin: 6px 0; }
    li > ul, li > ol { margin: 4px 0; }

    /* === Details/Summary === */
    details {
      background: #f8fafc;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px 16px;
      margin: 12px 0;
    }
    details summary {
      cursor: pointer;
      font-weight: 600;
      color: var(--accent);
    }
    details[open] summary { margin-bottom: 8px; }

    /* === Plain code blocks === */
    pre:has(code:not(.hljs)) {
      background: #fafbfc;
      border: 2px solid var(--border);
      box-shadow: none;
    }
    pre:has(code:not(.hljs))::before {
      background: #f1f5f9;
      color: #64748b;
      border-bottom-color: var(--border);
    }
    pre:has(code:not(.hljs)) code { color: #334155; }

    /* === Chapter Navigation === */
    .chapter-nav {
      display: flex;
      justify-content: space-between;
      gap: 16px;
      margin: 40px 0 20px;
      padding-top: 24px;
      border-top: 2px solid var(--border);
    }
    .chapter-nav a {
      display: flex;
      flex-direction: column;
      padding: 14px 20px;
      border: 1px solid var(--border);
      border-radius: 10px;
      text-decoration: none;
      transition: all 0.2s;
      min-width: 200px;
    }
    .chapter-nav a:hover {
      border-color: var(--accent);
      background: var(--accent-light);
      text-decoration: none;
    }
    .nav-prev { align-items: flex-start; }
    .nav-next { align-items: flex-end; }
    .nav-label {
      font-size: 0.8em;
      color: #94a3b8;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .nav-title { font-weight: 600; color: var(--accent); margin-top: 2px; }

    /* === Footer === */
    .book-footer {
      text-align: center;
      padding: 20px;
      margin-top: 40px;
      border-top: 1px solid var(--border);
      color: #94a3b8;
      font-size: 0.85em;
    }

    /* === Back to Top === */
    .back-to-top {
      position: fixed;
      bottom: 24px;
      right: 24px;
      width: 44px;
      height: 44px;
      background: var(--accent);
      color: white;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      font-size: 20px;
      display: none;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      transition: opacity 0.3s;
      z-index: 100;
    }
    .back-to-top.visible { display: flex; }

    /* === Print === */
    @media print {
      .progress-bar, .back-to-top, .chapter-nav, .toc { display: none !important; }
      body { font-size: 11pt; }
      .content { max-width: 100%; padding: 0; }
      .cover-header { break-after: page; }
      pre { box-shadow: none; border: 2px solid #ccc; break-inside: avoid; }
      .svg-diagram { break-inside: avoid; border: 1px solid #ccc; }
      table { break-inside: avoid; }
      h2, h3 { break-after: avoid; }
    }

    /* === Responsive === */
    @media (max-width: 640px) {
      .content { padding: 16px 12px 40px; font-size: 15px; }
      h1 { font-size: 1.5em; }
      h2 { font-size: 1.25em; }
      pre code { font-size: 0.8em; padding: 12px; }
      thead th, tbody td { padding: 8px 10px; font-size: 0.88em; }
      .svg-diagram { padding: 10px; }
      .toc { padding: 14px 18px; }
      .chapter-nav { flex-direction: column; }
      .chapter-nav a { min-width: unset; }
      .nav-next { align-items: flex-start; }
      .cover-chapter-num { font-size: 1.5em; }
    }
  </style>
</head>
<body>
  <!-- Reading Progress Bar -->
  <div class="progress-bar" id="progressBar"></div>

  
<header class="cover-header">
  <div class="cover-part" style="--part-color: #10b981">
    <span class="cover-part-label">Part 2: 깊이 파기</span>
  </div>
  <div class="cover-chapter-num">Chapter 08</div>
</header>

  <div class="content">
    <nav class="toc">
<h2 class="toc-title">목차</h2>
<ul>
<li><a href="#8-1-왜-자동-검증이-필요한가">8.1 왜 자동 검증이 필요한가</a></li>
  <li class="toc-sub"><a href="#8-1-1-수동-검증의-한계-눈으로-확인하는-검증">8.1.1 수동 검증의 한계 — 눈으로 확인하는 검증</a></li>
  <li class="toc-sub"><a href="#8-1-2-스코어보드-자동-채점기">8.1.2 스코어보드 — 자동 채점기</a></li>
  <li class="toc-sub"><a href="#8-1-3-커버리지-시험-범위-체크리스트">8.1.3 커버리지 — 시험 범위 체크리스트</a></li>
  <li class="toc-sub"><a href="#8-1-4-검증-자동화-전체-구조">8.1.4 검증 자동화 전체 구조</a></li>
<li><a href="#8-2-스코어보드-기초">8.2 스코어보드 기초</a></li>
  <li class="toc-sub"><a href="#8-2-1-reference-model-정답지-만들기">8.2.1 Reference Model — 정답지 만들기</a></li>
  <li class="toc-sub"><a href="#8-2-2-uvm-scoreboard-와-uvm-analysis-imp">8.2.2 uvm_scoreboard 와 uvm_analysis_imp</a></li>
  <li class="toc-sub"><a href="#8-2-3-write-메서드-트랜잭션이-도착하면">8.2.3 write() 메서드 — 트랜잭션이 도착하면</a></li>
  <li class="toc-sub"><a href="#8-2-4-기본-스코어보드-구현-예제-8-1">8.2.4 기본 스코어보드 구현 — 예제 8-1</a></li>
<li><a href="#8-3-스코어보드-심화">8.3 스코어보드 심화</a></li>
  <li class="toc-sub"><a href="#8-3-1-uvm-subscriber-더-간단한-대안">8.3.1 uvm_subscriber — 더 간단한 대안</a></li>
  <li class="toc-sub"><a href="#8-3-2-예측-비교-분리-패턴">8.3.2 예측-비교 분리 패턴</a></li>
  <li class="toc-sub"><a href="#8-3-3-멀티포트-스코어보드">8.3.3 멀티포트 스코어보드</a></li>
  <li class="toc-sub"><a href="#8-3-4-report-phase-로-최종-결과-요약">8.3.4 report_phase()로 최종 결과 요약</a></li>
<li><a href="#8-4-기능-커버리지-기초">8.4 기능 커버리지 기초</a></li>
  <li class="toc-sub"><a href="#8-4-1-코드-커버리지-vs-기능-커버리지">8.4.1 코드 커버리지 vs 기능 커버리지</a></li>
  <li class="toc-sub"><a href="#8-4-2-covergroup-coverpoint-bins">8.4.2 covergroup, coverpoint, bins</a></li>
  <li class="toc-sub"><a href="#8-4-3-cross-coverage">8.4.3 cross coverage</a></li>
  <li class="toc-sub"><a href="#8-4-4-기본-커버리지-수집기-예제-8-2">8.4.4 기본 커버리지 수집기 — 예제 8-2</a></li>
<li><a href="#8-5-커버리지-기반-검증-cdv">8.5 커버리지 기반 검증 (CDV)</a></li>
  <li class="toc-sub"><a href="#8-5-1-cdv-워크플로우">8.5.1 CDV 워크플로우</a></li>
  <li class="toc-sub"><a href="#8-5-2-커버리지-리포트-읽기">8.5.2 커버리지 리포트 읽기</a></li>
  <li class="toc-sub"><a href="#8-5-3-커버리지-100-의-함정">8.5.3 커버리지 100%의 함정</a></li>
<li><a href="#8-6-종합-자동-검증-테스트벤치">8.6 종합: 자동 검증 테스트벤치</a></li>
  <li class="toc-sub"><a href="#8-6-1-전체-구조">8.6.1 전체 구조</a></li>
  <li class="toc-sub"><a href="#8-6-2-완성-코드-예제-8-3">8.6.2 완성 코드 — 예제 8-3</a></li>
  <li class="toc-sub"><a href="#8-6-3-실행-결과">8.6.3 실행 결과</a></li>
  <li class="toc-sub"><a href="#8-6-4-ch-5-ch-8-진화-정리">8.6.4 Ch.5 → Ch.8 진화 정리</a></li>
<li><a href="#8-7-체크포인트">8.7 체크포인트</a></li>
  <li class="toc-sub"><a href="#셀프-체크">셀프 체크</a></li>
  <li class="toc-sub"><a href="#연습문제">연습문제</a></li>
  <li class="toc-sub"><a href="#다음-장-미리보기">다음 장 미리보기</a></li>
</ul>
</nav>
    <h1>Chapter 8: 스코어보드 &amp; 커버리지</h1>
<blockquote>
<p><strong>이 챕터의 목표</strong>: 스코어보드로 DUT 출력을 <strong>자동 검증</strong>하고, 기능 커버리지로 검증 <strong>완전성</strong>을 측정합니다. 눈으로 파형을 보는 시대는 끝났습니다.</p>
</blockquote>
<blockquote>
<p><strong>선수 지식</strong>: Chapter 7 (analysis port, TLM 포트, 모니터 브로드캐스트)</p>
</blockquote>
<hr>
<h2 id="8-1-왜-자동-검증이-필요한가">8.1 왜 자동 검증이 필요한가</h2>
<blockquote>
<p><strong>이 절의 목표</strong>: 수동 검증의 한계를 이해하고, 스코어보드와 커버리지가 해결하는 문제를 파악합니다.</p>
</blockquote>
<h3 id="8-1-1-수동-검증의-한계-눈으로-확인하는-검증">8.1.1 수동 검증의 한계 — 눈으로 확인하는 검증</h3>
<p>Chapter 7까지 우리는 모니터가 수집한 데이터를 <code>uvm_info</code>로 출력만 했습니다. 검증은 어떻게 했나요?</p>
<pre><code>[시뮬레이션 실행]
    ↓
[파형 뷰어에서 눈으로 확인]
    ↓
[맞는 것 같으면... PASS?]
</code></pre><p>이 방법의 문제점:</p>
<table>
<thead>
<tr>
<th>문제</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td><strong>확장 불가</strong></td>
<td>신호 100개, 트랜잭션 10,000개를 눈으로?</td>
</tr>
<tr>
<td><strong>실수 가능</strong></td>
<td>사람은 피곤하면 오류를 놓침</td>
</tr>
<tr>
<td><strong>재현 불가</strong></td>
<td>&quot;저번에 봤을 때 맞았는데...&quot;</td>
</tr>
<tr>
<td><strong>정량화 불가</strong></td>
<td>&quot;충분히 테스트했나?&quot; → 감으로 판단</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>실무 이야기</strong>: 팹리스에서 칩을 테이프아웃하기 전, &quot;검증이 충분한가?&quot;라는 질문에 &quot;파형 봤는데 괜찮아 보여요&quot;라고 답하면 바로 탈락입니다. <strong>자동 검증</strong> + <strong>정량적 커버리지 목표</strong>가 필수입니다.</p>
</blockquote>
<h3 id="8-1-2-스코어보드-자동-채점기">8.1.2 스코어보드 — 자동 채점기</h3>
<p>시험에 비유하면:</p>
<table>
<thead>
<tr>
<th>시험</th>
<th>검증</th>
</tr>
</thead>
<tbody><tr>
<td>시험지</td>
<td>테스트 시나리오 (시퀀스)</td>
</tr>
<tr>
<td>학생 답안</td>
<td>DUT 출력 (모니터가 관찰)</td>
</tr>
<tr>
<td><strong>정답지</strong></td>
<td><strong>Reference Model (스코어보드 내부)</strong></td>
</tr>
<tr>
<td><strong>채점관</strong></td>
<td><strong>스코어보드</strong></td>
</tr>
</tbody></table>
<p>스코어보드는 **정답지(Reference Model)**를 갖고 있고, 모니터가 전달한 **학생 답안(DUT 출력)**을 자동으로 비교합니다. 틀리면 즉시 에러를 보고합니다.</p>
<h3 id="8-1-3-커버리지-시험-범위-체크리스트">8.1.3 커버리지 — 시험 범위 체크리스트</h3>
<p>시험을 잘 봤다고 끝이 아닙니다. &quot;이 시험이 모든 범위를 커버했는가?&quot;도 중요합니다.</p>
<table>
<thead>
<tr>
<th>체크리스트 항목</th>
<th>검증 대응</th>
</tr>
</thead>
<tbody><tr>
<td>1장 출제했나?</td>
<td>reset 시나리오 테스트했나?</td>
</tr>
<tr>
<td>2장 출제했나?</td>
<td>overflow 시나리오 테스트했나?</td>
</tr>
<tr>
<td>1+2장 복합?</td>
<td>reset 후 overflow 테스트했나?</td>
</tr>
<tr>
<td><strong>커버율</strong></td>
<td><strong>기능 커버리지 퍼센트</strong></td>
</tr>
</tbody></table>
<h3 id="8-1-4-검증-자동화-전체-구조">8.1.4 검증 자동화 전체 구조</h3>

<div class="svg-diagram">
<svg viewBox="0 0 700 450" xmlns="http://www.w3.org/2000/svg" style="max-width:700px;width:100%">
  <defs>
    <marker id="ah" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto"><polygon points="0 0, 8 2.8, 0 5.6" fill="#64748b"/></marker>
    <marker id="ah-accent" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto"><polygon points="0 0, 8 2.8, 0 5.6" fill="#2563eb"/></marker>
    <marker id="ah-green" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto"><polygon points="0 0, 8 2.8, 0 5.6" fill="#10b981"/></marker>
    <marker id="ah-purple" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto"><polygon points="0 0, 8 2.8, 0 5.6" fill="#7c3aed"/></marker>
    <filter id="sh" x="-5%" y="-5%" width="115%" height="115%"><feDropShadow dx="0" dy="2" stdDeviation="3" flood-color="#000" flood-opacity="0.1"/></filter>
  </defs>

  <!-- Title -->
  <text x="350" y="28" text-anchor="middle" font-family="'Noto Sans KR',sans-serif" font-size="17" font-weight="bold" fill="#2563eb">자동 검증 구조</text>

  <!-- ===== Left column: Sequence → Sequencer → Driver → DUT ===== -->
  <rect x="30" y="55" width="145" height="44" rx="10" fill="#f8fafc" stroke="#94a3b8" stroke-width="2" filter="url(#sh)"/>
  <text x="102" y="82" text-anchor="middle" font-family="'Fira Code',monospace" font-size="13" font-weight="bold" fill="#1e293b">Sequence</text>

  <line x1="102" y1="99" x2="102" y2="132" stroke="#64748b" stroke-width="1.5" marker-end="url(#ah)"/>

  <rect x="30" y="138" width="145" height="44" rx="10" fill="#f8fafc" stroke="#94a3b8" stroke-width="2" filter="url(#sh)"/>
  <text x="102" y="165" text-anchor="middle" font-family="'Fira Code',monospace" font-size="13" font-weight="bold" fill="#1e293b">Sequencer</text>

  <line x1="102" y1="182" x2="102" y2="215" stroke="#64748b" stroke-width="1.5" marker-end="url(#ah)"/>

  <rect x="30" y="221" width="145" height="44" rx="10" fill="#eff6ff" stroke="#2563eb" stroke-width="2" filter="url(#sh)"/>
  <text x="102" y="248" text-anchor="middle" font-family="'Fira Code',monospace" font-size="13" font-weight="bold" fill="#2563eb">Driver</text>

  <line x1="102" y1="265" x2="102" y2="340" stroke="#64748b" stroke-width="1.5" marker-end="url(#ah)"/>
  <text x="90" y="300" text-anchor="end" font-family="'Noto Sans KR',sans-serif" font-size="10" fill="#64748b">구동</text>

  <rect x="30" y="346" width="145" height="52" rx="10" fill="#fef3c7" stroke="#f59e0b" stroke-width="2" filter="url(#sh)"/>
  <text x="102" y="377" text-anchor="middle" font-family="'Fira Code',monospace" font-size="14" font-weight="bold" fill="#92400e">DUT</text>

  <!-- ===== Right: Environment box ===== -->
  <rect x="240" y="55" width="430" height="350" rx="14" fill="#f0fdf4" stroke="#10b981" stroke-width="2" opacity="0.3"/>
  <text x="455" y="78" text-anchor="middle" font-family="'Noto Sans KR',sans-serif" font-size="14" font-weight="bold" fill="#10b981">Environment</text>

  <!-- Monitor -->
  <rect x="275" y="220" width="160" height="48" rx="10" fill="#eff6ff" stroke="#2563eb" stroke-width="2" filter="url(#sh)"/>
  <text x="355" y="249" text-anchor="middle" font-family="'Fira Code',monospace" font-size="13" font-weight="bold" fill="#2563eb">Monitor</text>

  <!-- DUT → Monitor (L-shape: right then up) -->
  <path d="M 175 372 L 258 372 L 258 244 L 273 244" fill="none" stroke="#2563eb" stroke-width="1.5" marker-end="url(#ah-accent)"/>
  <text x="265" y="325" text-anchor="end" font-family="'Noto Sans KR',sans-serif" font-size="10" fill="#2563eb">인터페이스 관찰</text>

  <!-- Scoreboard -->
  <rect x="500" y="115" width="155" height="66" rx="10" fill="#ecfdf5" stroke="#10b981" stroke-width="2" filter="url(#sh)"/>
  <text x="577" y="142" text-anchor="middle" font-family="'Fira Code',monospace" font-size="13" font-weight="bold" fill="#065f46">Scoreboard</text>
  <text x="577" y="163" text-anchor="middle" font-family="'Noto Sans KR',sans-serif" font-size="11" fill="#64748b">자동 채점</text>

  <!-- Coverage -->
  <rect x="500" y="298" width="155" height="66" rx="10" fill="#f5f3ff" stroke="#7c3aed" stroke-width="2" filter="url(#sh)"/>
  <text x="577" y="325" text-anchor="middle" font-family="'Fira Code',monospace" font-size="13" font-weight="bold" fill="#5b21b6">Coverage</text>
  <text x="577" y="346" text-anchor="middle" font-family="'Noto Sans KR',sans-serif" font-size="11" fill="#64748b">범위 측정</text>

  <!-- Monitor → Scoreboard arrow (curved) -->
  <path d="M 435 235 Q 470 148, 498 148" fill="none" stroke="#10b981" stroke-width="1.5" marker-end="url(#ah-green)"/>
  <text x="478" y="178" text-anchor="middle" font-family="'Noto Sans KR',sans-serif" font-size="10" fill="#10b981" font-weight="bold">write()</text>

  <!-- Monitor → Coverage arrow (curved) -->
  <path d="M 435 252 Q 470 331, 498 331" fill="none" stroke="#7c3aed" stroke-width="1.5" marker-end="url(#ah-purple)"/>
  <text x="478" y="303" text-anchor="middle" font-family="'Noto Sans KR',sans-serif" font-size="10" fill="#7c3aed" font-weight="bold">write()</text>

  <!-- Label: 1:N broadcast -->
  <rect x="380" y="258" width="100" height="24" rx="12" fill="#fef3c7" stroke="#f59e0b" stroke-width="1.5"/>
  <text x="430" y="275" text-anchor="middle" font-family="'Noto Sans KR',sans-serif" font-size="11" font-weight="bold" fill="#92400e">1:N 브로드캐스트</text>
</svg>
</div><p><strong>핵심 포인트</strong>: 모니터의 <code>analysis_port.write()</code>가 스코어보드와 커버리지 수집기 <strong>둘 다</strong>에게 동시에 트랜잭션을 전달합니다. Ch.7에서 배운 1:N 브로드캐스트의 실전 활용입니다!</p>
<hr>
<h2 id="8-2-스코어보드-기초">8.2 스코어보드 기초</h2>
<blockquote>
<p><strong>이 절의 목표</strong>: <code>uvm_scoreboard</code>와 <code>uvm_analysis_imp</code>를 사용해 자동 검증 스코어보드를 구현합니다.</p>
</blockquote>
<h3 id="8-2-1-reference-model-정답지-만들기">8.2.1 Reference Model — 정답지 만들기</h3>
<p>스코어보드가 DUT 출력을 검증하려면 &quot;정답&quot;을 알아야 합니다. 이 정답을 만드는 것이 <strong>Reference Model</strong>입니다.</p>
<p><strong>우리의 4비트 카운터 DUT 동작 규칙:</strong></p>
<ul>
<li><code>rst_n == 0</code> → count = 0 (리셋)</li>
<li><code>enable == 1</code> → count = count + 1 (증가)</li>
<li><code>enable == 0</code> → count 유지 (정지)</li>
<li>count가 15(4&#39;hF)를 넘으면 → 0으로 돌아감 (오버플로우)</li>
</ul>
<p>이 규칙을 SystemVerilog 함수로 구현하면 Reference Model이 됩니다:</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// Reference Model — 소프트웨어로 DUT 동작을 예측</span>
<span class="hljs-keyword">function</span> <span class="hljs-keyword">logic</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] predict_count(
    <span class="hljs-keyword">logic</span>       rst_n,
    <span class="hljs-keyword">logic</span>       enable,
    <span class="hljs-keyword">logic</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] current_count
);
  <span class="hljs-keyword">if</span> (!rst_n)
    <span class="hljs-keyword">return</span> <span class="hljs-number">4&#x27;h0</span>;                    <span class="hljs-comment">// 리셋</span>
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (enable)
    <span class="hljs-keyword">return</span> current_count + <span class="hljs-number">1</span>;       <span class="hljs-comment">// 증가 (자동 오버플로우)</span>
  <span class="hljs-keyword">else</span>
    <span class="hljs-keyword">return</span> current_count;           <span class="hljs-comment">// 유지</span>
<span class="hljs-keyword">endfunction</span>
</code></pre><blockquote>
<p><strong>왜 Reference Model이 필요한가?</strong> DUT는 하드웨어(RTL)로 구현됩니다. 같은 기능을 <strong>소프트웨어</strong>로 별도 구현해서 결과를 비교하면, 두 구현이 독립적이므로 동일한 버그를 만들 확률이 매우 낮습니다.</p>
</blockquote>
<h3 id="8-2-2-uvm-scoreboard-와-uvm-analysis-imp">8.2.2 uvm_scoreboard 와 uvm_analysis_imp</h3>
<p>Ch.7에서 스코어보드 코드를 프리뷰했습니다. 이제 본격적으로 구조를 이해합니다.</p>
<p><strong>스코어보드의 3가지 핵심 요소:</strong></p>
<table>
<thead>
<tr>
<th>요소</th>
<th>역할</th>
<th>UVM 클래스</th>
</tr>
</thead>
<tbody><tr>
<td>기본 클래스</td>
<td>스코어보드 뼈대</td>
<td><code>uvm_scoreboard</code></td>
</tr>
<tr>
<td>수신 포트</td>
<td>모니터에서 트랜잭션 받기</td>
<td><code>uvm_analysis_imp</code></td>
</tr>
<tr>
<td>검증 함수</td>
<td>받은 데이터 비교</td>
<td><code>write()</code> 메서드</td>
</tr>
</tbody></table>
<p><strong>연결 흐름 복습</strong> (Ch.7 → Ch.8):</p>

<div class="svg-diagram">
<svg viewBox="0 0 600 200" xmlns="http://www.w3.org/2000/svg" style="max-width:600px;width:100%">
  <defs>
    <marker id="ah" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto"><polygon points="0 0, 8 2.8, 0 5.6" fill="#64748b"/></marker>
    <marker id="ah-accent" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto"><polygon points="0 0, 8 2.8, 0 5.6" fill="#2563eb"/></marker>
    <filter id="sh" x="-5%" y="-5%" width="115%" height="115%"><feDropShadow dx="0" dy="2" stdDeviation="3" flood-color="#000" flood-opacity="0.1"/></filter>
  </defs>

  <!-- Monitor box -->
  <rect x="20" y="40" width="180" height="120" rx="12" fill="#eff6ff" stroke="#2563eb" stroke-width="2" filter="url(#sh)"/>
  <text x="110" y="32" text-anchor="middle" font-family="'Fira Code',monospace" font-size="14" font-weight="bold" fill="#2563eb">Monitor</text>
  <text x="110" y="80" text-anchor="middle" font-family="'Fira Code',monospace" font-size="12" fill="#1e293b">analysis</text>
  <text x="110" y="97" text-anchor="middle" font-family="'Fira Code',monospace" font-size="12" fill="#1e293b">_port</text>

  <!-- Arrow -->
  <line x1="200" y1="100" x2="310" y2="100" stroke="#2563eb" stroke-width="1.5" marker-end="url(#ah-accent)"/>
  <text x="255" y="88" text-anchor="middle" font-family="'Fira Code',monospace" font-size="11" font-weight="bold" fill="#2563eb">write()</text>
  <text x="255" y="122" text-anchor="middle" font-family="'Noto Sans KR',sans-serif" font-size="10" fill="#64748b">자동 호출</text>

  <!-- Scoreboard box -->
  <rect x="315" y="40" width="260" height="120" rx="12" fill="#ecfdf5" stroke="#10b981" stroke-width="2" filter="url(#sh)"/>
  <text x="445" y="32" text-anchor="middle" font-family="'Fira Code',monospace" font-size="14" font-weight="bold" fill="#065f46">Scoreboard</text>

  <text x="445" y="72" text-anchor="middle" font-family="'Fira Code',monospace" font-size="12" fill="#1e293b">uvm_analysis_imp</text>

  <rect x="340" y="90" width="210" height="50" rx="8" fill="#ffffff" stroke="#10b981" stroke-width="1.5"/>
  <text x="445" y="112" text-anchor="middle" font-family="'Fira Code',monospace" font-size="12" fill="#065f46">write() {</text>
  <text x="445" y="130" text-anchor="middle" font-family="'Noto Sans KR',sans-serif" font-size="11" fill="#64748b">비교 &amp; 판정</text>

  <!-- Highlight badge -->
  <rect x="230" y="140" width="100" height="24" rx="12" fill="#fef3c7" stroke="#f59e0b" stroke-width="1.5"/>
  <text x="280" y="157" text-anchor="middle" font-family="'Noto Sans KR',sans-serif" font-size="10" font-weight="bold" fill="#92400e">자동 연결</text>
</svg>
</div><h3 id="8-2-3-write-메서드-트랜잭션이-도착하면">8.2.3 write() 메서드 — 트랜잭션이 도착하면</h3>
<p><code>write()</code> 메서드는 모니터가 <code>ap.write(item)</code>을 호출할 때마다 <strong>자동으로</strong> 실행됩니다. 이 안에서 Reference Model로 예측한 값과 실제 DUT 출력을 비교합니다.</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> write(counter_seq_item item);
  <span class="hljs-keyword">logic</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] expected;

  <span class="hljs-comment">// ⭐ Step 1: Reference Model로 예측</span>
  expected = predict_count(item<span class="hljs-variable">.rst_n</span>, item<span class="hljs-variable">.enable</span>, prev_count);

  <span class="hljs-comment">// ⭐ Step 2: 예측 vs 실제 비교</span>
  <span class="hljs-keyword">if</span> (expected !== item<span class="hljs-variable">.count</span>) <span class="hljs-keyword">begin</span>
    `uvm_error(get_type_name(),
      <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;MISMATCH! expected=%0d, actual=%0d (rst_n=%0b, enable=%0b)&quot;</span>,
                expected, item<span class="hljs-variable">.count</span>, item<span class="hljs-variable">.rst_n</span>, item<span class="hljs-variable">.enable</span>))
    error_count++;
  <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
    `uvm_info(get_type_name(),
      <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;MATCH: count=%0d (rst_n=%0b, enable=%0b)&quot;</span>,
                item<span class="hljs-variable">.count</span>, item<span class="hljs-variable">.rst_n</span>, item<span class="hljs-variable">.enable</span>), UVM_HIGH)
    match_count++;
  <span class="hljs-keyword">end</span>

  <span class="hljs-comment">// ⭐ Step 3: 상태 업데이트</span>
  prev_count = expected;
<span class="hljs-keyword">endfunction</span>
</code></pre><p><strong>핵심 패턴:</strong></p>
<ol>
<li><strong>예측(Predict)</strong>: Reference Model로 예상 출력 계산</li>
<li><strong>비교(Compare)</strong>: 예상 출력 ↔ 실제 DUT 출력 비교</li>
<li><strong>보고(Report)</strong>: 일치하면 PASS, 불일치하면 ERROR</li>
</ol>
<blockquote>
<p><strong><code>uvm_error</code> vs <code>uvm_fatal</code></strong>: 스코어보드에서 불일치를 발견하면 <code>uvm_error</code>를 사용합니다. <code>uvm_fatal</code>은 시뮬레이션을 즉시 중단하므로, 여러 오류를 모아서 보고하려면 <code>uvm_error</code>가 적합합니다.</p>
</blockquote>
<h3 id="8-2-4-기본-스코어보드-구현-예제-8-1">8.2.4 기본 스코어보드 구현 — 예제 8-1</h3>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// ===== 예제 8-1: 4비트 카운터 스코어보드 =====</span>
<span class="hljs-keyword">class</span> counter_scoreboard <span class="hljs-keyword">extends</span> uvm_scoreboard;
  `uvm_component_utils(counter_scoreboard)

  <span class="hljs-comment">// ⭐ analysis implementation — 모니터에서 트랜잭션을 받는 포트</span>
  uvm_analysis_imp <span class="hljs-variable">#(counter_seq_item, counter_scoreboard)</span> ap_imp;

  <span class="hljs-comment">// 내부 상태</span>
  <span class="hljs-keyword">logic</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] prev_count;          <span class="hljs-comment">// 이전 예측 값</span>
  <span class="hljs-keyword">int</span>         match_count;          <span class="hljs-comment">// 일치 횟수</span>
  <span class="hljs-keyword">int</span>         error_count;          <span class="hljs-comment">// 불일치 횟수</span>
  <span class="hljs-keyword">bit</span>         first_transaction;    <span class="hljs-comment">// 첫 트랜잭션 플래그</span>

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-comment">// ─── build_phase: 포트 생성 ───</span>
  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);
    ap_imp = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;ap_imp&quot;</span>, <span class="hljs-keyword">this</span>);
    prev_count = <span class="hljs-number">4&#x27;h0</span>;
    match_count = <span class="hljs-number">0</span>;
    error_count = <span class="hljs-number">0</span>;
    first_transaction = <span class="hljs-number">1</span>;
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-comment">// ─── Reference Model ───</span>
  <span class="hljs-keyword">function</span> <span class="hljs-keyword">logic</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] predict(
      <span class="hljs-keyword">logic</span> rst_n, <span class="hljs-keyword">logic</span> enable, <span class="hljs-keyword">logic</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] current
  );
    <span class="hljs-keyword">if</span> (!rst_n)     <span class="hljs-keyword">return</span> <span class="hljs-number">4&#x27;h0</span>;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (enable) <span class="hljs-keyword">return</span> current + <span class="hljs-number">1</span>;
    <span class="hljs-keyword">else</span>             <span class="hljs-keyword">return</span> current;
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-comment">// ─── write(): 모니터가 호출 → 자동 실행 ───</span>
  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> write(counter_seq_item item);
    <span class="hljs-keyword">logic</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] expected;

    <span class="hljs-comment">// 첫 트랜잭션은 초기 상태이므로 비교 생략</span>
    <span class="hljs-keyword">if</span> (first_transaction) <span class="hljs-keyword">begin</span>
      prev_count = item<span class="hljs-variable">.count</span>;
      first_transaction = <span class="hljs-number">0</span>;
      `uvm_info(get_type_name(),
        <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;Initial state: count=%0d&quot;</span>, item<span class="hljs-variable">.count</span>), UVM_MEDIUM)
      <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">end</span>

    <span class="hljs-comment">// Step 1: 예측</span>
    expected = predict(item<span class="hljs-variable">.rst_n</span>, item<span class="hljs-variable">.enable</span>, prev_count);

    <span class="hljs-comment">// Step 2: 비교</span>
    <span class="hljs-keyword">if</span> (expected !== item<span class="hljs-variable">.count</span>) <span class="hljs-keyword">begin</span>
      `uvm_error(get_type_name(),
        <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;MISMATCH! expected=%0d, actual=%0d (rst_n=%0b, en=%0b)&quot;</span>,
                  expected, item<span class="hljs-variable">.count</span>, item<span class="hljs-variable">.rst_n</span>, item<span class="hljs-variable">.enable</span>))
      error_count++;
    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
      `uvm_info(get_type_name(),
        <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;MATCH: count=%0d (rst_n=%0b, en=%0b)&quot;</span>,
                  item<span class="hljs-variable">.count</span>, item<span class="hljs-variable">.rst_n</span>, item<span class="hljs-variable">.enable</span>), UVM_HIGH)
      match_count++;
    <span class="hljs-keyword">end</span>

    <span class="hljs-comment">// Step 3: 상태 업데이트</span>
    prev_count = expected;
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-comment">// ─── check_phase: 시뮬레이션 종료 후 잔여 검증 ───</span>
  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> check_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.check_phase</span>(phase);
    <span class="hljs-comment">// ⭐ 트랜잭션을 하나도 받지 못했다면 연결 누락 가능성</span>
    <span class="hljs-keyword">if</span> (match_count + error_count == <span class="hljs-number">0</span>)
      `uvm_error(get_type_name(),
        <span class="hljs-string">&quot;No transactions received! Check monitor→scoreboard connection.&quot;</span>)
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-comment">// ─── report_phase: 최종 결과 요약 ───</span>
  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> report_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.report_phase</span>(phase);
    `uvm_info(get_type_name(), <span class="hljs-string">&quot;===== Scoreboard Summary =====&quot;</span>, UVM_LOW)
    `uvm_info(get_type_name(),
      <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;  Total transactions: %0d&quot;</span>, match_count + error_count), UVM_LOW)
    `uvm_info(get_type_name(),
      <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;  Matches : %0d&quot;</span>, match_count), UVM_LOW)
    `uvm_info(get_type_name(),
      <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;  Errors  : %0d&quot;</span>, error_count), UVM_LOW)

    <span class="hljs-keyword">if</span> (error_count &gt; <span class="hljs-number">0</span>)
      `uvm_error(get_type_name(),
        <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;TEST FAILED — %0d mismatches detected!&quot;</span>, error_count))
    <span class="hljs-keyword">else</span>
      `uvm_info(get_type_name(), <span class="hljs-string">&quot;TEST PASSED — all transactions matched!&quot;</span>, UVM_LOW)
  <span class="hljs-keyword">endfunction</span>
<span class="hljs-keyword">endclass</span>
</code></pre><p><strong>실행 결과 예시:</strong></p>
<pre><code>UVM_INFO  counter_scoreboard: Initial state: count=0
UVM_INFO  counter_scoreboard: MATCH: count=0 (rst_n=0, en=0)
UVM_INFO  counter_scoreboard: MATCH: count=1 (rst_n=1, en=1)
UVM_INFO  counter_scoreboard: MATCH: count=2 (rst_n=1, en=1)
...
UVM_INFO  counter_scoreboard: ===== Scoreboard Summary =====
UVM_INFO  counter_scoreboard:   Total transactions: 30
UVM_INFO  counter_scoreboard:   Matches : 30
UVM_INFO  counter_scoreboard:   Errors  : 0
UVM_INFO  counter_scoreboard: TEST PASSED — all transactions matched!
</code></pre><blockquote>
<p><strong>면접 포인트</strong>: &quot;스코어보드에서 Reference Model은 어떻게 구현하나요?&quot; — 간단한 DUT는 함수로 직접 구현합니다. 복잡한 프로토콜(PCIe, USB 등)은 C/C++ DPI 모델이나 별도 SystemVerilog 모듈을 사용합니다.</p>
</blockquote>
<hr>
<h2 id="8-3-스코어보드-심화">8.3 스코어보드 심화</h2>
<blockquote>
<p><strong>이 절의 목표</strong>: <code>uvm_subscriber</code>로 더 간단하게 스코어보드를 만들고, 실무에서 사용하는 패턴을 학습합니다.</p>
</blockquote>
<h3 id="8-3-1-uvm-subscriber-더-간단한-대안">8.3.1 uvm_subscriber — 더 간단한 대안</h3>
<p>Ch.7에서 <code>uvm_subscriber</code>를 잠깐 소개했습니다. <code>uvm_analysis_imp</code>를 직접 선언하는 것보다 <strong>훨씬 간단합니다</strong>.</p>
<p><strong>uvm_analysis_imp (직접 선언) vs uvm_subscriber (내장):</strong></p>
<table>
<thead>
<tr>
<th>항목</th>
<th>uvm_analysis_imp</th>
<th>uvm_subscriber</th>
</tr>
</thead>
<tbody><tr>
<td>포트 선언</td>
<td>직접 <code>uvm_analysis_imp</code> 생성</td>
<td>자동 내장 (<code>analysis_export</code>)</td>
</tr>
<tr>
<td>구현 메서드</td>
<td><code>write()</code> 직접 구현</td>
<td><code>write()</code> 직접 구현 (동일)</td>
</tr>
<tr>
<td>연결</td>
<td><code>mon.ap.connect(sb.ap_imp)</code></td>
<td><code>mon.ap.connect(sb.analysis_export)</code></td>
</tr>
<tr>
<td>코드량</td>
<td>많음</td>
<td>적음</td>
</tr>
<tr>
<td>다중 포트</td>
<td>지원 (여러 imp 선언)</td>
<td>불가 (포트 1개 고정)</td>
</tr>
</tbody></table>
<p><strong>uvm_subscriber 버전 스코어보드:</strong></p>
<pre><code class="hljs language-systemverilog"><span class="hljs-keyword">class</span> counter_scoreboard_sub <span class="hljs-keyword">extends</span> uvm_subscriber <span class="hljs-variable">#(counter_seq_item)</span>;
  `uvm_component_utils(counter_scoreboard_sub)

  <span class="hljs-keyword">logic</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] prev_count;
  <span class="hljs-keyword">int</span> match_count, error_count;
  <span class="hljs-keyword">bit</span> first_transaction = <span class="hljs-number">1</span>;

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-comment">// ⭐ uvm_subscriber는 write()만 구현하면 끝!</span>
  <span class="hljs-comment">//    포트 선언, build_phase에서 포트 생성 — 전부 자동</span>
  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> write(counter_seq_item t);
    <span class="hljs-keyword">logic</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] expected;

    <span class="hljs-keyword">if</span> (first_transaction) <span class="hljs-keyword">begin</span>
      prev_count = t<span class="hljs-variable">.count</span>;
      first_transaction = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">end</span>

    expected = (!t<span class="hljs-variable">.rst_n</span>) ? <span class="hljs-number">4&#x27;h0</span> :
               (t<span class="hljs-variable">.enable</span>) ? prev_count + <span class="hljs-number">1</span> : prev_count;

    <span class="hljs-keyword">if</span> (expected !== t<span class="hljs-variable">.count</span>) <span class="hljs-keyword">begin</span>
      `uvm_error(get_type_name(),
        <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;MISMATCH! exp=%0d, act=%0d&quot;</span>, expected, t<span class="hljs-variable">.count</span>))
      error_count++;
    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span>
      match_count++;

    prev_count = expected;
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> report_phase(uvm_phase phase);
    `uvm_info(get_type_name(),
      <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;Results: %0d matches, %0d errors&quot;</span>,
                match_count, error_count), UVM_LOW)
  <span class="hljs-keyword">endfunction</span>
<span class="hljs-keyword">endclass</span>
</code></pre><blockquote>
<p><strong>어떤 것을 사용할까?</strong> 포트가 1개면 <code>uvm_subscriber</code>가 간편합니다. 입력과 출력을 <strong>따로</strong> 받아야 하면 <code>uvm_analysis_imp</code>를 직접 선언해야 합니다 (8.3.3에서 다룸).</p>
</blockquote>
<h3 id="8-3-2-예측-비교-분리-패턴">8.3.2 예측-비교 분리 패턴</h3>
<p>실무에서 복잡한 DUT를 검증할 때는 스코어보드를 **Predictor(예측기)**와 **Comparator(비교기)**로 분리합니다.</p>

<div class="svg-diagram">
<svg viewBox="0 0 600 320" xmlns="http://www.w3.org/2000/svg" style="max-width:600px;width:100%">
  <defs>
    <marker id="ah" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto"><polygon points="0 0, 8 2.8, 0 5.6" fill="#64748b"/></marker>
    <marker id="ah-accent" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto"><polygon points="0 0, 8 2.8, 0 5.6" fill="#2563eb"/></marker>
    <filter id="sh" x="-5%" y="-5%" width="115%" height="115%"><feDropShadow dx="0" dy="2" stdDeviation="3" flood-color="#000" flood-opacity="0.1"/></filter>
  </defs>

  <!-- Outer box -->
  <rect x="15" y="10" width="570" height="300" rx="14" fill="#f8fafc" stroke="#94a3b8" stroke-width="2"/>
  <text x="300" y="38" text-anchor="middle" font-family="'Noto Sans KR',sans-serif" font-size="16" font-weight="bold" fill="#2563eb">예측-비교 분리 패턴</text>

  <!-- 입력 Monitor -->
  <rect x="60" y="60" width="170" height="50" rx="10" fill="#eff6ff" stroke="#2563eb" stroke-width="2" filter="url(#sh)"/>
  <text x="145" y="82" text-anchor="middle" font-family="'Fira Code',monospace" font-size="12" font-weight="bold" fill="#2563eb">입력 Monitor</text>
  <text x="145" y="99" text-anchor="middle" font-family="'Noto Sans KR',sans-serif" font-size="10" fill="#64748b">(자극 관찰)</text>

  <!-- 출력 Monitor -->
  <rect x="370" y="60" width="170" height="50" rx="10" fill="#f5f3ff" stroke="#7c3aed" stroke-width="2" filter="url(#sh)"/>
  <text x="455" y="82" text-anchor="middle" font-family="'Fira Code',monospace" font-size="12" font-weight="bold" fill="#5b21b6">출력 Monitor</text>
  <text x="455" y="99" text-anchor="middle" font-family="'Noto Sans KR',sans-serif" font-size="10" fill="#64748b">(결과 관찰)</text>

  <!-- Arrows down -->
  <line x1="145" y1="110" x2="145" y2="148" stroke="#2563eb" stroke-width="1.5" marker-end="url(#ah-accent)"/>
  <line x1="455" y1="110" x2="455" y2="148" stroke="#64748b" stroke-width="1.5" marker-end="url(#ah)"/>

  <!-- Predictor box -->
  <rect x="50" y="150" width="190" height="100" rx="10" fill="#ecfdf5" stroke="#10b981" stroke-width="2" filter="url(#sh)"/>
  <text x="145" y="178" text-anchor="middle" font-family="'Fira Code',monospace" font-size="13" font-weight="bold" fill="#065f46">Predictor</text>
  <text x="145" y="198" text-anchor="middle" font-family="'Noto Sans KR',sans-serif" font-size="11" fill="#64748b">(예측기)</text>
  <text x="145" y="228" text-anchor="middle" font-family="'Fira Code',monospace" font-size="11" fill="#1e293b">Ref Model</text>

  <!-- Comparator box -->
  <rect x="360" y="150" width="190" height="100" rx="10" fill="#fef3c7" stroke="#f59e0b" stroke-width="2" filter="url(#sh)"/>
  <text x="455" y="178" text-anchor="middle" font-family="'Fira Code',monospace" font-size="13" font-weight="bold" fill="#92400e">Comparator</text>
  <text x="455" y="198" text-anchor="middle" font-family="'Noto Sans KR',sans-serif" font-size="11" fill="#64748b">(비교기)</text>
  <text x="455" y="228" text-anchor="middle" font-family="'Noto Sans KR',sans-serif" font-size="11" fill="#1e293b">예측 vs 실제 비교</text>

  <!-- Predictor → Comparator arrow -->
  <line x1="240" y1="200" x2="358" y2="200" stroke="#10b981" stroke-width="1.5" marker-end="url(#ah)"/>
  <text x="299" y="190" text-anchor="middle" font-family="'Noto Sans KR',sans-serif" font-size="11" font-weight="bold" fill="#10b981">예측값</text>

  <!-- Legend -->
  <text x="300" y="288" text-anchor="middle" font-family="'Noto Sans KR',sans-serif" font-size="11" fill="#64748b">역할 분리로 디버깅 용이 &amp; Predictor 재사용 가능</text>
</svg>
</div><p>이 패턴은 Part 3 (Chapter 11+)에서 복잡한 프로토콜 검증 시 다시 다룹니다. 지금은 **&quot;스코어보드를 분리할 수 있다&quot;**는 개념만 기억하세요.</p>
<blockquote>
<p><strong>왜 분리하나?</strong> Predictor는 입력을 받아 예측만 합니다. Comparator는 예측값과 실제값을 비교만 합니다. 각자의 역할이 명확해 디버깅이 쉽고, Predictor를 다른 프로젝트에 재사용할 수 있습니다.</p>
</blockquote>
<h3 id="8-3-3-멀티포트-스코어보드">8.3.3 멀티포트 스코어보드</h3>
<p>4비트 카운터처럼 간단한 DUT는 모니터 1개로 충분합니다. 하지만 실무에서는 <strong>입력과 출력을 별도 모니터</strong>로 관찰하는 경우가 많습니다.</p>

<div class="svg-diagram">
<svg viewBox="0 0 620 360" xmlns="http://www.w3.org/2000/svg" style="max-width:620px;width:100%">
  <defs>
    <marker id="ah" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto"><polygon points="0 0, 8 2.8, 0 5.6" fill="#64748b"/></marker>
    <marker id="ah-accent" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto"><polygon points="0 0, 8 2.8, 0 5.6" fill="#2563eb"/></marker>
    <filter id="sh" x="-5%" y="-5%" width="115%" height="115%"><feDropShadow dx="0" dy="2" stdDeviation="3" flood-color="#000" flood-opacity="0.1"/></filter>
  </defs>

  <!-- Title -->
  <text x="310" y="28" text-anchor="middle" font-family="'Noto Sans KR',sans-serif" font-size="17" font-weight="bold" fill="#2563eb">멀티포트 스코어보드</text>

  <!-- Input Monitor -->
  <rect x="50" y="55" width="170" height="50" rx="10" fill="#eff6ff" stroke="#2563eb" stroke-width="2" filter="url(#sh)"/>
  <text x="135" y="76" text-anchor="middle" font-family="'Fira Code',monospace" font-size="12" font-weight="bold" fill="#2563eb">입력 Monitor</text>
  <text x="135" y="93" text-anchor="middle" font-family="'Noto Sans KR',sans-serif" font-size="11" fill="#64748b">(자극 관찰)</text>

  <!-- Output Monitor -->
  <rect x="400" y="55" width="170" height="50" rx="10" fill="#f5f3ff" stroke="#7c3aed" stroke-width="2" filter="url(#sh)"/>
  <text x="485" y="76" text-anchor="middle" font-family="'Fira Code',monospace" font-size="12" font-weight="bold" fill="#5b21b6">출력 Monitor</text>
  <text x="485" y="93" text-anchor="middle" font-family="'Noto Sans KR',sans-serif" font-size="11" fill="#64748b">(결과 관찰)</text>

  <!-- Arrows down -->
  <line x1="135" y1="105" x2="135" y2="138" stroke="#2563eb" stroke-width="1.5" marker-end="url(#ah-accent)"/>
  <line x1="485" y1="105" x2="485" y2="138" stroke="#64748b" stroke-width="1.5" marker-end="url(#ah)"/>

  <!-- Scoreboard outer box -->
  <rect x="60" y="140" width="500" height="190" rx="12" fill="#ecfdf5" stroke="#10b981" stroke-width="2" filter="url(#sh)"/>
  <text x="310" y="165" text-anchor="middle" font-family="'Fira Code',monospace" font-size="15" font-weight="bold" fill="#065f46">Scoreboard</text>

  <!-- ap_imp_in -->
  <rect x="90" y="180" width="160" height="44" rx="8" fill="#eff6ff" stroke="#2563eb" stroke-width="1.5"/>
  <text x="170" y="200" text-anchor="middle" font-family="'Fira Code',monospace" font-size="12" font-weight="bold" fill="#2563eb">ap_imp_in</text>
  <text x="170" y="216" text-anchor="middle" font-family="'Noto Sans KR',sans-serif" font-size="10" fill="#64748b">(입력 포트)</text>

  <!-- ap_imp_out -->
  <rect x="370" y="180" width="160" height="44" rx="8" fill="#f5f3ff" stroke="#7c3aed" stroke-width="1.5"/>
  <text x="450" y="200" text-anchor="middle" font-family="'Fira Code',monospace" font-size="12" font-weight="bold" fill="#5b21b6">ap_imp_out</text>
  <text x="450" y="216" text-anchor="middle" font-family="'Noto Sans KR',sans-serif" font-size="10" fill="#64748b">(출력 포트)</text>

  <!-- Arrows to comparison -->
  <line x1="170" y1="224" x2="170" y2="260" stroke="#2563eb" stroke-width="1.5"/>
  <line x1="450" y1="224" x2="450" y2="260" stroke="#7c3aed" stroke-width="1.5"/>

  <!-- Comparison box -->
  <rect x="120" y="260" width="380" height="46" rx="10" fill="#fef3c7" stroke="#f59e0b" stroke-width="2"/>
  <text x="310" y="288" text-anchor="middle" font-family="'Noto Sans KR',sans-serif" font-size="13" font-weight="bold" fill="#92400e">예측 큐 vs 실제 비교</text>
</svg>
</div><p><strong>멀티포트 스코어보드의 핵심</strong>: <code>uvm_analysis_imp</code>를 2개 사용하려면 매크로가 필요합니다.</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// ⭐ 매크로로 별명 포트 선언 — UVM 표준 방식</span>
`uvm_analysis_imp_decl(_input)
`uvm_analysis_imp_decl(_output)

<span class="hljs-keyword">class</span> counter_scoreboard_multi <span class="hljs-keyword">extends</span> uvm_scoreboard;
  `uvm_component_utils(counter_scoreboard_multi)

  <span class="hljs-comment">// ⭐ 2개의 analysis implementation port</span>
  uvm_analysis_imp_input  <span class="hljs-variable">#(counter_seq_item, counter_scoreboard_multi)</span> ap_in;
  uvm_analysis_imp_output <span class="hljs-variable">#(counter_seq_item, counter_scoreboard_multi)</span> ap_out;

  <span class="hljs-comment">// 예측 큐 — 입력 기반 예측값 저장</span>
  <span class="hljs-keyword">logic</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] expected_queue[$];
  <span class="hljs-keyword">int</span> match_count, error_count;

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);
    ap_in  = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;ap_in&quot;</span>,  <span class="hljs-keyword">this</span>);
    ap_out = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;ap_out&quot;</span>, <span class="hljs-keyword">this</span>);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-comment">// ⭐ 입력 포트: 입력 트랜잭션을 받아 예측값 저장</span>
  <span class="hljs-comment">//   실무에서는 입력 모니터가 자극(rst_n, enable)만 관찰하고,</span>
  <span class="hljs-comment">//   출력 모니터가 결과(count)를 관찰합니다.</span>
  <span class="hljs-comment">//   여기서는 단순화를 위해 item.count(현재 상태)를 참조합니다.</span>
  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> write_input(counter_seq_item item);
    <span class="hljs-keyword">logic</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] predicted;
    predicted = (!item<span class="hljs-variable">.rst_n</span>) ? <span class="hljs-number">4&#x27;h0</span> :
                (item<span class="hljs-variable">.enable</span>) ? item<span class="hljs-variable">.count</span> + <span class="hljs-number">1</span> : item<span class="hljs-variable">.count</span>;
    expected_queue<span class="hljs-variable">.push_back</span>(predicted);
    `uvm_info(get_type_name(),
      <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;Predicted: %0d (queue size: %0d)&quot;</span>,
                predicted, expected_queue<span class="hljs-variable">.size</span>()), UVM_HIGH)
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-comment">// ⭐ 출력 포트: 실제 출력과 예측값 비교</span>
  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> write_output(counter_seq_item item);
    <span class="hljs-keyword">logic</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] expected;

    <span class="hljs-keyword">if</span> (expected_queue<span class="hljs-variable">.size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">begin</span>
      `uvm_error(get_type_name(), <span class="hljs-string">&quot;Unexpected output — no prediction in queue!&quot;</span>)
      <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">end</span>

    expected = expected_queue<span class="hljs-variable">.pop_front</span>();

    <span class="hljs-keyword">if</span> (expected !== item<span class="hljs-variable">.count</span>) <span class="hljs-keyword">begin</span>
      `uvm_error(get_type_name(),
        <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;MISMATCH! exp=%0d, act=%0d&quot;</span>, expected, item<span class="hljs-variable">.count</span>))
      error_count++;
    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span>
      match_count++;
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> report_phase(uvm_phase phase);
    `uvm_info(get_type_name(),
      <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;Results: %0d matches, %0d errors&quot;</span>, match_count, error_count),
      UVM_LOW)
    <span class="hljs-keyword">if</span> (expected_queue<span class="hljs-variable">.size</span>() &gt; <span class="hljs-number">0</span>)
      `uvm_warning(get_type_name(),
        <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;%0d predictions left unchecked!&quot;</span>, expected_queue<span class="hljs-variable">.size</span>()))
  <span class="hljs-keyword">endfunction</span>
<span class="hljs-keyword">endclass</span>
</code></pre><p><strong>핵심 포인트:</strong></p>
<ul>
<li><code>uvm_analysis_imp_decl(_input)</code>: <code>write_input()</code> 메서드를 사용하는 포트 타입 생성</li>
<li><code>uvm_analysis_imp_decl(_output)</code>: <code>write_output()</code> 메서드를 사용하는 포트 타입 생성</li>
<li>예측 큐(<code>expected_queue</code>)로 입력 기반 예측과 출력 비교를 시간차로 처리</li>
</ul>
<blockquote>
<p><strong>면접 포인트</strong>: &quot;멀티포트 스코어보드를 구현한 경험이 있나요?&quot; — <code>uvm_analysis_imp_decl</code> 매크로로 접미사별 포트를 생성하고, <code>write_접미사()</code> 메서드로 각각 처리합니다. 실무에서 AXI, AHB 같은 버스 프로토콜 검증 시 입력/출력 포트 분리가 필수입니다.</p>
</blockquote>
<h3 id="8-3-4-report-phase-로-최종-결과-요약">8.3.4 report_phase()로 최종 결과 요약</h3>
<p>예제 8-1에서 이미 <code>report_phase()</code>를 사용했습니다. 실무에서 자주 쓰는 패턴을 정리합니다:</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> report_phase(uvm_phase phase);
  uvm_report_server svr = uvm_report_server::get_server();

  `uvm_info(get_type_name(), <span class="hljs-string">&quot;============ SCOREBOARD REPORT ============&quot;</span>, UVM_LOW)
  `uvm_info(get_type_name(),
    <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;  Transactions checked: %0d&quot;</span>, match_count + error_count), UVM_LOW)
  `uvm_info(get_type_name(),
    <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;  Pass: %0d / Fail: %0d&quot;</span>, match_count, error_count), UVM_LOW)
  `uvm_info(get_type_name(), <span class="hljs-string">&quot;============================================&quot;</span>, UVM_LOW)

  <span class="hljs-comment">// ⭐ 트랜잭션이 0개면 경고 — 연결 누락 가능성</span>
  <span class="hljs-keyword">if</span> (match_count + error_count == <span class="hljs-number">0</span>)
    `uvm_warning(get_type_name(),
      <span class="hljs-string">&quot;No transactions received! Check monitor-scoreboard connection.&quot;</span>)
<span class="hljs-keyword">endfunction</span>
</code></pre><blockquote>
<p><strong>트러블슈팅</strong>: <code>No transactions received!</code> 경고가 뜨면?</p>
<ol>
<li><code>env.connect_phase()</code>에서 <code>agent.mon.ap.connect(scoreboard.ap_imp)</code> 확인</li>
<li>모니터가 <code>ap.write(item)</code>을 호출하는지 확인</li>
<li>Agent가 Active 모드인지 확인 (<code>is_active == UVM_ACTIVE</code>)</li>
</ol>
</blockquote>
<hr>
<h2 id="8-4-기능-커버리지-기초">8.4 기능 커버리지 기초</h2>
<blockquote>
<p><strong>이 절의 목표</strong>: SystemVerilog <code>covergroup</code>을 사용해 기능 커버리지를 수집하고, 검증 완전성을 정량적으로 측정합니다.</p>
</blockquote>
<h3 id="8-4-1-코드-커버리지-vs-기능-커버리지">8.4.1 코드 커버리지 vs 기능 커버리지</h3>
<p>커버리지는 두 종류가 있습니다:</p>
<table>
<thead>
<tr>
<th>항목</th>
<th>코드 커버리지</th>
<th>기능 커버리지</th>
</tr>
</thead>
<tbody><tr>
<td><strong>무엇을</strong></td>
<td>RTL 코드 실행 여부</td>
<td><strong>기능 시나리오</strong> 검증 여부</td>
</tr>
<tr>
<td><strong>누가</strong></td>
<td>시뮬레이터 자동 수집</td>
<td><strong>검증 엔지니어가 정의</strong></td>
</tr>
<tr>
<td><strong>예시</strong></td>
<td>&quot;이 if문 실행됐나?&quot;</td>
<td>&quot;reset 후 enable 시나리오 테스트했나?&quot;</td>
</tr>
<tr>
<td><strong>도구</strong></td>
<td>VCS: <code>-cm line+cond+...</code></td>
<td><code>covergroup</code> 문법</td>
</tr>
<tr>
<td><strong>한계</strong></td>
<td>코드가 실행됐다 ≠ 기능 검증됨</td>
<td>정의하지 않은 건 측정 불가</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>핵심</strong>: 코드 커버리지 100%여도 버그가 있을 수 있습니다. 코드가 &quot;실행&quot;만 됐을 뿐 &quot;올바른 결과&quot;인지는 확인하지 않기 때문입니다. <strong>기능 커버리지</strong>는 &quot;의미 있는 시나리오를 테스트했는가?&quot;를 측정합니다.</p>
</blockquote>
<h3 id="8-4-2-covergroup-coverpoint-bins">8.4.2 covergroup, coverpoint, bins</h3>
<p><code>covergroup</code>은 <strong>SystemVerilog 문법</strong>입니다 (UVM 전용이 아님). UVM 테스트벤치에서 활용하는 방법을 배웁니다.</p>
<p><strong>기본 문법:</strong></p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// covergroup 선언</span>
<span class="hljs-keyword">covergroup</span> counter_cg @(<span class="hljs-keyword">posedge</span> clk);
  <span class="hljs-comment">// ⭐ coverpoint: 관심 있는 변수</span>
  cp_rst_n: <span class="hljs-keyword">coverpoint</span> rst_n {
    <span class="hljs-keyword">bins</span> active   = {<span class="hljs-number">0</span>};    <span class="hljs-comment">// 리셋 활성화</span>
    <span class="hljs-keyword">bins</span> inactive = {<span class="hljs-number">1</span>};    <span class="hljs-comment">// 리셋 비활성화</span>
  }

  cp_enable: <span class="hljs-keyword">coverpoint</span> enable {
    <span class="hljs-keyword">bins</span> on  = {<span class="hljs-number">1</span>};         <span class="hljs-comment">// 카운터 활성화</span>
    <span class="hljs-keyword">bins</span> off = {<span class="hljs-number">0</span>};         <span class="hljs-comment">// 카운터 비활성화</span>
  }

  cp_count: <span class="hljs-keyword">coverpoint</span> count {
    <span class="hljs-keyword">bins</span> zero     = {<span class="hljs-number">0</span>};           <span class="hljs-comment">// 0 값</span>
    <span class="hljs-keyword">bins</span> mid      = {[<span class="hljs-number">1</span>:<span class="hljs-number">14</span>]};      <span class="hljs-comment">// 중간 값</span>
    <span class="hljs-keyword">bins</span> max      = {<span class="hljs-number">15</span>};          <span class="hljs-comment">// 최대 값 (오버플로우 직전)</span>
  }
<span class="hljs-keyword">endgroup</span>
</code></pre><p><strong>용어 정리:</strong></p>
<table>
<thead>
<tr>
<th>용어</th>
<th>뜻</th>
<th>비유</th>
</tr>
</thead>
<tbody><tr>
<td><code>covergroup</code></td>
<td>커버리지 그룹</td>
<td>시험 과목</td>
</tr>
<tr>
<td><code>coverpoint</code></td>
<td>관찰 대상 변수</td>
<td>시험 문제</td>
</tr>
<tr>
<td><code>bins</code></td>
<td>값 범위 구간</td>
<td>문제의 보기 (각각 맞춰야 100%)</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>참고</strong>: <code>bins</code>를 직접 정의하지 않으면 시뮬레이터가 <strong>자동으로</strong> bin을 생성합니다 (auto bins). 기본값은 <code>auto_bin_max = 64</code>개입니다. 자동 bin은 편리하지만, 의미 있는 구간을 직접 정의하는 것이 실무에서 권장됩니다.</p>
</blockquote>
<h3 id="8-4-3-cross-coverage">8.4.3 cross coverage</h3>
<p><code>cross</code>는 두 coverpoint의 <strong>조합</strong>을 측정합니다.</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-keyword">covergroup</span> counter_cg @(<span class="hljs-keyword">posedge</span> clk);
  cp_rst_n:  <span class="hljs-keyword">coverpoint</span> rst_n;
  cp_enable: <span class="hljs-keyword">coverpoint</span> enable;
  cp_count:  <span class="hljs-keyword">coverpoint</span> count {
    <span class="hljs-keyword">bins</span> zero = {<span class="hljs-number">0</span>};
    <span class="hljs-keyword">bins</span> mid  = {[<span class="hljs-number">1</span>:<span class="hljs-number">14</span>]};
    <span class="hljs-keyword">bins</span> max  = {<span class="hljs-number">15</span>};
  }

  <span class="hljs-comment">// ⭐ cross: 조합 커버리지</span>
  <span class="hljs-comment">//    rst_n × enable = 4가지 조합 (00, 01, 10, 11)</span>
  cx_rst_en: <span class="hljs-keyword">cross</span> cp_rst_n, cp_enable;

  <span class="hljs-comment">// ⭐ enable × count 조합</span>
  <span class="hljs-comment">//    enable이 1일 때 count가 0/mid/max 모두 나왔는가?</span>
  cx_en_count: <span class="hljs-keyword">cross</span> cp_enable, cp_count;
<span class="hljs-keyword">endgroup</span>
</code></pre><p><strong>cross coverage가 중요한 이유:</strong></p>
<ul>
<li><code>rst_n = 0</code> 테스트함 ✅</li>
<li><code>enable = 1</code> 테스트함 ✅</li>
<li>하지만 <code>rst_n = 0 &amp;&amp; enable = 1</code> 조합은? → cross가 잡아냄</li>
</ul>
<blockquote>
<p><strong>실무 이야기</strong>: 팹리스에서 테이프아웃 전 기능 커버리지 목표는 보통 <strong>95% 이상</strong>입니다. cross coverage까지 95%를 달성해야 &quot;검증 완료&quot;로 판단합니다.</p>
</blockquote>
<h3 id="8-4-4-기본-커버리지-수집기-예제-8-2">8.4.4 기본 커버리지 수집기 — 예제 8-2</h3>
<p>커버리지 수집기도 <code>uvm_subscriber</code>로 구현합니다. 모니터의 analysis port에 연결되어 트랜잭션을 받을 때마다 covergroup을 샘플링합니다.</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// ===== 예제 8-2: 4비트 카운터 커버리지 수집기 =====</span>
<span class="hljs-keyword">class</span> counter_coverage <span class="hljs-keyword">extends</span> uvm_subscriber <span class="hljs-variable">#(counter_seq_item)</span>;
  `uvm_component_utils(counter_coverage)

  <span class="hljs-comment">// ⭐ 커버리지 그룹 선언</span>
  <span class="hljs-keyword">covergroup</span> counter_cg;
    cp_rst_n: <span class="hljs-keyword">coverpoint</span> item<span class="hljs-variable">.rst_n</span> {
      <span class="hljs-keyword">bins</span> active   = {<span class="hljs-number">0</span>};
      <span class="hljs-keyword">bins</span> inactive = {<span class="hljs-number">1</span>};
    }

    cp_enable: <span class="hljs-keyword">coverpoint</span> item<span class="hljs-variable">.enable</span> {
      <span class="hljs-keyword">bins</span> on  = {<span class="hljs-number">1</span>};
      <span class="hljs-keyword">bins</span> off = {<span class="hljs-number">0</span>};
    }

    cp_count: <span class="hljs-keyword">coverpoint</span> item<span class="hljs-variable">.count</span> {
      <span class="hljs-keyword">bins</span> zero     = {<span class="hljs-number">0</span>};
      <span class="hljs-keyword">bins</span> low      = {[<span class="hljs-number">1</span>:<span class="hljs-number">7</span>]};
      <span class="hljs-keyword">bins</span> high     = {[<span class="hljs-number">8</span>:<span class="hljs-number">14</span>]};
      <span class="hljs-keyword">bins</span> max      = {<span class="hljs-number">15</span>};
    }

    <span class="hljs-comment">// cross coverage</span>
    cx_rst_en:    <span class="hljs-keyword">cross</span> cp_rst_n, cp_enable;
    cx_en_count:  <span class="hljs-keyword">cross</span> cp_enable, cp_count;
  <span class="hljs-keyword">endgroup</span>

  <span class="hljs-comment">// 트랜잭션 저장용 — covergroup에서 참조</span>
  counter_seq_item item;

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
    counter_cg = <span class="hljs-keyword">new</span>();    <span class="hljs-comment">// ⭐ covergroup 인스턴스 생성</span>
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-comment">// ⭐ write(): 트랜잭션 수신 시 커버리지 샘플링</span>
  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> write(counter_seq_item t);
    <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// null 트랜잭션 방어</span>
    item = t;
    counter_cg<span class="hljs-variable">.sample</span>();    <span class="hljs-comment">// ⭐ 커버리지 수집!</span>
    `uvm_info(get_type_name(),
      <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;Sampled: rst_n=%0b, en=%0b, count=%0d&quot;</span>,
                t<span class="hljs-variable">.rst_n</span>, t<span class="hljs-variable">.enable</span>, t<span class="hljs-variable">.count</span>), UVM_HIGH)
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-comment">// ⭐ report_phase: 커버리지 요약 출력</span>
  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> report_phase(uvm_phase phase);
    `uvm_info(get_type_name(), <span class="hljs-string">&quot;===== Coverage Summary =====&quot;</span>, UVM_LOW)
    `uvm_info(get_type_name(),
      <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;  Overall: %.1f%%&quot;</span>, counter_cg<span class="hljs-variable">.get_coverage</span>()), UVM_LOW)
    `uvm_info(get_type_name(),
      <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;  rst_n : %.1f%%&quot;</span>, counter_cg<span class="hljs-variable">.cp_rst_n</span><span class="hljs-variable">.get_coverage</span>()), UVM_LOW)
    `uvm_info(get_type_name(),
      <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;  enable: %.1f%%&quot;</span>, counter_cg<span class="hljs-variable">.cp_enable</span><span class="hljs-variable">.get_coverage</span>()), UVM_LOW)
    `uvm_info(get_type_name(),
      <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;  count : %.1f%%&quot;</span>, counter_cg<span class="hljs-variable">.cp_count</span><span class="hljs-variable">.get_coverage</span>()), UVM_LOW)
    `uvm_info(get_type_name(),
      <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;  cross(rst,en)   : %.1f%%&quot;</span>,
                counter_cg<span class="hljs-variable">.cx_rst_en</span><span class="hljs-variable">.get_coverage</span>()), UVM_LOW)
    `uvm_info(get_type_name(),
      <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;  cross(en,count) : %.1f%%&quot;</span>,
                counter_cg<span class="hljs-variable">.cx_en_count</span><span class="hljs-variable">.get_coverage</span>()), UVM_LOW)
  <span class="hljs-keyword">endfunction</span>
<span class="hljs-keyword">endclass</span>
</code></pre><p><strong>실행 결과 예시:</strong></p>
<pre><code>UVM_INFO  counter_coverage: ===== Coverage Summary =====
UVM_INFO  counter_coverage:   Overall: 78.5%
UVM_INFO  counter_coverage:   rst_n : 100.0%
UVM_INFO  counter_coverage:   enable: 100.0%
UVM_INFO  counter_coverage:   count : 75.0%      ← max(15) 미달!
UVM_INFO  counter_coverage:   cross(rst,en)   : 100.0%
UVM_INFO  counter_coverage:   cross(en,count) : 62.5%   ← 조합 부족!
</code></pre><blockquote>
<p><strong>분석</strong>: count의 <code>max</code> bin(15)이 hit되지 않았습니다. 오버플로우까지 카운터를 돌리는 시퀀스가 필요합니다. → Ch.9에서 시나리오별 시퀀스 작성을 배웁니다.</p>
</blockquote>
<hr>
<h2 id="8-5-커버리지-기반-검증-cdv">8.5 커버리지 기반 검증 (CDV)</h2>
<blockquote>
<p><strong>이 절의 목표</strong>: Coverage-Driven Verification 워크플로우를 이해하고, 커버리지를 체계적으로 관리하는 방법을 배웁니다.</p>
</blockquote>
<h3 id="8-5-1-cdv-워크플로우">8.5.1 CDV 워크플로우</h3>

<div class="svg-diagram">
<svg viewBox="0 0 580 440" xmlns="http://www.w3.org/2000/svg" style="max-width:580px;width:100%">
  <defs>
    <marker id="ah" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto"><polygon points="0 0, 8 2.8, 0 5.6" fill="#64748b"/></marker>
    <marker id="ah-accent" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto"><polygon points="0 0, 8 2.8, 0 5.6" fill="#2563eb"/></marker>
    <marker id="ah-green" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto"><polygon points="0 0, 8 2.8, 0 5.6" fill="#10b981"/></marker>
    <filter id="sh" x="-5%" y="-5%" width="115%" height="115%"><feDropShadow dx="0" dy="2" stdDeviation="3" flood-color="#000" flood-opacity="0.1"/></filter>
  </defs>

  <!-- Title -->
  <text x="290" y="28" text-anchor="middle" font-family="'Noto Sans KR',sans-serif" font-size="17" font-weight="bold" fill="#2563eb">CDV (Coverage-Driven Verification)</text>

  <!-- Step 1: 목표 설정 -->
  <rect x="140" y="50" width="180" height="50" rx="10" fill="#eff6ff" stroke="#2563eb" stroke-width="2" filter="url(#sh)"/>
  <text x="230" y="72" text-anchor="middle" font-family="'Noto Sans KR',sans-serif" font-size="13" font-weight="bold" fill="#1e293b">1. 목표 설정</text>
  <text x="230" y="89" text-anchor="middle" font-family="'Noto Sans KR',sans-serif" font-size="10" fill="#64748b">커버리지 항목 정의</text>
  <text x="370" y="80" text-anchor="start" font-family="'Noto Sans KR',sans-serif" font-size="10" fill="#64748b">목표: 95% 이상</text>

  <line x1="230" y1="100" x2="230" y2="123" stroke="#64748b" stroke-width="1.5" marker-end="url(#ah)"/>

  <!-- Step 2: 테스트 실행 -->
  <rect x="140" y="126" width="180" height="50" rx="10" fill="#ecfdf5" stroke="#10b981" stroke-width="2" filter="url(#sh)"/>
  <text x="230" y="148" text-anchor="middle" font-family="'Noto Sans KR',sans-serif" font-size="13" font-weight="bold" fill="#1e293b">2. 테스트 실행</text>
  <text x="230" y="165" text-anchor="middle" font-family="'Noto Sans KR',sans-serif" font-size="10" fill="#64748b">시퀀스 작성 &amp; 실행</text>

  <line x1="230" y1="176" x2="230" y2="199" stroke="#64748b" stroke-width="1.5" marker-end="url(#ah)"/>

  <!-- Step 3: 커버리지 분석 -->
  <rect x="140" y="202" width="180" height="50" rx="10" fill="#f5f3ff" stroke="#7c3aed" stroke-width="2" filter="url(#sh)"/>
  <text x="230" y="224" text-anchor="middle" font-family="'Noto Sans KR',sans-serif" font-size="13" font-weight="bold" fill="#1e293b">3. 커버리지 분석</text>
  <text x="230" y="241" text-anchor="middle" font-family="'Noto Sans KR',sans-serif" font-size="10" fill="#64748b">미달 bin 확인</text>

  <line x1="230" y1="252" x2="230" y2="275" stroke="#64748b" stroke-width="1.5" marker-end="url(#ah)"/>

  <!-- Step 4: 목표 달성? (diamond) -->
  <polygon points="230,278 310,310 230,342 150,310" fill="#fef3c7" stroke="#f59e0b" stroke-width="2"/>
  <text x="230" y="306" text-anchor="middle" font-family="'Noto Sans KR',sans-serif" font-size="12" font-weight="bold" fill="#92400e">4. 목표</text>
  <text x="230" y="320" text-anchor="middle" font-family="'Noto Sans KR',sans-serif" font-size="12" font-weight="bold" fill="#92400e">달성?</text>

  <!-- No → Loop back -->
  <line x1="310" y1="310" x2="420" y2="310" stroke="#ef4444" stroke-width="2"/>
  <text x="350" y="302" text-anchor="middle" font-family="'Noto Sans KR',sans-serif" font-size="11" font-weight="bold" fill="#ef4444">No</text>

  <rect x="400" y="285" width="150" height="50" rx="10" fill="#fef2f2" stroke="#ef4444" stroke-width="2" filter="url(#sh)"/>
  <text x="475" y="307" text-anchor="middle" font-family="'Noto Sans KR',sans-serif" font-size="11" font-weight="bold" fill="#ef4444">추가 시나리오</text>
  <text x="475" y="323" text-anchor="middle" font-family="'Noto Sans KR',sans-serif" font-size="10" fill="#64748b">작성 후 2로</text>

  <!-- Loop arrow back to Step 2 -->
  <path d="M 475 285 L 475 151 L 322 151" fill="none" stroke="#ef4444" stroke-width="1.5" stroke-dasharray="6,3" marker-end="url(#ah)"/>

  <!-- Yes → Step 5 -->
  <line x1="230" y1="342" x2="230" y2="370" stroke="#10b981" stroke-width="1.5" marker-end="url(#ah-green)"/>
  <text x="245" y="360" text-anchor="start" font-family="'Noto Sans KR',sans-serif" font-size="11" font-weight="bold" fill="#10b981">Yes</text>

  <!-- Step 5: 검증 완료! -->
  <rect x="140" y="374" width="180" height="50" rx="25" fill="#ecfdf5" stroke="#10b981" stroke-width="3" filter="url(#sh)"/>
  <text x="230" y="404" text-anchor="middle" font-family="'Noto Sans KR',sans-serif" font-size="14" font-weight="bold" fill="#065f46">5. 검증 완료!</text>
</svg>
</div><p><strong>단계별 설명:</strong></p>
<table>
<thead>
<tr>
<th>단계</th>
<th>활동</th>
<th>산출물</th>
</tr>
</thead>
<tbody><tr>
<td>1. 목표 설정</td>
<td>DUT 기능 명세에서 커버리지 항목 추출</td>
<td>커버리지 계획서</td>
</tr>
<tr>
<td>2. 테스트 실행</td>
<td>시퀀스로 다양한 시나리오 실행</td>
<td>시뮬레이션 로그</td>
</tr>
<tr>
<td>3. 커버리지 분석</td>
<td>미달 bin 확인, 원인 분석</td>
<td>커버리지 리포트</td>
</tr>
<tr>
<td>4. 목표 확인</td>
<td>95% 이상 달성했는지 확인</td>
<td>합격/추가 작업</td>
</tr>
<tr>
<td>5. 완료</td>
<td>사인오프, 테이프아웃 진행</td>
<td>검증 완료 보고서</td>
</tr>
</tbody></table>
<h3 id="8-5-2-커버리지-리포트-읽기">8.5.2 커버리지 리포트 읽기</h3>
<p>시뮬레이션 후 커버리지 리포트를 읽는 방법입니다:</p>
<pre><code>=== Coverage Report ===
covergroup: counter_cg

  coverpoint: cp_rst_n          Coverage: 100.0%
    bins active   = {0}         hit: 5     ✅
    bins inactive = {1}         hit: 25    ✅

  coverpoint: cp_enable         Coverage: 100.0%
    bins on  = {1}              hit: 20    ✅
    bins off = {0}              hit: 10    ✅

  coverpoint: cp_count          Coverage: 75.0%
    bins zero = {0}             hit: 5     ✅
    bins low  = {[1:7]}         hit: 12    ✅
    bins high = {[8:14]}        hit: 8     ✅
    bins max  = {15}            hit: 0     ❌ ← 미달!

  cross: cx_en_count            Coverage: 62.5%
    &lt;enable=1, count=max&gt;       hit: 0     ❌ ← 미달!
    &lt;enable=0, count=max&gt;       hit: 0     ❌ ← 미달!
</code></pre><p><strong>읽는 법:</strong></p>
<ol>
<li>각 bin의 <code>hit</code> 수를 확인 — 0이면 해당 시나리오 미테스트</li>
<li><strong>cross coverage</strong> 주목 — 개별 100%여도 조합이 부족할 수 있음</li>
<li>미달 항목에 맞는 <strong>타겟 시퀀스</strong> 작성 (Ch.9에서 상세히)</li>
</ol>
<h3 id="8-5-3-커버리지-100-의-함정">8.5.3 커버리지 100%의 함정</h3>
<blockquote>
<p><strong>중요</strong>: 기능 커버리지 100% ≠ 버그 없음</p>
</blockquote>
<table>
<thead>
<tr>
<th>함정</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td><strong>정의 누락</strong></td>
<td>정의하지 않은 시나리오는 측정 불가</td>
</tr>
<tr>
<td><strong>스코어보드 없는 커버리지</strong></td>
<td>실행만 하고 결과를 확인하지 않으면 무의미</td>
</tr>
<tr>
<td><strong>과도한 bin 생략</strong></td>
<td><code>illegal_bins</code>, <code>ignore_bins</code>로 너무 많이 제외</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>실무 규칙</strong>: 커버리지는 <strong>스코어보드와 함께</strong> 사용해야 의미가 있습니다. &quot;실행했다&quot;와 &quot;검증했다&quot;는 다릅니다. 스코어보드가 PASS를 보고한 상태에서 커버리지 95%가 진짜 검증 완료입니다.</p>
</blockquote>
<hr>
<h2 id="8-6-종합-자동-검증-테스트벤치">8.6 종합: 자동 검증 테스트벤치</h2>
<blockquote>
<p><strong>이 절의 목표</strong>: 스코어보드와 커버리지를 Environment에 통합하여 완전한 자동 검증 테스트벤치를 완성합니다.</p>
</blockquote>
<h3 id="8-6-1-전체-구조">8.6.1 전체 구조</h3>

<div class="svg-diagram">
<svg viewBox="0 0 700 520" xmlns="http://www.w3.org/2000/svg" style="max-width:700px;width:100%">
  <defs>
    <marker id="ah" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto"><polygon points="0 0, 8 2.8, 0 5.6" fill="#64748b"/></marker>
    <marker id="ah-accent" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto"><polygon points="0 0, 8 2.8, 0 5.6" fill="#2563eb"/></marker>
    <filter id="sh" x="-5%" y="-5%" width="115%" height="115%"><feDropShadow dx="0" dy="2" stdDeviation="3" flood-color="#000" flood-opacity="0.1"/></filter>
  </defs>

  <!-- Outer: counter_test -->
  <rect x="10" y="10" width="680" height="500" rx="16" fill="#f8fafc" stroke="#94a3b8" stroke-width="2"/>
  <text x="350" y="38" text-anchor="middle" font-family="'Fira Code',monospace" font-size="15" font-weight="bold" fill="#1e293b">counter_test</text>

  <!-- counter_env -->
  <rect x="30" y="55" width="640" height="360" rx="14" fill="#f0fdf4" stroke="#10b981" stroke-width="2" opacity="0.5"/>
  <text x="350" y="78" text-anchor="middle" font-family="'Fira Code',monospace" font-size="14" font-weight="bold" fill="#10b981">counter_env</text>

  <!-- counter_agent -->
  <rect x="50" y="95" width="240" height="280" rx="12" fill="#eff6ff" stroke="#2563eb" stroke-width="2" filter="url(#sh)"/>
  <text x="170" y="118" text-anchor="middle" font-family="'Fira Code',monospace" font-size="13" font-weight="bold" fill="#2563eb">counter_agent</text>

  <!-- Sequencer -->
  <rect x="75" y="130" width="190" height="42" rx="8" fill="#ffffff" stroke="#2563eb" stroke-width="1.5"/>
  <text x="170" y="156" text-anchor="middle" font-family="'Fira Code',monospace" font-size="12" font-weight="bold" fill="#2563eb">Sequencer</text>

  <line x1="170" y1="172" x2="170" y2="192" stroke="#64748b" stroke-width="1.5" marker-end="url(#ah)"/>

  <!-- Driver -->
  <rect x="75" y="195" width="190" height="42" rx="8" fill="#ffffff" stroke="#2563eb" stroke-width="1.5"/>
  <text x="170" y="221" text-anchor="middle" font-family="'Fira Code',monospace" font-size="12" font-weight="bold" fill="#2563eb">Driver</text>

  <!-- Monitor -->
  <rect x="75" y="270" width="190" height="42" rx="8" fill="#ffffff" stroke="#2563eb" stroke-width="1.5"/>
  <text x="170" y="296" text-anchor="middle" font-family="'Fira Code',monospace" font-size="12" font-weight="bold" fill="#2563eb">Monitor</text>

  <!-- analysis_port label on arrow -->
  <line x1="265" y1="291" x2="345" y2="291" stroke="#2563eb" stroke-width="1.5" marker-end="url(#ah-accent)"/>
  <text x="305" y="283" text-anchor="middle" font-family="'Fira Code',monospace" font-size="9" fill="#2563eb">analysis_port</text>

  <!-- Scoreboard -->
  <rect x="370" y="110" width="270" height="100" rx="10" fill="#ecfdf5" stroke="#10b981" stroke-width="2" filter="url(#sh)"/>
  <text x="505" y="137" text-anchor="middle" font-family="'Fira Code',monospace" font-size="13" font-weight="bold" fill="#065f46">counter_scoreboard</text>
  <text x="505" y="158" text-anchor="middle" font-family="'Noto Sans KR',sans-serif" font-size="11" fill="#64748b">Reference Model</text>
  <text x="505" y="175" text-anchor="middle" font-family="'Fira Code',monospace" font-size="10" fill="#64748b">+ write()</text>
  <text x="505" y="192" text-anchor="middle" font-family="'Fira Code',monospace" font-size="10" fill="#64748b">+ report_phase()</text>

  <!-- Coverage Collector -->
  <rect x="370" y="270" width="270" height="100" rx="10" fill="#f5f3ff" stroke="#7c3aed" stroke-width="2" filter="url(#sh)"/>
  <text x="505" y="297" text-anchor="middle" font-family="'Fira Code',monospace" font-size="13" font-weight="bold" fill="#5b21b6">counter_coverage</text>
  <text x="505" y="318" text-anchor="middle" font-family="'Fira Code',monospace" font-size="11" fill="#64748b">covergroup</text>
  <text x="505" y="335" text-anchor="middle" font-family="'Fira Code',monospace" font-size="10" fill="#64748b">+ sample()</text>
  <text x="505" y="352" text-anchor="middle" font-family="'Fira Code',monospace" font-size="10" fill="#64748b">+ report_phase()</text>

  <!-- Monitor → Scoreboard -->
  <path d="M 345 280 Q 360 160, 368 155" fill="none" stroke="#10b981" stroke-width="2"/>
  <circle cx="370" cy="155" r="3" fill="#10b981"/>

  <!-- Monitor → Coverage -->
  <path d="M 345 300 Q 360 310, 368 310" fill="none" stroke="#7c3aed" stroke-width="2"/>
  <circle cx="370" cy="310" r="3" fill="#7c3aed"/>

  <!-- DUT -->
  <rect x="100" y="440" width="200" height="50" rx="10" fill="#fef3c7" stroke="#f59e0b" stroke-width="2" filter="url(#sh)"/>
  <text x="200" y="470" text-anchor="middle" font-family="'Fira Code',monospace" font-size="14" font-weight="bold" fill="#92400e">DUT</text>
  <text x="310" y="470" text-anchor="start" font-family="'Noto Sans KR',sans-serif" font-size="11" fill="#64748b">(4비트 카운터)</text>
</svg>
</div><h3 id="8-6-2-완성-코드-예제-8-3">8.6.2 완성 코드 — 예제 8-3</h3>
<p>이전 챕터에서 만든 코드에 스코어보드와 커버리지를 추가합니다. <strong>변경 부분만</strong> 표시합니다.</p>
<p><strong>① counter_seq_item (Ch.6에서 작성, 변경 없음)</strong></p>
<pre><code class="hljs language-systemverilog"><span class="hljs-keyword">class</span> counter_seq_item <span class="hljs-keyword">extends</span> uvm_sequence_item;
  `uvm_object_utils(counter_seq_item)

  <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span>       rst_n;
  <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span>       enable;
  <span class="hljs-keyword">logic</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>]    count;     <span class="hljs-comment">// DUT 출력 (관찰용)</span>

  <span class="hljs-keyword">constraint</span> c_default {
    rst_n <span class="hljs-keyword">dist</span> {<span class="hljs-number">0</span> := <span class="hljs-number">10</span>, <span class="hljs-number">1</span> := <span class="hljs-number">90</span>};
    enable <span class="hljs-keyword">dist</span> {<span class="hljs-number">0</span> := <span class="hljs-number">20</span>, <span class="hljs-number">1</span> := <span class="hljs-number">80</span>};
  }

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;counter_seq_item&quot;</span>);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">string</span> convert2string();
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;rst_n=%0b, en=%0b, count=%0d&quot;</span>, rst_n, enable, count);
  <span class="hljs-keyword">endfunction</span>
<span class="hljs-keyword">endclass</span>
</code></pre><p><strong>② counter_env — ⭐ 스코어보드 &amp; 커버리지 추가</strong></p>
<pre><code class="hljs language-systemverilog"><span class="hljs-keyword">class</span> counter_env <span class="hljs-keyword">extends</span> uvm_env;
  `uvm_component_utils(counter_env)

  counter_agent      agent;
  counter_scoreboard scoreboard;    <span class="hljs-comment">// ⭐ 새로 추가</span>
  counter_coverage   coverage_col;  <span class="hljs-comment">// ⭐ 새로 추가</span>

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);
    agent        = counter_agent::type_id::create(<span class="hljs-string">&quot;agent&quot;</span>, <span class="hljs-keyword">this</span>);
    scoreboard   = counter_scoreboard::type_id::create(<span class="hljs-string">&quot;scoreboard&quot;</span>, <span class="hljs-keyword">this</span>);
    coverage_col = counter_coverage::type_id::create(<span class="hljs-string">&quot;coverage_col&quot;</span>, <span class="hljs-keyword">this</span>);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-comment">// ⭐ connect_phase: 모니터 → 스코어보드 &amp; 커버리지 연결</span>
  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> connect_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.connect_phase</span>(phase);
    <span class="hljs-comment">// 모니터의 analysis port를 두 곳에 연결 (1:N 브로드캐스트!)</span>
    agent<span class="hljs-variable">.mon</span><span class="hljs-variable">.ap</span><span class="hljs-variable">.connect</span>(scoreboard<span class="hljs-variable">.ap_imp</span>);            <span class="hljs-comment">// → 스코어보드</span>
    agent<span class="hljs-variable">.mon</span><span class="hljs-variable">.ap</span><span class="hljs-variable">.connect</span>(coverage_col<span class="hljs-variable">.analysis_export</span>);  <span class="hljs-comment">// → 커버리지</span>
  <span class="hljs-keyword">endfunction</span>
<span class="hljs-keyword">endclass</span>
</code></pre><blockquote>
<p><strong>핵심</strong>: <code>connect_phase()</code>에서 모니터의 <code>ap</code>를 스코어보드와 커버리지 <strong>둘 다</strong>에 연결합니다. Ch.7에서 배운 analysis port의 1:N 브로드캐스트가 여기서 빛을 발합니다!</p>
</blockquote>
<p><strong>③ counter_test — run_phase 시퀀스 실행</strong></p>
<pre><code class="hljs language-systemverilog"><span class="hljs-keyword">class</span> counter_base_test <span class="hljs-keyword">extends</span> uvm_test;
  `uvm_component_utils(counter_base_test)

  counter_env env;

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);
    env = counter_env::type_id::create(<span class="hljs-string">&quot;env&quot;</span>, <span class="hljs-keyword">this</span>);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> run_phase(uvm_phase phase);
    counter_reset_seq  reset_seq;
    counter_count_seq  count_seq;

    phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);

    <span class="hljs-comment">// 리셋 시퀀스</span>
    reset_seq = counter_reset_seq::type_id::create(<span class="hljs-string">&quot;reset_seq&quot;</span>);
    reset_seq<span class="hljs-variable">.start</span>(env<span class="hljs-variable">.agent</span><span class="hljs-variable">.sqr</span>);

    <span class="hljs-comment">// 카운트 시퀀스</span>
    count_seq = counter_count_seq::type_id::create(<span class="hljs-string">&quot;count_seq&quot;</span>);
    count_seq<span class="hljs-variable">.num_transactions</span> = <span class="hljs-number">50</span>;
    count_seq<span class="hljs-variable">.start</span>(env<span class="hljs-variable">.agent</span><span class="hljs-variable">.sqr</span>);

    phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>
</code></pre><p><strong>④ 시퀀스들 — 다양한 시나리오</strong></p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// 리셋 시퀀스 — 초기화 확인</span>
<span class="hljs-keyword">class</span> counter_reset_seq <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(counter_seq_item)</span>;
  `uvm_object_utils(counter_reset_seq)

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;counter_reset_seq&quot;</span>);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();
    counter_seq_item item;

    <span class="hljs-comment">// 리셋 활성화 (3 클럭)</span>
    <span class="hljs-keyword">repeat</span> (<span class="hljs-number">3</span>) <span class="hljs-keyword">begin</span>
      item = counter_seq_item::type_id::create(<span class="hljs-string">&quot;item&quot;</span>);
      start_item(item);
      item<span class="hljs-variable">.rst_n</span>  = <span class="hljs-number">0</span>;
      item<span class="hljs-variable">.enable</span> = <span class="hljs-number">0</span>;
      finish_item(item);
    <span class="hljs-keyword">end</span>

    <span class="hljs-comment">// 리셋 해제</span>
    item = counter_seq_item::type_id::create(<span class="hljs-string">&quot;item&quot;</span>);
    start_item(item);
    item<span class="hljs-variable">.rst_n</span>  = <span class="hljs-number">1</span>;
    item<span class="hljs-variable">.enable</span> = <span class="hljs-number">0</span>;
    finish_item(item);
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>

<span class="hljs-comment">// 카운트 시퀀스 — 랜덤 자극</span>
<span class="hljs-keyword">class</span> counter_count_seq <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(counter_seq_item)</span>;
  `uvm_object_utils(counter_count_seq)

  <span class="hljs-keyword">int</span> num_transactions = <span class="hljs-number">20</span>;

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;counter_count_seq&quot;</span>);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();
    counter_seq_item item;

    <span class="hljs-keyword">repeat</span> (num_transactions) <span class="hljs-keyword">begin</span>
      item = counter_seq_item::type_id::create(<span class="hljs-string">&quot;item&quot;</span>);
      start_item(item);
      <span class="hljs-keyword">if</span> (!item<span class="hljs-variable">.randomize</span>())
        `uvm_fatal(get_type_name(), <span class="hljs-string">&quot;Randomization failed!&quot;</span>)
      item<span class="hljs-variable">.rst_n</span> = <span class="hljs-number">1</span>;    <span class="hljs-comment">// 리셋 해제 유지</span>
      finish_item(item);
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>

<span class="hljs-comment">// 오버플로우 시퀀스 — count=15 → 0 전이 확인</span>
<span class="hljs-keyword">class</span> counter_overflow_seq <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(counter_seq_item)</span>;
  `uvm_object_utils(counter_overflow_seq)

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name = <span class="hljs-string">&quot;counter_overflow_seq&quot;</span>);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();
    counter_seq_item item;

    <span class="hljs-comment">// 연속 enable로 16+α 클럭 구동 → 오버플로우 발생</span>
    <span class="hljs-keyword">repeat</span> (<span class="hljs-number">20</span>) <span class="hljs-keyword">begin</span>
      item = counter_seq_item::type_id::create(<span class="hljs-string">&quot;item&quot;</span>);
      start_item(item);
      item<span class="hljs-variable">.rst_n</span>  = <span class="hljs-number">1</span>;
      item<span class="hljs-variable">.enable</span> = <span class="hljs-number">1</span>;    <span class="hljs-comment">// 계속 카운트</span>
      finish_item(item);
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>
</code></pre><p><strong>⑤ top 모듈 (간략)</strong></p>
<pre><code class="hljs language-systemverilog"><span class="hljs-keyword">module</span> top;
  <span class="hljs-keyword">import</span> uvm_pkg::*;
  <span class="hljs-meta">`<span class="hljs-keyword">include</span> &quot;uvm_macros.svh&quot;</span>

  <span class="hljs-comment">// 시그널 및 인터페이스</span>
  <span class="hljs-keyword">logic</span> clk;
  counter_if cif(clk);

  <span class="hljs-comment">// DUT 인스턴스</span>
  counter_4bit dut (
    <span class="hljs-variable">.clk</span>    (clk),
    <span class="hljs-variable">.rst_n</span>  (cif<span class="hljs-variable">.rst_n</span>),
    <span class="hljs-variable">.enable</span> (cif<span class="hljs-variable">.enable</span>),
    <span class="hljs-variable">.count</span>  (cif<span class="hljs-variable">.count</span>)
  );

  <span class="hljs-comment">// 클럭 생성</span>
  <span class="hljs-keyword">initial</span> clk = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">always</span> #<span class="hljs-number">5</span> clk = ~clk;

  <span class="hljs-comment">// UVM 설정 및 시작</span>
  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span>
    uvm_config_db<span class="hljs-variable">#(virtual counter_if)::set(null, &quot;*&quot;, &quot;vif&quot;, cif)</span>;
    run_test(<span class="hljs-string">&quot;counter_base_test&quot;</span>);
  <span class="hljs-keyword">end</span>

  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span>
    <span class="hljs-built_in">$dumpfile</span>(<span class="hljs-string">&quot;counter_scoreboard.vcd&quot;</span>);
    <span class="hljs-built_in">$dumpvars</span>(<span class="hljs-number">0</span>, top);
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</code></pre><h3 id="8-6-3-실행-결과">8.6.3 실행 결과</h3>

<div class="svg-diagram">
<svg viewBox="0 0 600 200" xmlns="http://www.w3.org/2000/svg" style="max-width:600px;width:100%">
  
  <style>
    .diagram-box { fill: #ffffff; stroke: #334155; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-accent { fill: #eff6ff; stroke: #2563eb; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-highlight { fill: #fef3c7; stroke: #f59e0b; stroke-width: 2.5; rx: 10; ry: 10; }
    .diagram-box-dark { fill: #1e293b; stroke: #1e293b; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-run { fill: #fef3c7; stroke: #f59e0b; stroke-width: 3; rx: 10; ry: 10; }
    .diagram-box-green { fill: #ecfdf5; stroke: #10b981; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-purple { fill: #f5f3ff; stroke: #7c3aed; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-red { fill: #fef2f2; stroke: #ef4444; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-gray { fill: #f8fafc; stroke: #94a3b8; stroke-width: 1.5; rx: 8; ry: 8; }
    .diagram-text { font-family: 'Noto Sans KR', sans-serif; fill: #1e293b; }
    .diagram-text-white { font-family: 'Noto Sans KR', sans-serif; fill: #ffffff; }
    .diagram-text-accent { font-family: 'Noto Sans KR', sans-serif; fill: #2563eb; }
    .diagram-text-small { font-family: 'Noto Sans KR', sans-serif; fill: #64748b; font-size: 12px; }
    .diagram-text-code { font-family: 'Fira Code', 'JetBrains Mono', monospace; fill: #1e293b; }
    .diagram-arrow { fill: none; stroke: #64748b; stroke-width: 1.5; }
    .diagram-arrow-accent { fill: none; stroke: #2563eb; stroke-width: 1.5; }
    .diagram-line { stroke: #cbd5e1; stroke-width: 1.5; stroke-dasharray: 6,3; }
  </style>
  <defs>
    <marker id="arrowhead" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#64748b" />
    </marker>
    <marker id="arrowhead-accent" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#2563eb" />
    </marker>
    <marker id="arrowhead-dark" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#1e293b" />
    </marker>
    <marker id="arrowhead-orange" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#f59e0b" />
    </marker>
    <filter id="shadow" x="-5%" y="-5%" width="115%" height="115%">
      <feDropShadow dx="0" dy="2" stdDeviation="3" flood-color="#000" flood-opacity="0.1"/>
    </filter>
  </defs>

  <!-- Background -->
  <rect x="10" y="10" width="580" height="180" rx="10" ry="10" fill="#0f172a" filter="url(#shadow)"/>

  <!-- Title -->
  <text x="30" y="38" font-family="'Fira Code','JetBrains Mono',monospace" fill="#f59e0b" font-size="12" font-weight="bold">--- UVM Report Summary ---</text>
  <text x="30" y="58" font-family="'Fira Code','JetBrains Mono',monospace" fill="#94a3b8" font-size="11">** Report counts by severity</text>
  <text x="380" y="58" font-family="'Noto Sans KR',sans-serif" fill="#64748b" font-size="10">심각도별 메시지 개수</text>

  <!-- UVM_INFO -->
  <text x="30" y="84" font-family="'Fira Code','JetBrains Mono',monospace" fill="#4ade80" font-size="12">UVM_INFO :    4</text>
  <text x="380" y="84" font-family="'Noto Sans KR',sans-serif" fill="#64748b" font-size="10">INFO 메시지 4개</text>

  <!-- UVM_WARNING -->
  <text x="30" y="108" font-family="'Fira Code','JetBrains Mono',monospace" fill="#fbbf24" font-size="12">UVM_WARNING :    0</text>
  <text x="380" y="108" font-family="'Noto Sans KR',sans-serif" fill="#64748b" font-size="10">경고 없음</text>

  <!-- UVM_ERROR -->
  <rect x="22" y="118" width="340" height="22" rx="4" ry="4" fill="#052e16" stroke="#10b981" stroke-width="1" opacity="0.6"/>
  <text x="30" y="134" font-family="'Fira Code','JetBrains Mono',monospace" fill="#4ade80" font-size="12" font-weight="bold">UVM_ERROR :    0</text>
  <text x="380" y="134" font-family="'Noto Sans KR',sans-serif" fill="#10b981" font-size="11" font-weight="bold">에러 없음 ✓</text>

  <!-- UVM_FATAL -->
  <rect x="22" y="142" width="340" height="22" rx="4" ry="4" fill="#052e16" stroke="#10b981" stroke-width="1" opacity="0.6"/>
  <text x="30" y="158" font-family="'Fira Code','JetBrains Mono',monospace" fill="#4ade80" font-size="12" font-weight="bold">UVM_FATAL :    0</text>
  <text x="380" y="158" font-family="'Noto Sans KR',sans-serif" fill="#10b981" font-size="11" font-weight="bold">치명적 에러 없음 ✓</text>

  <!-- Note -->
  <text x="300" y="182" text-anchor="middle" font-family="'Noto Sans KR',sans-serif" fill="#94a3b8" font-size="10" font-style="italic">이 두 줄이 0이면 정상 종료!</text>
</svg>
</div><p><strong>결과 분석:</strong></p>
<ul>
<li><strong>스코어보드</strong>: 53개 트랜잭션 전부 PASS → DUT 동작 정확</li>
<li><strong>커버리지</strong>: 87.5% → 일부 조합 미달<ul>
<li><code>rst_n=0, enable=1</code> 조합 — 리셋 중 enable 시나리오 미테스트</li>
<li><code>enable=0, count=15</code> 조합 — 최대값에서 정지 시나리오 미테스트</li>
</ul>
</li>
<li><strong>다음 단계</strong>: Ch.9에서 타겟 시퀀스를 추가해 95% 이상 달성</li>
</ul>
<h3 id="8-6-4-ch-5-ch-8-진화-정리">8.6.4 Ch.5 → Ch.8 진화 정리</h3>
<table>
<thead>
<tr>
<th>항목</th>
<th>Ch.5</th>
<th>Ch.6</th>
<th>Ch.7</th>
<th><strong>Ch.8</strong></th>
</tr>
</thead>
<tbody><tr>
<td>시나리오</td>
<td>하드코딩</td>
<td>시퀀스 분리</td>
<td>시퀀스 (동일)</td>
<td>시퀀스 (동일)</td>
</tr>
<tr>
<td>타이밍</td>
<td><code>#1</code> 해킹</td>
<td><code>#1</code> 해킹</td>
<td>clocking block</td>
<td>clocking block</td>
</tr>
<tr>
<td>접근 제어</td>
<td>없음</td>
<td>없음</td>
<td>modport</td>
<td>modport</td>
</tr>
<tr>
<td>데이터 전달</td>
<td>직접 신호</td>
<td>seq_item_port</td>
<td>seq_item_port</td>
<td>seq_item_port</td>
</tr>
<tr>
<td>모니터 출력</td>
<td><code>uvm_info</code>만</td>
<td><code>uvm_info</code>만</td>
<td>analysis port</td>
<td>analysis port</td>
</tr>
<tr>
<td><strong>검증</strong></td>
<td><strong>눈으로 파형</strong></td>
<td><strong>눈으로 파형</strong></td>
<td><strong>눈으로 파형</strong></td>
<td><strong>⭐ 스코어보드 자동</strong></td>
</tr>
<tr>
<td><strong>커버리지</strong></td>
<td><strong>없음</strong></td>
<td><strong>없음</strong></td>
<td><strong>없음</strong></td>
<td><strong>⭐ 기능 커버리지</strong></td>
</tr>
</tbody></table>
<blockquote>
<p><strong>성취감 포인트</strong>: 이제 만든 테스트벤치는 팹리스에서 실제 사용하는 것과 <strong>동일한 수준</strong>입니다! 시나리오 자동화(시퀀스) + 타이밍 안정(clocking block) + 자동 검증(스코어보드) + 완전성 측정(커버리지)를 모두 갖췄습니다.</p>
</blockquote>
<hr>
<h2 id="8-7-체크포인트">8.7 체크포인트</h2>
<h3 id="셀프-체크">셀프 체크</h3>
<p><strong>1. 스코어보드의 역할은?</strong> (8.1-8.2)</p>
<details>
<summary>정답 확인</summary>
Reference Model로 예상 출력을 계산하고, 모니터가 관찰한 실제 DUT 출력과 자동으로 비교합니다. 불일치 시 `uvm_error`로 보고하고, `report_phase()`에서 최종 결과를 요약합니다.
</details>

<p><strong>2. uvm_analysis_imp와 uvm_subscriber의 차이는?</strong> (8.2-8.3)</p>
<details>
<summary>정답 확인</summary>
`uvm_analysis_imp`는 analysis port 수신 포트를 직접 선언합니다. 다중 포트가 필요할 때 사용합니다. `uvm_subscriber`는 analysis port가 내장되어 있어 `write()`만 구현하면 됩니다. 포트 1개로 충분한 경우 `uvm_subscriber`가 간편합니다.
</details>

<p><strong>3. 코드 커버리지와 기능 커버리지의 차이는?</strong> (8.4)</p>
<details>
<summary>정답 확인</summary>
코드 커버리지는 시뮬레이터가 자동으로 RTL 코드 실행 여부를 측정합니다 (line, branch, condition 등). 기능 커버리지는 검증 엔지니어가 `covergroup`으로 정의한 기능 시나리오의 검증 여부를 측정합니다. 코드 커버리지 100%여도 기능 검증이 부족할 수 있습니다.
</details>

<p><strong>4. cross coverage가 필요한 이유는?</strong> (8.4)</p>
<details>
<summary>정답 확인</summary>
개별 coverpoint가 100%여도 변수 간 조합이 테스트되지 않을 수 있습니다. 예: `rst_n=0` 테스트 완료, `enable=1` 테스트 완료이지만 `rst_n=0 && enable=1` 조합은 미테스트. cross coverage가 이런 빈틈을 잡아냅니다.
</details>

<p><strong>5. connect_phase()에서 모니터를 스코어보드와 커버리지에 동시 연결하는 방법은?</strong> (8.6)</p>
<details>
<summary>정답 확인</summary>
analysis port의 1:N 브로드캐스트를 활용합니다. `agent.mon.ap.connect(scoreboard.ap_imp)` 와 `agent.mon.ap.connect(coverage_col.analysis_export)`를 둘 다 호출하면, 모니터가 `write()`할 때 스코어보드와 커버리지 수집기 **모두**의 `write()`가 자동 호출됩니다.
</details>

<p><strong>6. 스코어보드의 report_phase()에서 트랜잭션 수가 0이면?</strong> (8.3)</p>
<details>
<summary>정답 확인</summary>
모니터-스코어보드 연결이 누락되었거나, 모니터가 `ap.write()`를 호출하지 않거나, Agent가 Passive 모드(모니터만 존재)인데 입력이 없는 경우입니다. `connect_phase()` 연결과 모니터 구현을 확인해야 합니다.
</details>

<h3 id="연습문제">연습문제</h3>
<p><strong>연습 8-1 (기본)</strong>: 예제 8-1의 스코어보드에 <strong>타임스탬프 로깅</strong>을 추가하세요. 각 비교 결과에 <code>$time</code> 값을 포함하여 언제 에러가 발생했는지 추적할 수 있도록 합니다.</p>
<details>
<summary>힌트</summary>
`$sformatf`의 포맷 문자열에 `$time`을 추가합니다: `$sformatf("[%0t] MISMATCH! ...", $time, ...)`
</details>

<p><strong>연습 8-2 (중급)</strong>: 예제 8-2의 커버리지 수집기에 <strong>transition coverage</strong>를 추가하세요. <code>count</code> 값이 <code>15 → 0</code>으로 전이되는 오버플로우 이벤트를 추적합니다.</p>
<details>
<summary>힌트</summary>
coverpoint에 `bins overflow = (15 => 0);` transition bin을 추가합니다. 이것은 순차적 값 전이를 추적합니다.
</details>

<p><strong>연습 8-3 (도전)</strong>: 멀티포트 스코어보드(8.3.3)를 실제로 구현하세요. 입력 모니터와 출력 모니터를 분리하고, 예측 큐를 사용하여 비동기적으로 비교합니다. <code>check_phase()</code>에서 큐에 남은 미비교 항목을 에러로 보고합니다.</p>
<details>
<summary>힌트</summary>
`uvm_analysis_imp_decl(_input)`, `uvm_analysis_imp_decl(_output)` 매크로를 사용합니다. `check_phase()`에서 `expected_queue.size() > 0`이면 `uvm_error`를 보고합니다.
</details>

<h3 id="다음-장-미리보기">다음 장 미리보기</h3>
<p>Chapter 9에서는 <strong>테스트 시나리오</strong>를 체계적으로 작성합니다. 이번 챕터에서 커버리지가 87.5%에 머물렀던 이유는 시나리오가 부족했기 때문입니다. 타겟 시퀀스, 랜덤 시퀀스, 에러 주입 시퀀스를 조합하여 커버리지 95% 이상을 달성하는 방법을 배웁니다.</p>

    <nav class="chapter-nav"><a href="chapter-07-final.html" class="nav-prev">
      <span class="nav-label">이전 챕터</span>
      <span class="nav-title">Ch.7 드라이버 & 모니터</span>
    </a><a href="chapter-09-final.html" class="nav-next">
      <span class="nav-label">다음 챕터</span>
      <span class="nav-title">Ch.9 테스트 시나리오</span>
    </a></nav>
  </div>

  <footer class="book-footer">
    <p>팹리스 검증 엔지니어가 되기 위한 UVM 완전정복</p>
    <p>Published by UVM Book Publisher Agent</p>
  </footer>

  <!-- Back to Top Button -->
  <button class="back-to-top" id="backToTop" onclick="window.scrollTo({top:0,behavior:'smooth'})">↑</button>

  <script>
    // Reading progress bar
    window.addEventListener('scroll', () => {
      const h = document.documentElement;
      const pct = (h.scrollTop / (h.scrollHeight - h.clientHeight)) * 100;
      document.getElementById('progressBar').style.width = pct + '%';
      document.getElementById('backToTop').classList.toggle('visible', h.scrollTop > 400);
    });

    // Language labels for code blocks
    document.querySelectorAll('pre').forEach(pre => {
      const code = pre.querySelector('code');
      if (code) {
        const cls = code.className || '';
        const m = cls.match(/language-(\w+)/);
        if (m) {
          const map = {
            systemverilog:'SystemVerilog', sv:'SystemVerilog', verilog:'Verilog',
            bash:'Bash', shell:'Shell', tcl:'TCL', makefile:'Makefile',
            python:'Python', javascript:'JavaScript', text:'Output'
          };
          pre.setAttribute('data-lang', map[m[1]] || m[1]);
        }
      }
    });

    // Smart labels for plain code blocks
    document.querySelectorAll('pre code:not([class*="language-"])').forEach(code => {
      const pre = code.parentElement;
      if (!pre.getAttribute('data-lang')) {
        const t = code.textContent || '';
        if (t.includes('UVM_INFO') || t.includes('UVM_WARNING')) {
          pre.setAttribute('data-lang', 'Simulation Output');
        } else if (t.includes('[채용') || t.includes('필수 자격')) {
          pre.setAttribute('data-lang', '');
        } else if (t.includes('Step') || t.includes('패널') || t.includes('편집기')) {
          pre.setAttribute('data-lang', 'Setup Guide');
        } else {
          pre.setAttribute('data-lang', 'Info');
        }
      }
    });

    // Smooth scroll for TOC links
    document.querySelectorAll('.toc a').forEach(a => {
      a.addEventListener('click', e => {
        e.preventDefault();
        const id = a.getAttribute('href').slice(1);
        const target = document.getElementById(id);
        if (target) target.scrollIntoView({ behavior: 'smooth', block: 'start' });
      });
    });
  </script>
</body>
</html>