<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chapter 15: 면접 준비 & 포트폴리오 | 팹리스 검증 엔지니어가 되기 위한 UVM 완전정복</title>
  <style>
    /* =============================================
       UVM Book Publisher - Stylesheet
       Generated by Publisher Agent
       ============================================= */

    @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;600;700&display=swap');

    :root {
      --bg: #ffffff;
      --text: #1a1a2e;
      --accent: #7c3aed;
      --accent-light: #7c3aed18;
      --code-bg: #1e1e2e;
      --code-text: #cdd6f4;
      --border: #e2e8f0;
      --blockquote-bg: #f0f9ff;
      --blockquote-border: #3b82f6;
      --table-header: #1e293b;
      --table-stripe: #f8fafc;
      --warning-bg: #fef3c7;
      --warning-border: #f59e0b;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: 'Noto Sans KR', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      line-height: 1.85;
      color: var(--text);
      background: var(--bg);
      font-size: 16px;
    }

    /* === Reading Progress Bar === */
    .progress-bar {
      position: fixed;
      top: 0;
      left: 0;
      width: 0%;
      height: 3px;
      background: linear-gradient(90deg, var(--accent), #7c3aedcc);
      z-index: 9999;
      transition: width 0.1s;
    }

    /* === Cover Header === */
    .cover-header {
      background: linear-gradient(135deg, #7c3aed08, #7c3aed15);
      border-bottom: 3px solid var(--accent);
      padding: 32px 24px 24px;
      text-align: center;
      margin-bottom: 0;
    }
    .cover-part {
      display: inline-block;
      background: var(--accent);
      color: white;
      padding: 4px 16px;
      border-radius: 20px;
      font-size: 0.85em;
      font-weight: 600;
      letter-spacing: 0.5px;
      margin-bottom: 12px;
    }
    .cover-chapter-num {
      font-size: 2em;
      font-weight: 300;
      color: var(--accent);
      letter-spacing: 2px;
      opacity: 0.6;
    }

    /* === Main Content === */
    .content {
      max-width: 860px;
      margin: 0 auto;
      padding: 32px 24px 60px;
    }

    /* === TOC === */
    .toc {
      background: #f8fafc;
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 20px 28px;
      margin: 24px 0 32px;
    }
    .toc-title {
      font-size: 1.1em;
      color: var(--accent);
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 2px solid var(--border);
    }
    .toc ul { list-style: none; padding: 0; }
    .toc li { margin: 6px 0; }
    .toc li a {
      color: var(--text);
      text-decoration: none;
      font-weight: 500;
      font-size: 0.95em;
      padding: 4px 8px;
      border-radius: 4px;
      display: inline-block;
      transition: background 0.15s;
    }
    .toc li a:hover {
      background: var(--accent-light);
      color: var(--accent);
    }
    .toc li.toc-sub { padding-left: 24px; }
    .toc li.toc-sub a {
      font-weight: 400;
      font-size: 0.9em;
      color: #475569;
    }

    /* === Headings === */
    h1 {
      font-size: 2em;
      border-bottom: 3px solid var(--accent);
      padding-bottom: 12px;
      margin: 40px 0 20px;
      color: var(--text);
    }
    h1:first-child { margin-top: 0; }
    h2 {
      font-size: 1.5em;
      color: var(--accent);
      margin: 40px 0 16px;
      padding-bottom: 8px;
      border-bottom: 2px solid var(--border);
      scroll-margin-top: 16px;
    }
    h3 {
      font-size: 1.25em;
      margin: 28px 0 12px;
      color: #334155;
      scroll-margin-top: 16px;
    }
    h4 { font-size: 1.05em; margin: 20px 0 8px; color: #475569; }
    p { margin: 12px 0; }
    a { color: var(--accent); text-decoration: none; }
    a:hover { text-decoration: underline; }
    hr { border: none; border-top: 2px solid var(--border); margin: 32px 0; }
    strong { color: #1e293b; }
    img { max-width: 100%; border-radius: 8px; margin: 16px 0; }

    /* === Code Blocks === */
    pre {
      position: relative;
      background: var(--code-bg);
      border-radius: 12px;
      padding: 0;
      margin: 20px 0;
      overflow: hidden;
      box-shadow: 0 4px 16px rgba(0,0,0,0.12), 0 1px 4px rgba(0,0,0,0.08);
      border: 1px solid #313244;
    }
    pre::before {
      content: attr(data-lang);
      display: block;
      background: #313244;
      color: #a6adc8;
      padding: 8px 16px;
      font-size: 0.8em;
      font-family: 'Fira Code','JetBrains Mono',monospace;
      letter-spacing: 0.5px;
      border-bottom: 1px solid #45475a;
    }
    pre code {
      display: block;
      padding: 16px 20px;
      overflow-x: auto;
      font-family: 'Fira Code','JetBrains Mono','Cascadia Code','D2Coding',monospace;
      font-size: 0.88em;
      line-height: 1.75;
      tab-size: 4;
      color: var(--code-text);
    }
    pre code::-webkit-scrollbar { height: 6px; }
    pre code::-webkit-scrollbar-track { background: #1e1e2e; }
    pre code::-webkit-scrollbar-thumb { background: #45475a; border-radius: 3px; }

    code:not(pre code) {
      background: #f1f5f9;
      color: #be185d;
      padding: 2px 7px;
      border-radius: 5px;
      font-family: 'Fira Code','JetBrains Mono','D2Coding',monospace;
      font-size: 0.86em;
      border: 1px solid #e2e8f0;
    }

    /* Highlight.js Catppuccin */
    .hljs { background: transparent; color: #cdd6f4; }
    .hljs-keyword { color: #cba6f7; font-weight: bold; }
    .hljs-type { color: #f9e2af; }
    .hljs-string { color: #a6e3a1; }
    .hljs-number { color: #fab387; }
    .hljs-comment { color: #6c7086; font-style: italic; }
    .hljs-function, .hljs-title { color: #89b4fa; }
    .hljs-built_in { color: #f38ba8; }
    .hljs-variable { color: #cdd6f4; }
    .hljs-attr { color: #89dceb; }
    .hljs-meta { color: #f5c2e7; }
    .hljs-literal { color: #fab387; }

    /* === SVG Diagrams === */
    .svg-diagram {
      margin: 24px 0;
      padding: 20px;
      background: #fafbfc;
      border: 1px solid var(--border);
      border-radius: 12px;
      text-align: center;
      overflow-x: auto;
    }
    .svg-diagram svg { display: inline-block; }

    /* === Blockquotes === */
    blockquote {
      background: var(--blockquote-bg);
      border-left: 4px solid var(--blockquote-border);
      padding: 16px 20px;
      margin: 16px 0;
      border-radius: 0 8px 8px 0;
    }
    blockquote p:first-child { margin-top: 0; }
    blockquote p:last-child { margin-bottom: 0; }
    blockquote:has(strong:first-child) {
      background: var(--warning-bg);
      border-left-color: var(--warning-border);
    }

    /* === Tables === */
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 1px 4px rgba(0,0,0,0.06);
      border: 1px solid var(--border);
      font-size: 0.95em;
    }
    thead th {
      background: var(--table-header);
      color: white;
      padding: 12px 16px;
      text-align: left;
      font-weight: 600;
      font-size: 0.9em;
    }
    tbody td {
      padding: 10px 16px;
      border-bottom: 1px solid var(--border);
    }
    tbody tr:nth-child(even) { background: var(--table-stripe); }
    tbody tr:hover { background: var(--accent-light); }

    /* === Lists === */
    ul, ol { padding-left: 28px; margin: 12px 0; }
    li { margin: 6px 0; }
    li > ul, li > ol { margin: 4px 0; }

    /* === Details/Summary === */
    details {
      background: #f8fafc;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px 16px;
      margin: 12px 0;
    }
    details summary {
      cursor: pointer;
      font-weight: 600;
      color: var(--accent);
    }
    details[open] summary { margin-bottom: 8px; }

    /* === Plain code blocks === */
    pre:has(code:not(.hljs)) {
      background: #fafbfc;
      border: 2px solid var(--border);
      box-shadow: none;
    }
    pre:has(code:not(.hljs))::before {
      background: #f1f5f9;
      color: #64748b;
      border-bottom-color: var(--border);
    }
    pre:has(code:not(.hljs)) code { color: #334155; }

    /* === Chapter Navigation === */
    .chapter-nav {
      display: flex;
      justify-content: space-between;
      gap: 16px;
      margin: 40px 0 20px;
      padding-top: 24px;
      border-top: 2px solid var(--border);
    }
    .chapter-nav a {
      display: flex;
      flex-direction: column;
      padding: 14px 20px;
      border: 1px solid var(--border);
      border-radius: 10px;
      text-decoration: none;
      transition: all 0.2s;
      min-width: 200px;
    }
    .chapter-nav a:hover {
      border-color: var(--accent);
      background: var(--accent-light);
      text-decoration: none;
    }
    .nav-prev { align-items: flex-start; }
    .nav-next { align-items: flex-end; }
    .nav-label {
      font-size: 0.8em;
      color: #94a3b8;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .nav-title { font-weight: 600; color: var(--accent); margin-top: 2px; }

    /* === Footer === */
    .book-footer {
      text-align: center;
      padding: 20px;
      margin-top: 40px;
      border-top: 1px solid var(--border);
      color: #94a3b8;
      font-size: 0.85em;
    }

    /* === Back to Top === */
    .back-to-top {
      position: fixed;
      bottom: 24px;
      right: 24px;
      width: 44px;
      height: 44px;
      background: var(--accent);
      color: white;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      font-size: 20px;
      display: none;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      transition: opacity 0.3s;
      z-index: 100;
    }
    .back-to-top.visible { display: flex; }

    /* === Print === */
    @media print {
      .progress-bar, .back-to-top, .chapter-nav, .toc { display: none !important; }
      body { font-size: 11pt; }
      .content { max-width: 100%; padding: 0; }
      .cover-header { break-after: page; }
      pre { box-shadow: none; border: 2px solid #ccc; break-inside: avoid; }
      .svg-diagram { break-inside: avoid; border: 1px solid #ccc; }
      table { break-inside: avoid; }
      h2, h3 { break-after: avoid; }
    }

    /* === Responsive === */
    @media (max-width: 640px) {
      .content { padding: 16px 12px 40px; font-size: 15px; }
      h1 { font-size: 1.5em; }
      h2 { font-size: 1.25em; }
      pre code { font-size: 0.8em; padding: 12px; }
      thead th, tbody td { padding: 8px 10px; font-size: 0.88em; }
      .svg-diagram { padding: 10px; }
      .toc { padding: 14px 18px; }
      .chapter-nav { flex-direction: column; }
      .chapter-nav a { min-width: unset; }
      .nav-next { align-items: flex-start; }
      .cover-chapter-num { font-size: 1.5em; }
    }
  </style>
</head>
<body>
  <!-- Reading Progress Bar -->
  <div class="progress-bar" id="progressBar"></div>

  
<header class="cover-header">
  <div class="cover-part" style="--part-color: #7c3aed">
    <span class="cover-part-label">Part 3: 완성하기</span>
  </div>
  <div class="cover-chapter-num">Chapter 15</div>
</header>

  <div class="content">
    <nav class="toc">
<h2 class="toc-title">목차</h2>
<ul>
<li><a href="#15-1-팹리스-검증-엔지니어-취업-로드맵">15.1 팹리스 검증 엔지니어 취업 로드맵</a></li>
  <li class="toc-sub"><a href="#15-1-1-팹리스-검증팀의-하루">15.1.1 팹리스 검증팀의 하루</a></li>
  <li class="toc-sub"><a href="#15-1-2-채용-프로세스-이해하기">15.1.2 채용 프로세스 이해하기</a></li>
  <li class="toc-sub"><a href="#15-1-3-신입-vs-경력의-기대치-차이">15.1.3 신입 vs 경력의 기대치 차이</a></li>
<li><a href="#15-2-uvm-면접-빈출-질문-top-30">15.2 UVM 면접 빈출 질문 Top 30</a></li>
  <li class="toc-sub"><a href="#15-2-1-기초-개념-10문항">15.2.1 기초 개념 (10문항)</a></li>
  <li class="toc-sub"><a href="#15-2-2-컴포넌트-amp-아키텍처-10문항">15.2.2 컴포넌트 &amp; 아키텍처 (10문항)</a></li>
  <li class="toc-sub"><a href="#15-2-3-고급-주제-amp-실무-10문항">15.2.3 고급 주제 &amp; 실무 (10문항)</a></li>
<li><a href="#15-3-코드-리뷰-면접-대비">15.3 코드 리뷰 면접 대비</a></li>
  <li class="toc-sub"><a href="#15-3-1-quot-이-코드의-문제를-찾아라-quot-유형">15.3.1 &quot;이 코드의 문제를 찾아라&quot; 유형</a></li>
  <li class="toc-sub"><a href="#15-3-2-quot-이-환경을-개선해라-quot-유형">15.3.2 &quot;이 환경을 개선해라&quot; 유형</a></li>
  <li class="toc-sub"><a href="#15-3-3-라이브-코딩-팁">15.3.3 라이브 코딩 팁</a></li>
<li><a href="#15-4-포트폴리오-프로젝트-구성">15.4 포트폴리오 프로젝트 구성</a></li>
  <li class="toc-sub"><a href="#15-4-1-ch-11-14-apb-프로젝트를-포트폴리오로">15.4.1 Ch.11~14 APB 프로젝트를 포트폴리오로</a></li>
  <li class="toc-sub"><a href="#15-4-2-github-저장소-구조와-readme">15.4.2 GitHub 저장소 구조와 README</a></li>
  <li class="toc-sub"><a href="#15-4-3-문서화와-시연-가이드">15.4.3 문서화와 시연 가이드</a></li>
<li><a href="#15-5-이력서-amp-자기소개서-전략">15.5 이력서 &amp; 자기소개서 전략</a></li>
  <li class="toc-sub"><a href="#15-5-1-검증-엔지니어-이력서-작성법">15.5.1 검증 엔지니어 이력서 작성법</a></li>
  <li class="toc-sub"><a href="#15-5-2-기술-키워드와-성과-표현">15.5.2 기술 키워드와 성과 표현</a></li>
  <li class="toc-sub"><a href="#15-5-3-자기소개서에서-uvm-경험-어필">15.5.3 자기소개서에서 UVM 경험 어필</a></li>
<li><a href="#15-6-실전-면접-시뮬레이션">15.6 실전 면접 시뮬레이션</a></li>
  <li class="toc-sub"><a href="#15-6-1-1차-기술-면접-시뮬레이션">15.6.1 1차 기술 면접 시뮬레이션</a></li>
  <li class="toc-sub"><a href="#15-6-2-2차-심층-면접-시뮬레이션">15.6.2 2차 심층 면접 시뮬레이션</a></li>
  <li class="toc-sub"><a href="#15-6-3-면접-후-팔로업">15.6.3 면접 후 팔로업</a></li>
<li><a href="#15-7-체크포인트">15.7 체크포인트</a></li>
  <li class="toc-sub"><a href="#15-7-1-셀프-체크">15.7.1 셀프 체크</a></li>
  <li class="toc-sub"><a href="#15-7-2-연습문제">15.7.2 연습문제</a></li>
  <li class="toc-sub"><a href="#15-7-3-이-챕터에서-배운-것">15.7.3 이 챕터에서 배운 것</a></li>
  <li class="toc-sub"><a href="#15-7-4-전체-책-마무리-ch-1-15-학습-로드맵">15.7.4 전체 책 마무리 — Ch.1~15 학습 로드맵</a></li>
</ul>
</nav>
    <h1>Chapter 15: 면접 준비 &amp; 포트폴리오</h1>
<blockquote>
<p><strong>학습 목표</strong></p>
<ul>
<li><strong>UVM 면접 빈출 질문 30선</strong>을 이해하고 모범 답안을 준비할 수 있다</li>
<li><strong>코드 리뷰 면접</strong>에서 UVM 코드의 문제를 찾고 개선안을 제시할 수 있다</li>
<li><strong>포트폴리오 프로젝트</strong>를 Ch.11~14 APB 검증 환경을 기반으로 구성할 수 있다</li>
<li><strong>이력서와 GitHub</strong>에 검증 엔지니어 역량을 효과적으로 보여줄 수 있다</li>
<li><strong>팹리스 검증 엔지니어</strong> 취업 프로세스와 면접 전략을 이해할 수 있다</li>
</ul>
</blockquote>
<blockquote>
<p><strong>선수 지식</strong>: 이 챕터는 Ch.1<del>14 전체를 참조합니다. 특히 Ch.4(Factory/Phase), Ch.6</del>7(Sequence/Driver/Monitor), Ch.8(Scoreboard), Ch.11~14(APB 검증 환경)가 면접과 포트폴리오의 핵심 소재입니다.</p>
</blockquote>
<hr>
<h2 id="15-1-팹리스-검증-엔지니어-취업-로드맵">15.1 팹리스 검증 엔지니어 취업 로드맵</h2>
<blockquote>
<p><strong>이 절의 목표</strong>: 팹리스 검증 엔지니어가 실제로 어떤 일을 하는지, 채용 프로세스는 어떻게 진행되는지 이해합니다.</p>
</blockquote>
<h3 id="15-1-1-팹리스-검증팀의-하루">15.1.1 팹리스 검증팀의 하루</h3>
<p>Ch.1~14에서 UVM 기술을 배웠습니다. 그런데 <strong>실제로 출근하면 뭘 할까요?</strong> 팹리스 검증 엔지니어의 전형적인 하루를 봅시다:</p>
<table>
<thead>
<tr>
<th>시간</th>
<th>활동</th>
<th>UVM과의 연결</th>
</tr>
</thead>
<tbody><tr>
<td>09:00</td>
<td>출근, 밤새 돌린 리그레션 결과 확인</td>
<td>수백 개 테스트 자동 실행 결과 분석</td>
</tr>
<tr>
<td>09:30</td>
<td>팀 스탠드업 미팅</td>
<td>커버리지 진행률, 발견된 버그 공유</td>
</tr>
<tr>
<td>10:00</td>
<td>커버리지 홀(hole) 분석</td>
<td>Ch.14에서 배운 커버리지 리포트 분석</td>
</tr>
<tr>
<td>11:00</td>
<td>새 테스트 시나리오 작성</td>
<td>Ch.6 시퀀스, Ch.13 가상 시퀀스</td>
</tr>
<tr>
<td>13:00</td>
<td>발견된 버그 분석 및 리포트</td>
<td>Ch.10 디버깅, 파형 분석</td>
</tr>
<tr>
<td>14:00</td>
<td>설계팀과 버그 논의 미팅</td>
<td>프로토콜 이해, 어서션 결과 공유</td>
</tr>
<tr>
<td>15:00</td>
<td>새 IP 블록의 테스트벤치 구축</td>
<td>Ch.5~8 에이전트, 스코어보드</td>
</tr>
<tr>
<td>16:00</td>
<td>코드 리뷰 (동료 코드 검토)</td>
<td>이 챕터 15.3에서 연습!</td>
</tr>
<tr>
<td>17:00</td>
<td>리그레션 설정 후 퇴근</td>
<td>밤새 자동 실행될 테스트 세트</td>
</tr>
</tbody></table>
<blockquote>
<p>💡 <strong>핵심</strong>: 검증 엔지니어의 업무는 크게 <strong>&quot;테스트 작성&quot;</strong>, <strong>&quot;커버리지 분석&quot;</strong>, <strong>&quot;버그 디버깅&quot;</strong> 세 가지입니다. Ch.1~14에서 배운 것이 바로 이 업무를 하기 위한 기술입니다.</p>
</blockquote>
<p><strong>검증 엔지니어가 되면 좋은 점:</strong></p>
<table>
<thead>
<tr>
<th>장점</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td><strong>높은 수요</strong></td>
<td>설계 대비 검증 인력 비율 2:1~3:1 — 항상 인력 부족</td>
</tr>
<tr>
<td><strong>체계적 사고력</strong></td>
<td>&quot;어떻게 하면 버그를 찾을까?&quot;라는 창의적 문제 해결</td>
</tr>
<tr>
<td><strong>설계 이해</strong></td>
<td>하드웨어 전체를 이해하게 됨 (검증이 곧 설계 이해)</td>
</tr>
<tr>
<td><strong>글로벌 기회</strong></td>
<td>UVM은 전 세계 표준 — 해외 취업 가능성</td>
</tr>
</tbody></table>
<h3 id="15-1-2-채용-프로세스-이해하기">15.1.2 채용 프로세스 이해하기</h3>
<p>팹리스 검증 엔지니어 채용은 보통 다음 과정을 거칩니다:</p>

<div class="svg-diagram">
<svg viewBox="0 0 820 200" xmlns="http://www.w3.org/2000/svg" style="max-width:820px;width:100%">
  
  <style>
    .diagram-box { fill: #ffffff; stroke: #334155; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-accent { fill: #eff6ff; stroke: #2563eb; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-highlight { fill: #fef3c7; stroke: #f59e0b; stroke-width: 2.5; rx: 10; ry: 10; }
    .diagram-box-dark { fill: #1e293b; stroke: #1e293b; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-run { fill: #fef3c7; stroke: #f59e0b; stroke-width: 3; rx: 10; ry: 10; }
    .diagram-box-green { fill: #ecfdf5; stroke: #10b981; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-purple { fill: #f5f3ff; stroke: #7c3aed; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-red { fill: #fef2f2; stroke: #ef4444; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-gray { fill: #f8fafc; stroke: #94a3b8; stroke-width: 1.5; rx: 8; ry: 8; }
    .diagram-text { font-family: 'Noto Sans KR', sans-serif; fill: #1e293b; }
    .diagram-text-white { font-family: 'Noto Sans KR', sans-serif; fill: #ffffff; }
    .diagram-text-accent { font-family: 'Noto Sans KR', sans-serif; fill: #2563eb; }
    .diagram-text-small { font-family: 'Noto Sans KR', sans-serif; fill: #64748b; font-size: 12px; }
    .diagram-text-code { font-family: 'Fira Code', 'JetBrains Mono', monospace; fill: #1e293b; }
    .diagram-arrow { fill: none; stroke: #64748b; stroke-width: 1.5; }
    .diagram-arrow-accent { fill: none; stroke: #2563eb; stroke-width: 1.5; }
    .diagram-line { stroke: #cbd5e1; stroke-width: 1.5; stroke-dasharray: 6,3; }
  </style>
  <defs>
    <marker id="arrowhead" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#64748b" />
    </marker>
    <marker id="arrowhead-accent" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#2563eb" />
    </marker>
    <marker id="arrowhead-dark" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#1e293b" />
    </marker>
    <marker id="arrowhead-orange" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#f59e0b" />
    </marker>
    <filter id="shadow" x="-5%" y="-5%" width="115%" height="115%">
      <feDropShadow dx="0" dy="2" stdDeviation="3" flood-color="#000" flood-opacity="0.1"/>
    </filter>
  </defs>

  <defs>
    <marker id="arrowhead-sm" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#2563eb"/>
    </marker>
    <linearGradient id="progressGrad" x1="0" y1="0" x2="1" y2="0">
      <stop offset="0%" stop-color="#2563eb"/>
      <stop offset="25%" stop-color="#7c3aed"/>
      <stop offset="50%" stop-color="#f59e0b"/>
      <stop offset="75%" stop-color="#10b981"/>
      <stop offset="100%" stop-color="#334155"/>
    </linearGradient>
  </defs>
  <!-- Title -->
  <text x="410" y="22" text-anchor="middle" class="diagram-text" font-size="15" font-weight="bold">팹리스 검증 엔지니어 채용 프로세스</text>

  <!-- Step 1: 서류 전형 -->
  <rect x="10" y="40" width="130" height="90" class="diagram-box-accent" filter="url(#shadow)"/>
  <rect x="10" y="40" width="130" height="28" rx="10" ry="10" fill="#2563eb" stroke="#2563eb"/>
  <rect x="10" y="60" width="130" height="4" fill="#2563eb"/>
  <text x="75" y="60" text-anchor="middle" class="diagram-text-white" font-size="13" font-weight="bold">1. 서류 전형</text>
  <text x="75" y="85" text-anchor="middle" class="diagram-text" font-size="11">이력서</text>
  <text x="75" y="102" text-anchor="middle" class="diagram-text" font-size="11">포트폴리오</text>
  <text x="75" y="120" text-anchor="middle" class="diagram-text-small" font-size="10" font-style="italic">(15.5절)</text>

  <!-- Arrow 1→2 -->
  <line x1="140" y1="85" x2="172" y2="85" class="diagram-arrow-accent" marker-end="url(#arrowhead-sm)" stroke-width="1.5"/>

  <!-- Step 2: 코딩 테스트 -->
  <rect x="178" y="40" width="130" height="90" class="diagram-box-purple" filter="url(#shadow)"/>
  <rect x="178" y="40" width="130" height="28" rx="10" ry="10" fill="#7c3aed" stroke="#7c3aed"/>
  <rect x="178" y="60" width="130" height="4" fill="#7c3aed"/>
  <text x="243" y="60" text-anchor="middle" class="diagram-text-white" font-size="13" font-weight="bold">2. 코딩 테스트</text>
  <text x="243" y="85" text-anchor="middle" class="diagram-text" font-size="11">SV/UVM</text>
  <text x="243" y="102" text-anchor="middle" class="diagram-text" font-size="11">온라인</text>
  <text x="243" y="120" text-anchor="middle" class="diagram-text-small" font-size="10" font-style="italic">(15.3절)</text>

  <!-- Arrow 2→3 -->
  <line x1="308" y1="85" x2="340" y2="85" class="diagram-arrow-accent" marker-end="url(#arrowhead-sm)" stroke-width="1.5"/>

  <!-- Step 3: 1차 기술면접 -->
  <rect x="346" y="40" width="130" height="90" class="diagram-box-highlight" filter="url(#shadow)"/>
  <rect x="346" y="40" width="130" height="28" rx="10" ry="10" fill="#f59e0b" stroke="#f59e0b"/>
  <rect x="346" y="60" width="130" height="4" fill="#f59e0b"/>
  <text x="411" y="60" text-anchor="middle" class="diagram-text-white" font-size="13" font-weight="bold">3. 1차 기술면접</text>
  <text x="411" y="85" text-anchor="middle" class="diagram-text" font-size="11">UVM 개념</text>
  <text x="411" y="102" text-anchor="middle" class="diagram-text" font-size="11">코드 리뷰</text>
  <text x="411" y="120" text-anchor="middle" class="diagram-text-small" font-size="10" font-style="italic">(15.2절)</text>

  <!-- Arrow 3→4 -->
  <line x1="476" y1="85" x2="508" y2="85" class="diagram-arrow-accent" marker-end="url(#arrowhead-sm)" stroke-width="1.5"/>

  <!-- Step 4: 2차 심층면접 -->
  <rect x="514" y="40" width="130" height="90" class="diagram-box-green" filter="url(#shadow)"/>
  <rect x="514" y="40" width="130" height="28" rx="10" ry="10" fill="#10b981" stroke="#10b981"/>
  <rect x="514" y="60" width="130" height="4" fill="#10b981"/>
  <text x="579" y="60" text-anchor="middle" class="diagram-text-white" font-size="13" font-weight="bold">4. 2차 심층면접</text>
  <text x="579" y="85" text-anchor="middle" class="diagram-text" font-size="11">설계 문제</text>
  <text x="579" y="102" text-anchor="middle" class="diagram-text" font-size="11">팀 핏</text>
  <text x="579" y="120" text-anchor="middle" class="diagram-text-small" font-size="10" font-style="italic">(15.6절)</text>

  <!-- Arrow 4→5 -->
  <line x1="644" y1="85" x2="676" y2="85" class="diagram-arrow-accent" marker-end="url(#arrowhead-sm)" stroke-width="1.5"/>

  <!-- Step 5: 처우 협의 -->
  <rect x="682" y="40" width="130" height="90" class="diagram-box" filter="url(#shadow)"/>
  <rect x="682" y="40" width="130" height="28" rx="10" ry="10" fill="#334155" stroke="#334155"/>
  <rect x="682" y="60" width="130" height="4" fill="#334155"/>
  <text x="747" y="60" text-anchor="middle" class="diagram-text-white" font-size="13" font-weight="bold">5. 처우 협의</text>
  <text x="747" y="85" text-anchor="middle" class="diagram-text" font-size="11">연봉</text>
  <text x="747" y="102" text-anchor="middle" class="diagram-text" font-size="11">입사일</text>

  <!-- Bottom progress bar -->
  <rect x="10" y="150" width="800" height="6" rx="3" fill="#e2e8f0"/>
  <rect x="10" y="150" width="800" height="6" rx="3" fill="url(#progressGrad)"/>
  <text x="410" y="175" text-anchor="middle" class="diagram-text-small" font-size="11">이 책의 각 절이 각 단계를 대비합니다</text>
</svg>
</div><p><strong>각 단계에서 평가하는 것:</strong></p>
<table>
<thead>
<tr>
<th>단계</th>
<th>평가 항목</th>
<th>이 책에서 대비하는 곳</th>
</tr>
</thead>
<tbody><tr>
<td>서류 전형</td>
<td>UVM/SV 키워드, 프로젝트 경험</td>
<td>15.5 이력서 전략</td>
</tr>
<tr>
<td>코딩 테스트</td>
<td>SystemVerilog 코딩 능력</td>
<td>15.3 코드 리뷰 면접</td>
</tr>
<tr>
<td>1차 기술 면접</td>
<td>UVM 개념 이해도, 코드 리뷰</td>
<td>15.2 빈출 질문 + 15.3</td>
</tr>
<tr>
<td>2차 심층 면접</td>
<td>설계 문제 해결, 팀 적합성</td>
<td>15.6 면접 시뮬레이션</td>
</tr>
<tr>
<td>처우 협의</td>
<td>연봉, 복지, 성장 가능성</td>
<td>15.6.3 팔로업</td>
</tr>
</tbody></table>
<h3 id="15-1-3-신입-vs-경력의-기대치-차이">15.1.3 신입 vs 경력의 기대치 차이</h3>
<p>면접에서 신입에게 기대하는 것과 경력에게 기대하는 것은 다릅니다:</p>
<table>
<thead>
<tr>
<th>항목</th>
<th>신입 (0~2년)</th>
<th>경력 (3년+)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>UVM 지식</strong></td>
<td>기본 컴포넌트 이해, 간단한 TB 구축</td>
<td>복잡한 환경 설계, 성능 최적화</td>
</tr>
<tr>
<td><strong>코딩</strong></td>
<td>문법 정확성, 기본 패턴</td>
<td>효율적 코드, 재사용 가능한 설계</td>
</tr>
<tr>
<td><strong>디버깅</strong></td>
<td>에러 메시지 읽기, 기본 파형 분석</td>
<td>복잡한 타이밍 이슈, 시스템 레벨</td>
</tr>
<tr>
<td><strong>커뮤니케이션</strong></td>
<td>질문할 줄 아는 능력</td>
<td>기술 문서 작성, 설계팀 협업</td>
</tr>
<tr>
<td><strong>기대하지 않는 것</strong></td>
<td>완벽한 UVM 지식</td>
<td>—</td>
</tr>
</tbody></table>
<blockquote>
<p>💡 <strong>안심하세요</strong>: 신입에게는 **&quot;배울 수 있는 기반이 있는가?&quot;**를 봅니다. 이 책을 완독하고 포트폴리오를 만들었다면, 그 기반은 충분합니다.</p>
</blockquote>
<hr>
<h2 id="15-2-uvm-면접-빈출-질문-top-30">15.2 UVM 면접 빈출 질문 Top 30</h2>
<blockquote>
<p><strong>이 절의 목표</strong>: 면접에서 자주 나오는 UVM 질문 30개를 카테고리별로 정리하고, 모범 답안을 연습합니다.</p>
</blockquote>
<p>면접 답변의 황금 구조는 **&quot;핵심 → 이유 → 예시&quot;**입니다:</p>
<pre><code>답변 구조: &quot;~는 ~입니다. 왜냐하면 ~이기 때문입니다. 예를 들어 ~&quot;
</code></pre><p>면접 질문은 세 가지 카테고리로 나뉩니다:</p>

<div class="svg-diagram">
<svg viewBox="0 0 780 320" xmlns="http://www.w3.org/2000/svg" style="max-width:780px;width:100%">
  
  <style>
    .diagram-box { fill: #ffffff; stroke: #334155; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-accent { fill: #eff6ff; stroke: #2563eb; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-highlight { fill: #fef3c7; stroke: #f59e0b; stroke-width: 2.5; rx: 10; ry: 10; }
    .diagram-box-dark { fill: #1e293b; stroke: #1e293b; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-run { fill: #fef3c7; stroke: #f59e0b; stroke-width: 3; rx: 10; ry: 10; }
    .diagram-box-green { fill: #ecfdf5; stroke: #10b981; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-purple { fill: #f5f3ff; stroke: #7c3aed; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-red { fill: #fef2f2; stroke: #ef4444; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-gray { fill: #f8fafc; stroke: #94a3b8; stroke-width: 1.5; rx: 8; ry: 8; }
    .diagram-text { font-family: 'Noto Sans KR', sans-serif; fill: #1e293b; }
    .diagram-text-white { font-family: 'Noto Sans KR', sans-serif; fill: #ffffff; }
    .diagram-text-accent { font-family: 'Noto Sans KR', sans-serif; fill: #2563eb; }
    .diagram-text-small { font-family: 'Noto Sans KR', sans-serif; fill: #64748b; font-size: 12px; }
    .diagram-text-code { font-family: 'Fira Code', 'JetBrains Mono', monospace; fill: #1e293b; }
    .diagram-arrow { fill: none; stroke: #64748b; stroke-width: 1.5; }
    .diagram-arrow-accent { fill: none; stroke: #2563eb; stroke-width: 1.5; }
    .diagram-line { stroke: #cbd5e1; stroke-width: 1.5; stroke-dasharray: 6,3; }
  </style>
  <defs>
    <marker id="arrowhead" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#64748b" />
    </marker>
    <marker id="arrowhead-accent" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#2563eb" />
    </marker>
    <marker id="arrowhead-dark" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#1e293b" />
    </marker>
    <marker id="arrowhead-orange" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#f59e0b" />
    </marker>
    <filter id="shadow" x="-5%" y="-5%" width="115%" height="115%">
      <feDropShadow dx="0" dy="2" stdDeviation="3" flood-color="#000" flood-opacity="0.1"/>
    </filter>
  </defs>

  <!-- Title bar -->
  <rect x="10" y="10" width="760" height="36" rx="10" ry="10" fill="#1e293b"/>
  <text x="390" y="34" text-anchor="middle" class="diagram-text-white" font-size="15" font-weight="bold">UVM 면접 질문 30선 — 카테고리 맵</text>

  <!-- Category 1: 기초 -->
  <rect x="20" y="60" width="240" height="210" class="diagram-box-accent" filter="url(#shadow)"/>
  <rect x="20" y="60" width="240" height="30" rx="10" ry="10" fill="#2563eb" stroke="#2563eb"/>
  <rect x="20" y="82" width="240" height="4" fill="#2563eb"/>
  <text x="140" y="82" text-anchor="middle" class="diagram-text-white" font-size="13" font-weight="bold">기초 개념 (Q1~Q10)</text>
  <text x="40" y="110" class="diagram-text" font-size="11">Q1. UVM 정의</text>
  <text x="40" y="128" class="diagram-text" font-size="11">Q2. Object vs Component</text>
  <text x="40" y="146" class="diagram-text" font-size="11">Q3. Factory Pattern</text>
  <text x="40" y="164" class="diagram-text" font-size="11">Q4. UVM Phase</text>
  <text x="40" y="182" class="diagram-text" font-size="11">Q5. TLM</text>
  <text x="40" y="200" class="diagram-text" font-size="11">Q6. Sequence/Sequencer</text>
  <text x="40" y="218" class="diagram-text" font-size="11">Q7. Virtual Interface</text>
  <text x="40" y="236" class="diagram-text-small" font-size="10">Q8~Q10: config_db, Objection, seq_item</text>

  <!-- Category 2: 컴포넌트 -->
  <rect x="275" y="60" width="240" height="210" class="diagram-box-green" filter="url(#shadow)"/>
  <rect x="275" y="60" width="240" height="30" rx="10" ry="10" fill="#10b981" stroke="#10b981"/>
  <rect x="275" y="82" width="240" height="4" fill="#10b981"/>
  <text x="395" y="82" text-anchor="middle" class="diagram-text-white" font-size="13" font-weight="bold">컴포넌트 & 아키텍처 (Q11~Q20)</text>
  <text x="295" y="110" class="diagram-text" font-size="11">Q11. Agent 구조</text>
  <text x="295" y="128" class="diagram-text" font-size="11">Q12. Driver vs Monitor</text>
  <text x="295" y="146" class="diagram-text" font-size="11">Q13. Scoreboard</text>
  <text x="295" y="164" class="diagram-text" font-size="11">Q14. Analysis Port</text>
  <text x="295" y="182" class="diagram-text" font-size="11">Q15. Environment</text>
  <text x="295" y="200" class="diagram-text" font-size="11">Q16. RAL</text>
  <text x="295" y="218" class="diagram-text" font-size="11">Q17. Virtual Sequence</text>
  <text x="295" y="236" class="diagram-text-small" font-size="10">Q18~Q20: Coverage, Assertion, Callback</text>

  <!-- Category 3: 고급 -->
  <rect x="530" y="60" width="240" height="210" class="diagram-box-purple" filter="url(#shadow)"/>
  <rect x="530" y="60" width="240" height="30" rx="10" ry="10" fill="#7c3aed" stroke="#7c3aed"/>
  <rect x="530" y="82" width="240" height="4" fill="#7c3aed"/>
  <text x="650" y="82" text-anchor="middle" class="diagram-text-white" font-size="13" font-weight="bold">고급 & 실무 (Q21~Q30)</text>
  <text x="550" y="110" class="diagram-text" font-size="11">Q21. Constrained Random</text>
  <text x="550" y="128" class="diagram-text" font-size="11">Q22. Coverage Closure</text>
  <text x="550" y="146" class="diagram-text" font-size="11">Q23. Reset 처리</text>
  <text x="550" y="164" class="diagram-text" font-size="11">Q24. VIP 활용</text>
  <text x="550" y="182" class="diagram-text" font-size="11">Q25. 성능 최적화</text>
  <text x="550" y="200" class="diagram-text" font-size="11">Q26. field macro 장단점</text>
  <text x="550" y="218" class="diagram-text" font-size="11">Q27. end_of_elaboration</text>
  <text x="550" y="236" class="diagram-text-small" font-size="10">Q28~Q30: Multi-agent, 에러 주입, TB 구축</text>

  <!-- Bottom bar: 신입 vs 경력 -->
  <rect x="20" y="282" width="495" height="26" rx="8" fill="#dbeafe" stroke="#2563eb" stroke-width="1.5"/>
  <text x="267" y="300" text-anchor="middle" class="diagram-text-accent" font-size="12" font-weight="600">신입: 기초 필수 + 컴포넌트 대부분</text>
  <rect x="530" y="282" width="240" height="26" rx="8" fill="#f5f3ff" stroke="#7c3aed" stroke-width="1.5"/>
  <text x="650" y="300" text-anchor="middle" font-family="'Noto Sans KR',sans-serif" fill="#7c3aed" font-size="12" font-weight="600">경력: 전 카테고리</text>
</svg>
</div><h3 id="15-2-1-기초-개념-10문항">15.2.1 기초 개념 (10문항)</h3>
<p>이 카테고리는 <strong>모든 면접에서 반드시</strong> 나옵니다. 정확하게 답하지 못하면 탈락입니다.</p>
<p><strong>Q1. UVM이란 무엇이며, 왜 사용하는가?</strong></p>
<details>
<summary>모범 답안 보기</summary>

<p>UVM(Universal Verification Methodology)은 SystemVerilog 기반의 <strong>검증 방법론 라이브러리</strong>입니다. 왜 사용하는가 하면, <strong>재사용 가능한 검증 환경</strong>을 표준화된 방식으로 구축할 수 있기 때문입니다. 예를 들어 UART 검증 환경을 만들면, 다른 프로젝트에서 UART를 사용할 때 동일한 에이전트를 재사용할 수 있습니다.</p>
<p><strong>키포인트</strong>: 표준화(모든 회사가 같은 방법론), 재사용(VIP), 자동화(랜덤 테스트, 커버리지)</p>
<blockquote>
<p>Ch.1 복습</p>
</blockquote>
</details>

<p><strong>Q2. uvm_object와 uvm_component의 차이는?</strong></p>
<details>
<summary>모범 답안 보기</summary>

<p><code>uvm_object</code>는 <strong>데이터</strong>를 표현하는 기본 클래스이고, <code>uvm_component</code>는 <strong>테스트벤치 구조</strong>를 구성하는 클래스입니다. 가장 큰 차이는 <code>uvm_component</code>는 <strong>Phase 메커니즘</strong>과 **계층 구조(parent-child)**를 가진다는 점입니다. 예를 들어 트랜잭션(<code>uvm_sequence_item</code>)은 <code>uvm_object</code>이고, 드라이버(<code>uvm_driver</code>)는 <code>uvm_component</code>입니다.</p>
<p><strong>키포인트</strong>: object=데이터/일시적, component=구조/영구적, component만 Phase 참여</p>
<p><strong>주의</strong>: Factory 등록 매크로도 다릅니다. object 계열은 <code>`uvm_object_utils</code>, component 계열은 <code>`uvm_component_utils</code>를 사용합니다. 이 둘을 혼동하면 컴파일 에러가 발생합니다.</p>
<blockquote>
<p>Ch.4 복습</p>
</blockquote>
</details>

<p><strong>Q3. Factory Pattern이란? 왜 new() 대신 create()를 쓰는가?</strong></p>
<details>
<summary>모범 답안 보기</summary>

<p>Factory Pattern은 <strong>객체 생성을 중앙에서 관리</strong>하는 디자인 패턴입니다. <code>new()</code> 대신 <code>create()</code>를 쓰는 이유는 **런타임에 클래스를 교체(override)**할 수 있기 때문입니다. 예를 들어 테스트 A에서는 기본 드라이버를 쓰고, 테스트 B에서는 에러 주입 드라이버로 교체할 때, 환경 코드를 수정하지 않고 Factory override만 하면 됩니다.</p>
<blockquote>
<p>💡 <strong>비유</strong>: 자동차 공장의 <strong>생산 라인</strong>과 같습니다. 세단을 만들던 라인에서 SUV를 만들고 싶을 때, 공장 전체를 새로 짓지 않고 <strong>라인(클래스)만 교체</strong>하면 됩니다. <code>create()</code>가 바로 이 &quot;교체 가능한 생산 라인&quot;입니다. <code>new()</code>를 쓰면 &quot;세단 전용 공장&quot;이 되어 SUV를 만들려면 공장을 새로 지어야 합니다.</p>
</blockquote>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// new()를 쓰면 — 교체 불가능 (세단 전용 공장)</span>
uart_driver drv = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;drv&quot;</span>, <span class="hljs-keyword">this</span>);

<span class="hljs-comment">// create()를 쓰면 — Factory가 관리, override 가능 (교체 가능 생산 라인)</span>
uart_driver drv = uart_driver::type_id::create(<span class="hljs-string">&quot;drv&quot;</span>, <span class="hljs-keyword">this</span>);
</code></pre><p><strong>키포인트</strong>: 재사용성, 유연성, 테스트별 커스터마이징</p>
<blockquote>
<p>Ch.4 복습</p>
</blockquote>
</details>

<p><strong>Q4. UVM Phase란? build_phase와 run_phase의 차이는?</strong></p>
<details>
<summary>모범 답안 보기</summary>

<p>UVM Phase는 테스트벤치의 <strong>실행 순서를 자동으로 관리</strong>하는 메커니즘입니다. <code>build_phase</code>는 <strong>컴포넌트를 생성</strong>하는 단계(top-down)이고, <code>run_phase</code>는 <strong>시뮬레이션을 실행</strong>하는 단계입니다. 핵심 차이는 <code>build_phase</code>는 <code>function</code>(시간 소모 없음)이고, <code>run_phase</code>는 <code>task</code>(시간 소모 가능, 클록 대기 가능)입니다.</p>
<p><strong>Phase 순서</strong>: build → connect → end_of_elaboration → start_of_simulation → run → extract → check → report</p>
<p><strong>키포인트</strong>: build=구조 생성, connect=연결, run=시뮬레이션 실행</p>
<blockquote>
<p>Ch.4 복습</p>
</blockquote>
</details>

<p><strong>Q5. TLM(Transaction Level Modeling)이란?</strong></p>
<details>
<summary>모범 답안 보기</summary>

<p>TLM은 <strong>신호 레벨이 아닌 트랜잭션 레벨</strong>로 컴포넌트 간 통신하는 방식입니다. 왜 사용하는가 하면, 신호 하나하나 연결하면 복잡하고 재사용이 어렵지만, 트랜잭션 단위로 통신하면 <strong>추상화 수준이 높아져</strong> 코드가 간결하고 재사용 가능해지기 때문입니다.</p>
<p><strong>핵심 포트 종류</strong>:</p>
<ul>
<li><code>uvm_blocking_put_port</code>: 1:1 통신 (드라이버↔시퀀서)</li>
<li><code>uvm_analysis_port</code>: 1:N 브로드캐스트 (모니터→스코어보드, 커버리지)</li>
</ul>
<p><strong>중요한 특성</strong>: <code>uvm_analysis_port</code>의 <code>write()</code> 메서드는 <strong>non-blocking</strong>입니다. 모니터가 <code>ap.write(item)</code>을 호출하면 연결된 모든 구독자(Scoreboard, Coverage Collector 등)의 <code>write()</code>가 순차적으로 호출됩니다. 구독자가 0개여도 에러가 발생하지 않습니다 — 이것이 Regular Port와의 핵심 차이입니다.</p>
<p><strong>키포인트</strong>: 추상화, 재사용, 1:N 브로드캐스트, non-blocking</p>
<blockquote>
<p>Ch.8 복습</p>
</blockquote>
</details>

<p><strong>Q6. Sequence와 Sequencer의 역할 차이는?</strong></p>
<details>
<summary>모범 답안 보기</summary>

<p><strong>Sequence</strong>는 <strong>트랜잭션을 생성하는 시나리오</strong>(무엇을 보낼지)이고, <strong>Sequencer</strong>는 Sequence와 Driver 사이에서 <strong>트랜잭션을 중재하는 라우터</strong>(언제, 누구 것을 보낼지)입니다. Sequence가 식당의 &quot;주문서&quot;라면, Sequencer는 &quot;주문을 받아 주방(Driver)에 전달하는 웨이터&quot;입니다.</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// Sequence — 시나리오 정의</span>
<span class="hljs-keyword">class</span> write_seq <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(apb_seq_item)</span>;
  `uvm_object_utils(write_seq)  <span class="hljs-comment">// Sequence는 uvm_object_utils!</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();
    req = apb_seq_item::type_id::create(<span class="hljs-string">&quot;req&quot;</span>);
    start_item(req);
    req<span class="hljs-variable">.randomize</span>() <span class="hljs-keyword">with</span> { pwrite == <span class="hljs-number">1</span>; };
    finish_item(req);
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>
</code></pre><p><strong>키포인트</strong>: Sequence=시나리오, Sequencer=중재, Driver=실행</p>
<blockquote>
<p>Ch.6 복습</p>
</blockquote>
</details>

<p><strong>Q7. Virtual Interface란? 왜 필요한가?</strong></p>
<details>
<summary>모범 답안 보기</summary>

<p>Virtual Interface는 <strong>클래스 기반 테스트벤치에서 모듈의 인터페이스에 접근</strong>하기 위한 핸들입니다. SystemVerilog에서 클래스(<code>class</code>)는 모듈(<code>module</code>)의 신호에 직접 접근할 수 없기 때문에 필요합니다. <code>interface</code>를 정의하고, 그 핸들을 <code>virtual interface</code>로 클래스에 전달하면 DUT 신호를 구동/관찰할 수 있습니다.</p>
<p><strong>키포인트</strong>: 클래스↔모듈 연결 다리, config_db로 전달, Driver/Monitor에서 사용</p>
<blockquote>
<p>Ch.7, Ch.11 복습</p>
</blockquote>
</details>

<p><strong>Q8. uvm_config_db란? 사용 목적은?</strong></p>
<details>
<summary>모범 답안 보기</summary>

<p><code>uvm_config_db</code>는 <strong>컴포넌트 간 설정 값을 전달하는 전역 데이터베이스</strong>입니다. 주로 Virtual Interface 전달, Agent 모드 설정(ACTIVE/PASSIVE), 테스트 파라미터 전달에 사용합니다. <code>set()</code>으로 값을 저장하고 <code>get()</code>으로 가져옵니다.</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// Top에서 set</span>
uvm_config_db<span class="hljs-variable">#(virtual apb_if)::set(null, &quot;uvm_test_top.env.agent*&quot;, &quot;vif&quot;, apb_if_inst)</span>;

<span class="hljs-comment">// Driver에서 get</span>
uvm_config_db<span class="hljs-variable">#(virtual apb_if)::get(this, &quot;&quot;, &quot;vif&quot;, vif)</span>;
</code></pre><p><strong>키포인트</strong>: 계층 간 설정 전달, 하드코딩 방지, 유연한 구성</p>
<blockquote>
<p>Ch.4, Ch.11 복습</p>
</blockquote>
</details>

<p><strong>Q9. Objection Mechanism이란?</strong></p>
<details>
<summary>모범 답안 보기</summary>

<p>Objection은 <strong>시뮬레이션 종료를 제어하는 메커니즘</strong>입니다. <code>raise_objection()</code>으로 &quot;아직 할 일이 있다&quot;고 선언하고, <code>drop_objection()</code>으로 &quot;끝났다&quot;고 알립니다. 모든 Objection이 해제되면 시뮬레이션이 종료됩니다.</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-keyword">task</span> run_phase(uvm_phase phase);
  phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);  <span class="hljs-comment">// 시작</span>
  <span class="hljs-comment">// ... 테스트 시나리오 ...</span>
  phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);   <span class="hljs-comment">// 종료</span>
<span class="hljs-keyword">endtask</span>
</code></pre><p><strong>키포인트</strong>: raise/drop 쌍, 보통 Test 레벨에서만 사용, 누락 시 즉시 종료</p>
<blockquote>
<p>Ch.4 복습</p>
</blockquote>
</details>

<p><strong>Q10. uvm_sequence_item의 역할은?</strong></p>
<details>
<summary>모범 답안 보기</summary>

<p><code>uvm_sequence_item</code>은 <strong>검증 환경에서 주고받는 데이터의 단위</strong>인 트랜잭션(Transaction)을 정의하는 클래스입니다. DUT의 프로토콜에 맞는 필드(주소, 데이터, 제어 신호 등)를 <code>rand</code>로 선언하여 <strong>랜덤 테스트</strong>가 가능하게 합니다. <code>uvm_object</code>를 상속하므로 <code>copy()</code>, <code>compare()</code>, <code>print()</code> 등의 유틸리티 기능을 활용할 수 있습니다.</p>
<p><strong>키포인트</strong>: 트랜잭션 정의, rand 필드, <code>uvm_field_*</code> 매크로 또는 do_copy/do_compare 구현</p>
<blockquote>
<p>Ch.6, Ch.11 복습</p>
</blockquote>
</details>

<h3 id="15-2-2-컴포넌트-amp-아키텍처-10문항">15.2.2 컴포넌트 &amp; 아키텍처 (10문항)</h3>
<p>이 카테고리는 <strong>UVM 테스트벤치 구조를 이해하고 있는지</strong> 확인합니다.</p>
<p><strong>Q11. UVM Agent의 구조를 설명하라.</strong></p>
<details>
<summary>모범 답안 보기</summary>

<p>UVM Agent는 <strong>DUT의 하나의 인터페이스를 검증하는 단위</strong>입니다. 세 개의 핵심 컴포넌트로 구성됩니다:</p>
<ul>
<li><strong>Sequencer</strong>: 트랜잭션 흐름 중재</li>
<li><strong>Driver</strong>: 트랜잭션을 DUT 신호로 변환</li>
<li><strong>Monitor</strong>: DUT 신호를 트랜잭션으로 변환 (관찰)</li>
</ul>
<p>Agent는 <strong>ACTIVE</strong> 모드(Sequencer+Driver+Monitor)와 <strong>PASSIVE</strong> 모드(Monitor만)로 동작합니다. PASSIVE 모드는 신호를 관찰만 할 때 사용합니다.</p>
<p><strong>키포인트</strong>: Sequencer-Driver-Monitor 삼총사, ACTIVE/PASSIVE 모드, Agent는 재사용 단위</p>
<blockquote>
<p>Ch.7, Ch.11 복습</p>
</blockquote>
</details>

<p><strong>Q12. Driver와 Monitor의 차이는?</strong></p>
<details>
<summary>모범 답안 보기</summary>

<p><strong>Driver</strong>는 트랜잭션을 받아 <strong>DUT 입력 신호를 구동</strong>(drive)하는 역할이고, <strong>Monitor</strong>는 DUT 인터페이스의 신호를 <strong>관찰(observe)하여 트랜잭션으로 변환</strong>하는 역할입니다. 핵심 차이는 Driver는 DUT에 <strong>능동적으로</strong> 신호를 보내고, Monitor는 <strong>수동적으로</strong> 관찰만 합니다.</p>
<p><strong>키포인트</strong>: Driver=구동(능동), Monitor=관찰(수동), Monitor는 항상 존재(PASSIVE 모드에서도)</p>
<blockquote>
<p>Ch.7 복습</p>
</blockquote>
</details>

<p><strong>Q13. Scoreboard의 역할과 구현 방법은?</strong></p>
<details>
<summary>모범 답안 보기</summary>

<p>Scoreboard는 <strong>DUT의 출력이 예상 결과와 일치하는지 자동으로 비교</strong>하는 컴포넌트입니다. Monitor의 <code>analysis_port</code>에 연결되어 트랜잭션을 수신하고, 내부의 **참조 모델(Reference Model)**과 비교합니다.</p>
<p>구현 방법:</p>
<ol>
<li><code>uvm_scoreboard</code> 상속</li>
<li><code>uvm_analysis_imp</code> 또는 <code>uvm_tlm_analysis_fifo</code> 사용</li>
<li><code>write()</code> 메서드에서 비교 로직 구현</li>
</ol>
<p><strong>키포인트</strong>: 자동 비교, analysis port 연결, 참조 모델</p>
<blockquote>
<p>Ch.8 복습</p>
</blockquote>
</details>

<p><strong>Q14. Analysis Port와 Regular Port의 차이는?</strong></p>
<details>
<summary>모범 답안 보기</summary>

<p><strong>Regular Port</strong>(<code>uvm_blocking_put_port</code> 등)는 <strong>1:1 통신</strong>으로, 데이터를 보내고 받는 양쪽이 연결되어야 합니다. <strong>Analysis Port</strong>(<code>uvm_analysis_port</code>)는 <strong>1:N 브로드캐스트</strong>로, 하나의 송신자(보통 Monitor)가 여러 수신자(Scoreboard, Coverage Collector 등)에게 동시에 데이터를 보낼 수 있습니다.</p>
<p><strong>핵심 차이</strong>: Analysis Port는 연결된 구독자가 0개여도 에러가 나지 않습니다 (non-blocking). <code>write()</code> 호출 시 모든 구독자의 <code>write()</code>가 순차 호출되지만, 포트 자체에는 blocking이 없습니다.</p>
<p><strong>키포인트</strong>: Regular=1:1/blocking, Analysis=1:N/non-blocking</p>
<blockquote>
<p>Ch.8 복습</p>
</blockquote>
</details>

<p><strong>Q15. Environment(uvm_env)의 역할은?</strong></p>
<details>
<summary>모범 답안 보기</summary>

<p><code>uvm_env</code>는 <strong>Agent, Scoreboard, Coverage Collector 등을 하나로 묶는 컨테이너</strong>입니다. 재사용의 핵심 단위로, 하나의 Environment에 여러 Agent와 Scoreboard를 조합하여 복잡한 검증 환경을 구성합니다.</p>
<p><strong>키포인트</strong>: 컴포넌트 조합 컨테이너, 재사용 단위, Test에서 인스턴스화</p>
<blockquote>
<p>Ch.5, Ch.11 복습</p>
</blockquote>
</details>

<p><strong>Q16. RAL(Register Abstraction Layer)이란?</strong></p>
<details>
<summary>모범 답안 보기</summary>

<p>RAL은 DUT의 <strong>레지스터를 소프트웨어 객체로 추상화</strong>하여 접근하는 계층입니다. 물리적 주소/데이터 대신 <code>reg_block.reg_name.field_name.write(value)</code> 같은 <strong>의미 있는 이름</strong>으로 레지스터를 읽고 쓸 수 있습니다. RAL은 내부적으로 Adapter를 통해 시퀀스 아이템으로 변환합니다.</p>
<p><strong>키포인트</strong>: 레지스터 추상화, 이름 기반 접근, 미러 기능(예상값 추적), Adapter로 변환</p>
<blockquote>
<p>Ch.12 복습</p>
</blockquote>
</details>

<p><strong>Q17. Virtual Sequence란? 왜 필요한가?</strong></p>
<details>
<summary>모범 답안 보기</summary>

<p>Virtual Sequence는 <strong>여러 Agent의 Sequencer를 동시에 제어</strong>하는 상위 시퀀스입니다. 예를 들어 APB Agent와 AXI Agent가 있을 때, 두 인터페이스에 대한 시나리오를 하나의 Virtual Sequence에서 조율할 수 있습니다.</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-keyword">class</span> system_vseq <span class="hljs-keyword">extends</span> uvm_sequence;
  `uvm_object_utils(system_vseq)  <span class="hljs-comment">// Virtual Sequence도 uvm_object_utils!</span>

  apb_sequencer apb_sqr;
  axi_sequencer axi_sqr;

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();
    <span class="hljs-keyword">fork</span>
      apb_write_seq<span class="hljs-variable">.start</span>(apb_sqr);  <span class="hljs-comment">// APB 쓰기</span>
      axi_read_seq<span class="hljs-variable">.start</span>(axi_sqr);   <span class="hljs-comment">// AXI 읽기 (동시)</span>
    <span class="hljs-keyword">join</span>
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>
</code></pre><p><strong>키포인트</strong>: 다중 Agent 조율, Virtual Sequencer에서 핸들 관리, fork-join으로 동시 실행</p>
<blockquote>
<p>Ch.13 복습</p>
</blockquote>
</details>

<p><strong>Q18. Coverage란? Functional Coverage와 Code Coverage의 차이는?</strong></p>
<details>
<summary>모범 답안 보기</summary>

<p>Coverage는 <strong>검증이 얼마나 충분한지 측정하는 지표</strong>입니다.</p>
<ul>
<li><strong>Code Coverage</strong>: 시뮬레이터가 자동 수집. RTL 코드의 몇 %가 실행되었는지 (line, branch, toggle, FSM 등)</li>
<li><strong>Functional Coverage</strong>: 검증 엔지니어가 직접 정의. <strong>원하는 시나리오가 실행되었는지</strong> (주소 범위, 읽기/쓰기 조합, 연속 패턴 등)</li>
</ul>
<p><strong>키포인트</strong>: Code=자동/RTL 기준, Functional=수동/스펙 기준, 둘 다 필요</p>
<blockquote>
<p>Ch.14 복습</p>
</blockquote>
</details>

<p><strong>Q19. Assertion이란? Immediate vs Concurrent의 차이는?</strong></p>
<details>
<summary>모범 답안 보기</summary>

<p>Assertion은 **&quot;이 조건이 항상 참이어야 한다&quot;**를 선언하는 검증 기법입니다.</p>
<ul>
<li><strong>Immediate Assertion</strong>: 절차적 코드 안에서 <strong>즉시</strong> 평가 (combinational)</li>
<li><strong>Concurrent Assertion</strong>: <strong>클록 기반</strong>으로 시간에 걸쳐 평가 (sequential)</li>
</ul>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// Immediate — 지금 이 순간 체크</span>
<span class="hljs-keyword">assert</span> (paddr &lt; <span class="hljs-number">16</span>) <span class="hljs-keyword">else</span> <span class="hljs-built_in">$error</span>(<span class="hljs-string">&quot;주소 범위 초과!&quot;</span>);

<span class="hljs-comment">// Concurrent — 클록 기반 시퀀스 체크</span>
<span class="hljs-keyword">assert</span> <span class="hljs-keyword">property</span> (@(<span class="hljs-keyword">posedge</span> clk) psel |-&gt; ##<span class="hljs-number">1</span> penable);
</code></pre><p><strong>키포인트</strong>: Immediate=즉시/combinational, Concurrent=클록/temporal, SVA는 Concurrent</p>
<blockquote>
<p>Ch.14 복습</p>
</blockquote>
</details>

<p><strong>Q20. Callback이란? 언제 사용하는가?</strong></p>
<details>
<summary>모범 답안 보기</summary>

<p>Callback은 <strong>기존 코드를 수정하지 않고 동작을 추가/변경</strong>할 수 있는 메커니즘입니다. Driver나 Monitor에 미리 정의된 훅(hook) 포인트에 새로운 동작을 등록합니다. 예를 들어 Driver의 트랜잭션 전송 전/후에 에러를 주입하거나 로그를 추가할 때 사용합니다.</p>
<p><strong>키포인트</strong>: 코드 수정 없이 동작 추가, 에러 주입/로깅, VIP 커스터마이징</p>
<blockquote>
<p>Ch.13 복습</p>
</blockquote>
</details>

<h3 id="15-2-3-고급-주제-amp-실무-10문항">15.2.3 고급 주제 &amp; 실무 (10문항)</h3>
<p>이 카테고리는 <strong>실무 경험과 깊은 이해</strong>를 확인합니다. 경력 면접에서 더 비중이 높습니다.</p>
<p><strong>Q21. Constrained Random Verification이란?</strong></p>
<details>
<summary>모범 답안 보기</summary>

<p>Constrained Random Verification은 <strong>제약 조건 내에서 랜덤으로 테스트 시나리오를 생성</strong>하는 검증 방법입니다. 완전히 랜덤이면 무효한 시나리오가 생기고, 완전히 지정하면 커버리지가 부족합니다. constraint로 유효 범위를 제한하면서 그 안에서 다양한 조합을 자동 생성합니다.</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-keyword">class</span> apb_seq_item <span class="hljs-keyword">extends</span> uvm_sequence_item;
  <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>]  paddr;
  <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] pwdata;
  <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span>        pwrite;

  <span class="hljs-keyword">constraint</span> valid_addr { paddr <span class="hljs-keyword">inside</span> {[<span class="hljs-number">0</span>:<span class="hljs-number">15</span>]}; }
  <span class="hljs-keyword">constraint</span> write_bias { pwrite <span class="hljs-keyword">dist</span> {<span class="hljs-number">1</span> := <span class="hljs-number">70</span>, <span class="hljs-number">0</span> := <span class="hljs-number">30</span>}; }  <span class="hljs-comment">// 쓰기 70%</span>
<span class="hljs-keyword">endclass</span>
</code></pre><p><strong>키포인트</strong>: 유효 범위 내 자동 다양화, constraint, dist로 비중 조절</p>
<blockquote>
<p>Ch.9 복습</p>
</blockquote>
</details>

<p><strong>Q22. Coverage Closure란? 어떻게 달성하는가?</strong></p>
<details>
<summary>모범 답안 보기</summary>

<p>Coverage Closure는 <strong>목표 커버리지에 도달하기 위한 반복적 프로세스</strong>입니다:</p>
<ol>
<li>랜덤 테스트 실행 → 커버리지 리포트 분석</li>
<li>미달 항목(hole) 식별</li>
<li>타겟 시퀀스 작성 (hole을 채우는 특정 시나리오)</li>
<li>재실행 → 리포트 확인 → 반복</li>
</ol>
<p>실무에서는 보통 랜덤 테스트로 80%, 타겟 테스트로 나머지 20%를 달성합니다.</p>
<p><strong>키포인트</strong>: 반복적 프로세스, 랜덤+타겟 조합, 100% 달성이 목표가 아닐 수도 있음 (waiver)</p>
<blockquote>
<p>Ch.14 복습</p>
</blockquote>
</details>

<p><strong>Q23. UVM에서 Reset 처리는 어떻게 하는가?</strong></p>
<details>
<summary>모범 답안 보기</summary>

<p>Reset 처리는 검증에서 중요한 시나리오입니다. UVM에서는 보통:</p>
<ol>
<li><strong>Sequence에서 reset 시퀀스</strong> 작성 (reset 신호 구동)</li>
<li><strong>Monitor에서 reset 감지</strong> 후 내부 상태 초기화</li>
<li><strong>Scoreboard에서 reset 시 예상 값 초기화</strong></li>
<li><strong>Driver에서 reset 중 트랜잭션 처리 중단</strong></li>
</ol>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// Monitor에서 reset 감지 예시</span>
<span class="hljs-keyword">forever</span> <span class="hljs-keyword">begin</span>
  @(<span class="hljs-keyword">negedge</span> vif<span class="hljs-variable">.rst_n</span>);
  <span class="hljs-comment">// reset 시작 — 진행 중인 트랜잭션 무효화</span>
  @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.rst_n</span>);
  <span class="hljs-comment">// reset 해제 — 모니터링 재개</span>
<span class="hljs-keyword">end</span>
</code></pre><p>실무에서는 **<code>uvm_heartbeat</code>**를 함께 사용하여 reset 후 hang(무응답)을 감지합니다. Heartbeat는 특정 Objection이 주기적으로 갱신되는지 모니터링하여, 갱신이 없으면 &quot;시뮬레이션이 멈췄다&quot;고 경고합니다.</p>
<p><strong>키포인트</strong>: 모든 컴포넌트가 reset에 반응해야 함, Sequence에서 reset 시나리오 작성, heartbeat로 hang 감지</p>
<blockquote>
<p>Ch.7 복습</p>
</blockquote>
</details>

<p><strong>Q24. VIP(Verification IP)란? 어떻게 사용하는가?</strong></p>
<details>
<summary>모범 답안 보기</summary>

<p>VIP는 <strong>특정 프로토콜(APB, AXI, PCIe 등)에 대한 사전 검증된 UVM 에이전트</strong>입니다. 직접 만들지 않고 Synopsys, Cadence, Siemens 등에서 제공하는 상용 VIP를 사용합니다. VIP에는 Agent, Sequence Library, Coverage Model, Protocol Checker가 포함됩니다.</p>
<p><strong>사용 시 핵심</strong>:</p>
<ul>
<li>VIP의 시퀀스 라이브러리를 활용하여 테스트 작성</li>
<li>Factory override로 커스터마이징</li>
<li>Callback으로 추가 동작 삽입</li>
</ul>
<p><strong>키포인트</strong>: 상용 검증 IP, 재사용, 프로토콜 표준 준수 보장</p>
<blockquote>
<p>Ch.12 복습</p>
</blockquote>
</details>

<p><strong>Q25. 시뮬레이션 성능을 개선하는 방법은?</strong></p>
<details>
<summary>모범 답안 보기</summary>

<p>UVM 시뮬레이션 성능 개선 주요 방법:</p>
<ol>
<li><strong>verbosity 줄이기</strong>: <code>UVM_HIGH</code>→<code>UVM_LOW</code>로 로그 출력 최소화</li>
<li><strong>$display 제거</strong>: 대신 <code>uvm_info</code> 사용 (verbosity 제어 가능)</li>
<li><strong>불필요한 field macro 제거</strong>: <code>uvm_field_*</code> 매크로는 느림, do_copy/do_compare 직접 구현</li>
<li><strong>커버리지 선택적 수집</strong>: 불필요한 covergroup disable</li>
<li><strong>병렬 시뮬레이션</strong>: 테스트를 여러 시드로 병렬 실행</li>
</ol>
<p><strong>키포인트</strong>: field macro 오버헤드, verbosity 제어, 병렬 리그레션</p>
<blockquote>
<p>Ch.10 복습</p>
</blockquote>
</details>

<p><strong>Q26. <code>uvm_field_*</code> 매크로의 장단점은?</strong></p>
<details>
<summary>모범 답안 보기</summary>

<p><strong>장점</strong>: <code>copy()</code>, <code>compare()</code>, <code>print()</code>, <code>pack()/unpack()</code> 등을 자동 생성하여 코드가 간결합니다.</p>
<p><strong>단점</strong>: 내부적으로 문자열 기반 처리를 하므로 <strong>성능이 느립니다</strong>. 대규모 시뮬레이션에서는 <code>do_copy()</code>, <code>do_compare()</code>, <code>do_print()</code> 등을 직접 구현하는 것이 권장됩니다.</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// field macro (간편하지만 느림)</span>
`uvm_field_int(paddr, UVM_ALL_ON)

<span class="hljs-comment">// do_compare (수동이지만 빠름)</span>
<span class="hljs-keyword">function</span> <span class="hljs-keyword">bit</span> do_compare(uvm_object rhs, uvm_comparer comparer);
  apb_seq_item rhs_;
  <span class="hljs-built_in">$cast</span>(rhs_, rhs);
  <span class="hljs-keyword">return</span> (paddr == rhs_<span class="hljs-variable">.paddr</span>) &amp;&amp; (pwdata == rhs_<span class="hljs-variable">.pwdata</span>);
<span class="hljs-keyword">endfunction</span>
</code></pre><p><strong>키포인트</strong>: 소규모=macro 편리, 대규모=do_* 직접 구현, 성능 차이 유의</p>
<blockquote>
<p>Ch.4 복습</p>
</blockquote>
</details>

<p><strong>Q27. end_of_elaboration_phase의 용도는?</strong></p>
<details>
<summary>모범 답안 보기</summary>

<p><code>end_of_elaboration_phase</code>는 <strong>모든 컴포넌트가 build/connect를 완료한 후</strong> 실행되는 Phase입니다. 주로 다음 용도로 사용합니다:</p>
<ul>
<li>UVM 토폴로지 출력 (<code>uvm_top.print_topology()</code>)</li>
<li>최종 설정 확인</li>
<li>컴포넌트 간 교차 참조 설정</li>
</ul>
<p><strong>키포인트</strong>: build/connect 완료 후 실행, 디버깅/확인 용도, function phase</p>
<blockquote>
<p>Ch.4 복습</p>
</blockquote>
</details>

<p><strong>Q28. Multi-agent 환경 설계 시 고려사항은?</strong></p>
<details>
<summary>모범 답안 보기</summary>

<p>여러 Agent가 있는 환경에서 고려할 사항:</p>
<ol>
<li><strong>Virtual Sequencer</strong>: 여러 Agent의 Sequencer 핸들을 모아 조율</li>
<li><strong>Scoreboard 연결</strong>: 여러 Monitor의 트랜잭션을 하나의 Scoreboard에서 비교</li>
<li><strong>동기화</strong>: <code>fork-join</code>으로 동시 시나리오, 이벤트(<code>uvm_event</code>)로 Agent 간 동기화</li>
<li><strong>Clock domain</strong>: Agent별 다른 클록 도메인 처리</li>
</ol>
<p><strong>키포인트</strong>: Virtual Sequencer로 조율, Analysis Port로 Scoreboard 연결, 동기화</p>
<blockquote>
<p>Ch.13 복습</p>
</blockquote>
</details>

<p><strong>Q29. UVM에서 에러 주입(Error Injection)은 어떻게 하는가?</strong></p>
<details>
<summary>모범 답안 보기</summary>

<p>에러 주입 방법:</p>
<ol>
<li><strong>Sequence에서 잘못된 트랜잭션 생성</strong>: constraint를 조작하여 프로토콜 위반 시나리오</li>
<li><strong>Callback을 통한 Driver 수정</strong>: 전송 직전에 데이터 변조</li>
<li><strong>Factory Override</strong>: 기본 트랜잭션을 에러 트랜잭션으로 교체</li>
</ol>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// Sequence에서 에러 주입 예시</span>
<span class="hljs-keyword">class</span> error_seq <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(apb_seq_item)</span>;
  `uvm_object_utils(error_seq)  <span class="hljs-comment">// Sequence → uvm_object_utils</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();
    req = apb_seq_item::type_id::create(<span class="hljs-string">&quot;req&quot;</span>);
    start_item(req);
    <span class="hljs-comment">// 의도적으로 유효 범위 밖 주소 사용</span>
    req<span class="hljs-variable">.randomize</span>() <span class="hljs-keyword">with</span> { paddr &gt; <span class="hljs-number">4&#x27;hF</span>; };
    finish_item(req);
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>
</code></pre><p><strong>키포인트</strong>: Sequence 조작, Callback, Factory Override</p>
<blockquote>
<p>Ch.9, Ch.13 복습</p>
</blockquote>
</details>

<p><strong>Q30. 실무에서 UVM 테스트벤치를 처음부터 구축하는 순서는?</strong></p>
<details>
<summary>모범 답안 보기</summary>

<p>실무에서의 구축 순서:</p>
<ol>
<li><strong>스펙 분석</strong>: DUT 인터페이스, 프로토콜 이해</li>
<li><strong>Transaction 정의</strong>: <code>uvm_sequence_item</code> 필드 설계</li>
<li><strong>Interface 정의</strong>: DUT 연결용 <code>interface</code> 작성</li>
<li><strong>Agent 구축</strong>: Driver → Monitor → Sequencer → Agent 순</li>
<li><strong>Environment 구성</strong>: Agent + Scoreboard + Coverage Collector</li>
<li><strong>기본 테스트 작성</strong>: Smoke test (간단한 읽기/쓰기)</li>
<li><strong>커버리지 모델 추가</strong>: Functional Coverage 정의</li>
<li><strong>어서션 추가</strong>: 프로토콜 규칙 SVA</li>
<li><strong>테스트 시나리오 확장</strong>: Random + Directed 테스트</li>
<li><strong>커버리지 클로저</strong>: 목표 달성까지 반복</li>
</ol>
<p><strong>키포인트</strong>: 스펙→Transaction→Agent→Env→Test→Coverage→Closure 순서</p>
<blockquote>
<p>Ch.1~14 전체 복습</p>
</blockquote>
</details>

<hr>
<h2 id="15-3-코드-리뷰-면접-대비">15.3 코드 리뷰 면접 대비</h2>
<blockquote>
<p><strong>이 절의 목표</strong>: UVM 코드에서 버그를 찾고 개선안을 제시하는 능력을 연습합니다.</p>
</blockquote>
<p>코드 리뷰 면접에서 <strong>자주 혼동하는 매크로 구분</strong>을 먼저 정리합시다:</p>
<table>
<thead>
<tr>
<th>클래스 종류</th>
<th>Factory 등록 매크로</th>
<th>예시</th>
</tr>
</thead>
<tbody><tr>
<td>uvm_component 계열</td>
<td><code>`uvm_component_utils</code></td>
<td>Driver, Monitor, Agent, Env, Test</td>
</tr>
<tr>
<td>uvm_object 계열</td>
<td><code>`uvm_object_utils</code></td>
<td>Sequence, Transaction(seq_item)</td>
</tr>
</tbody></table>
<blockquote>
<p>이 구분을 혼동하면 <strong>컴파일 에러</strong>가 발생합니다. 면접에서 가장 흔히 테스트하는 포인트 중 하나입니다.</p>
</blockquote>
<h3 id="15-3-1-quot-이-코드의-문제를-찾아라-quot-유형">15.3.1 &quot;이 코드의 문제를 찾아라&quot; 유형</h3>
<p><strong>면접관이 UVM 코드를 보여주고 &quot;무엇이 잘못되었는가?&quot; 물어봅니다.</strong> 이 유형은 UVM을 실제로 사용해본 사람과 아닌 사람을 구분합니다.</p>
<p><strong>문제 1: 쉬움 — Driver에서의 3가지 문제</strong></p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// apb_driver.sv — 이 코드에서 문제 3가지를 찾아라</span>

<span class="hljs-keyword">class</span> apb_driver <span class="hljs-keyword">extends</span> uvm_driver;  <span class="hljs-comment">// (1)</span>
  <span class="hljs-keyword">virtual</span> apb_if vif;

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
    <span class="hljs-comment">// (2) super.build_phase 생략</span>
    uvm_config_db<span class="hljs-variable">#(virtual apb_if)::get(this, &quot;&quot;, &quot;vif&quot;, vif)</span>;
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> run_phase(uvm_phase phase);
    <span class="hljs-keyword">forever</span> <span class="hljs-keyword">begin</span>
      seq_item_port<span class="hljs-variable">.get_next_item</span>(req);
      vif<span class="hljs-variable">.paddr</span>  = req<span class="hljs-variable">.paddr</span>;
      vif<span class="hljs-variable">.pwdata</span> = req<span class="hljs-variable">.pwdata</span>;
      vif<span class="hljs-variable">.pwrite</span> = req<span class="hljs-variable">.pwrite</span>;
      vif<span class="hljs-variable">.psel</span>   = <span class="hljs-number">1</span>;
      <span class="hljs-comment">// (3) penable 타이밍 누락</span>
      @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>);
      vif<span class="hljs-variable">.psel</span>   = <span class="hljs-number">0</span>;
      seq_item_port<span class="hljs-variable">.item_done</span>();
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>
</code></pre><details>
<summary>정답 보기</summary>

<p><strong>문제 1</strong>: 파라미터화 누락</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// 잘못됨</span>
<span class="hljs-keyword">class</span> apb_driver <span class="hljs-keyword">extends</span> uvm_driver;
<span class="hljs-comment">// 올바름</span>
<span class="hljs-keyword">class</span> apb_driver <span class="hljs-keyword">extends</span> uvm_driver <span class="hljs-variable">#(apb_seq_item)</span>;
</code></pre><p><code>uvm_driver</code>는 <code>#(REQ)</code>로 트랜잭션 타입을 파라미터로 받아야 합니다. 누락하면 <code>req</code>의 타입이 <code>uvm_sequence_item</code>이 되어 필드 접근 시 <code>$cast</code>가 필요합니다.</p>
<p><strong>문제 2</strong>: <code>super.build_phase(phase)</code> 누락</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
  <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);  <span class="hljs-comment">// 반드시 호출!</span>
  <span class="hljs-comment">// ...</span>
<span class="hljs-keyword">endfunction</span>
</code></pre><p>부모 클래스의 build 로직이 실행되지 않아 예기치 않은 동작이 발생할 수 있습니다.</p>
<p><strong>문제 3</strong>: APB 프로토콜 위반 — <code>penable</code> 처리 누락</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// 올바른 APB 프로토콜:</span>
<span class="hljs-comment">// Setup phase: psel=1, penable=0 (1사이클)</span>
<span class="hljs-comment">// Access phase: psel=1, penable=1 (pready까지)</span>
vif<span class="hljs-variable">.psel</span>    = <span class="hljs-number">1</span>;
vif<span class="hljs-variable">.penable</span> = <span class="hljs-number">0</span>;
@(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>);     <span class="hljs-comment">// Setup phase</span>
vif<span class="hljs-variable">.penable</span> = <span class="hljs-number">1</span>;
@(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span> <span class="hljs-keyword">iff</span> vif<span class="hljs-variable">.pready</span>);  <span class="hljs-comment">// Access phase (pready 대기)</span>
vif<span class="hljs-variable">.psel</span>    = <span class="hljs-number">0</span>;
vif<span class="hljs-variable">.penable</span> = <span class="hljs-number">0</span>;
</code></pre><p><strong>추가 문제</strong>: <code>`uvm_component_utils</code> 매크로도 누락되었습니다 — Factory에 등록되지 않아 <code>create()</code> 사용 불가.</p>
</details>

<p><strong>문제 2: 보통 — Scoreboard의 문제</strong></p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// apb_scoreboard.sv — 이 코드의 문제를 찾아라</span>

<span class="hljs-keyword">class</span> apb_scoreboard <span class="hljs-keyword">extends</span> uvm_scoreboard;
  `uvm_component_utils(apb_scoreboard)

  uvm_analysis_imp <span class="hljs-variable">#(apb_seq_item, apb_scoreboard)</span> analysis_export;

  <span class="hljs-keyword">bit</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] memory [<span class="hljs-keyword">bit</span>[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>]];  <span class="hljs-comment">// 참조 모델</span>

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);
    analysis_export = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;analysis_export&quot;</span>, <span class="hljs-keyword">this</span>);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> write(apb_seq_item item);
    <span class="hljs-keyword">if</span> (item<span class="hljs-variable">.pwrite</span>) <span class="hljs-keyword">begin</span>
      memory[item<span class="hljs-variable">.paddr</span>] = item<span class="hljs-variable">.pwdata</span>;
    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
      <span class="hljs-keyword">if</span> (memory[item<span class="hljs-variable">.paddr</span>] != item<span class="hljs-variable">.prdata</span>) <span class="hljs-keyword">begin</span>
        `uvm_error(get_type_name(),
          <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;Mismatch! addr=0x%0h exp=0x%0h got=0x%0h&quot;</span>,
            item<span class="hljs-variable">.paddr</span>, memory[item<span class="hljs-variable">.paddr</span>], item<span class="hljs-variable">.prdata</span>))
      <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">endfunction</span>
<span class="hljs-keyword">endclass</span>
</code></pre><details>
<summary>정답 보기</summary>

<p><strong>문제 1</strong>: 읽기 검증에서 <strong>초기화되지 않은 메모리 접근</strong> 위험</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// 쓰기 전에 읽기가 먼저 오면?</span>
<span class="hljs-comment">// memory[addr]가 존재하지 않으므로 0과 비교 — 잘못된 결과</span>
<span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> write(apb_seq_item item);
  <span class="hljs-keyword">if</span> (item<span class="hljs-variable">.pwrite</span>) <span class="hljs-keyword">begin</span>
    memory[item<span class="hljs-variable">.paddr</span>] = item<span class="hljs-variable">.pwdata</span>;
  <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>
    <span class="hljs-keyword">if</span> (!memory<span class="hljs-variable">.exists</span>(item<span class="hljs-variable">.paddr</span>)) <span class="hljs-keyword">begin</span>
      `uvm_warning(get_type_name(),
        <span class="hljs-built_in">$sformatf</span>(<span class="hljs-string">&quot;Read from uninitialized addr 0x%0h&quot;</span>, item<span class="hljs-variable">.paddr</span>))
    <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (memory[item<span class="hljs-variable">.paddr</span>] != item<span class="hljs-variable">.prdata</span>) <span class="hljs-keyword">begin</span>
      <span class="hljs-comment">// 비교 ...</span>
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endfunction</span>
</code></pre><p><strong>문제 2</strong>: 읽기와 쓰기를 <strong>같은 analysis port</strong>로 받는데, <strong>순서 보장 문제</strong>가 있을 수 있음. 쓰기 트랜잭션이 DUT에서 처리되기 전에 같은 주소의 읽기가 올 수 있습니다. 실무에서는 <strong>FIFO 기반</strong> 비교나 <strong>타이밍 고려</strong>가 필요합니다.</p>
<p><strong>문제 3</strong>: 에러 카운트 관리 없음 — 몇 개의 비교를 했고 몇 개가 실패했는지 <code>report_phase</code>에서 요약하는 것이 좋습니다.</p>
</details>

<p><strong>문제 3: 어려움 — Environment 구조 문제</strong></p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// apb_env.sv — 이 환경의 설계 문제를 찾아라</span>

<span class="hljs-keyword">class</span> apb_env <span class="hljs-keyword">extends</span> uvm_env;
  `uvm_component_utils(apb_env)

  apb_driver    driver;
  apb_monitor   monitor;
  apb_sequencer sequencer;
  apb_scoreboard scoreboard;

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);
    driver     = apb_driver::type_id::create(<span class="hljs-string">&quot;driver&quot;</span>, <span class="hljs-keyword">this</span>);
    monitor    = apb_monitor::type_id::create(<span class="hljs-string">&quot;monitor&quot;</span>, <span class="hljs-keyword">this</span>);
    sequencer  = apb_sequencer::type_id::create(<span class="hljs-string">&quot;sequencer&quot;</span>, <span class="hljs-keyword">this</span>);
    scoreboard = apb_scoreboard::type_id::create(<span class="hljs-string">&quot;scoreboard&quot;</span>, <span class="hljs-keyword">this</span>);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> connect_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.connect_phase</span>(phase);
    driver<span class="hljs-variable">.seq_item_port</span><span class="hljs-variable">.connect</span>(sequencer<span class="hljs-variable">.seq_item_export</span>);
    monitor<span class="hljs-variable">.ap</span><span class="hljs-variable">.connect</span>(scoreboard<span class="hljs-variable">.analysis_export</span>);
  <span class="hljs-keyword">endfunction</span>
<span class="hljs-keyword">endclass</span>
</code></pre><details>
<summary>정답 보기</summary>

<p><strong>핵심 문제: Agent 계층이 없음</strong></p>
<p>Driver, Monitor, Sequencer가 Environment에 직접 있으면 <strong>재사용이 불가능</strong>합니다. 이것들은 <strong>Agent</strong> 안에 캡슐화되어야 합니다:</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// 올바른 구조</span>
<span class="hljs-keyword">class</span> apb_env <span class="hljs-keyword">extends</span> uvm_env;
  `uvm_component_utils(apb_env)

  apb_agent      agent;       <span class="hljs-comment">// Agent가 Driver/Monitor/Sequencer를 포함</span>
  apb_scoreboard scoreboard;

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);
    agent      = apb_agent::type_id::create(<span class="hljs-string">&quot;agent&quot;</span>, <span class="hljs-keyword">this</span>);
    scoreboard = apb_scoreboard::type_id::create(<span class="hljs-string">&quot;scoreboard&quot;</span>, <span class="hljs-keyword">this</span>);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> connect_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.connect_phase</span>(phase);
    agent<span class="hljs-variable">.monitor</span><span class="hljs-variable">.ap</span><span class="hljs-variable">.connect</span>(scoreboard<span class="hljs-variable">.analysis_export</span>);
  <span class="hljs-keyword">endfunction</span>
<span class="hljs-keyword">endclass</span>
</code></pre><p><strong>왜 Agent가 필요한가?</strong></p>
<ul>
<li><strong>ACTIVE/PASSIVE 모드</strong>: Agent 없이는 모드 전환 불가</li>
<li><strong>재사용</strong>: Agent 단위로 다른 Environment에 통합</li>
<li><strong>캡슐화</strong>: Driver-Sequencer 연결은 Agent 내부 문제</li>
</ul>
<p>이것은 <strong>면접에서 아키텍처 이해도를 측정하는 핵심 질문</strong>입니다.</p>
</details>

<h3 id="15-3-2-quot-이-환경을-개선해라-quot-유형">15.3.2 &quot;이 환경을 개선해라&quot; 유형</h3>
<p>이 유형은 동작하는 코드를 <strong>더 좋게 만드는 능력</strong>을 봅니다.</p>
<p><strong>문제: 다음 테스트를 개선하라</strong></p>
<pre><code class="hljs language-systemverilog"><span class="hljs-keyword">class</span> basic_test <span class="hljs-keyword">extends</span> uvm_test;
  `uvm_component_utils(basic_test)
  apb_env env;

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);
    env = apb_env::type_id::create(<span class="hljs-string">&quot;env&quot;</span>, <span class="hljs-keyword">this</span>);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> run_phase(uvm_phase phase);
    apb_seq_item req;
    phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);

    <span class="hljs-comment">// 100번 랜덤 쓰기</span>
    <span class="hljs-keyword">repeat</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">begin</span>
      req = apb_seq_item::type_id::create(<span class="hljs-string">&quot;req&quot;</span>);
      start_item(req);
      req<span class="hljs-variable">.randomize</span>() <span class="hljs-keyword">with</span> { pwrite == <span class="hljs-number">1</span>; };
      finish_item(req);
    <span class="hljs-keyword">end</span>

    <span class="hljs-comment">// 100번 랜덤 읽기</span>
    <span class="hljs-keyword">repeat</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">begin</span>
      req = apb_seq_item::type_id::create(<span class="hljs-string">&quot;req&quot;</span>);
      start_item(req);
      req<span class="hljs-variable">.randomize</span>() <span class="hljs-keyword">with</span> { pwrite == <span class="hljs-number">0</span>; };
      finish_item(req);
    <span class="hljs-keyword">end</span>

    phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>
</code></pre><details>
<summary>개선안 보기</summary>

<p><strong>문제점 4가지:</strong></p>
<ol>
<li><strong>Test에서 직접 Sequence를 실행하지 않음</strong>: Test는 Sequence를 시작해야지, 직접 <code>start_item/finish_item</code>을 하면 안 됩니다.</li>
<li><strong>시퀀스 재사용 불가</strong>: 쓰기 100번, 읽기 100번이 하드코딩되어 있습니다.</li>
<li><strong>쓰기 후 읽기만 테스트</strong>: 읽기→쓰기, 교차 패턴 등 다양한 시나리오가 없습니다.</li>
<li><strong>커버리지 연결 없음</strong>: 테스트 결과를 측정할 수 없습니다.</li>
</ol>
<p><strong>개선된 코드:</strong></p>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// 1. 재사용 가능한 Sequence 분리</span>
<span class="hljs-keyword">class</span> apb_write_seq <span class="hljs-keyword">extends</span> uvm_sequence <span class="hljs-variable">#(apb_seq_item)</span>;
  `uvm_object_utils(apb_write_seq)  <span class="hljs-comment">// Sequence는 uvm_object_utils!</span>
  <span class="hljs-keyword">rand</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">100</span>;

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> body();
    <span class="hljs-keyword">repeat</span>(count) <span class="hljs-keyword">begin</span>
      req = apb_seq_item::type_id::create(<span class="hljs-string">&quot;req&quot;</span>);
      start_item(req);
      req<span class="hljs-variable">.randomize</span>() <span class="hljs-keyword">with</span> { pwrite == <span class="hljs-number">1</span>; };
      finish_item(req);
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>

<span class="hljs-comment">// 2. 테스트는 Sequence만 시작</span>
<span class="hljs-keyword">class</span> improved_test <span class="hljs-keyword">extends</span> uvm_test;
  `uvm_component_utils(improved_test)  <span class="hljs-comment">// Test는 uvm_component_utils!</span>
  apb_env env;

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);
    env = apb_env::type_id::create(<span class="hljs-string">&quot;env&quot;</span>, <span class="hljs-keyword">this</span>);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> run_phase(uvm_phase phase);
    apb_write_seq   wr_seq = apb_write_seq::type_id::create(<span class="hljs-string">&quot;wr_seq&quot;</span>);
    apb_read_seq    rd_seq = apb_read_seq::type_id::create(<span class="hljs-string">&quot;rd_seq&quot;</span>);
    apb_mixed_seq   mx_seq = apb_mixed_seq::type_id::create(<span class="hljs-string">&quot;mx_seq&quot;</span>);

    phase<span class="hljs-variable">.raise_objection</span>(<span class="hljs-keyword">this</span>);
    wr_seq<span class="hljs-variable">.start</span>(env<span class="hljs-variable">.agent</span><span class="hljs-variable">.sequencer</span>);  <span class="hljs-comment">// 쓰기</span>
    rd_seq<span class="hljs-variable">.start</span>(env<span class="hljs-variable">.agent</span><span class="hljs-variable">.sequencer</span>);  <span class="hljs-comment">// 읽기</span>
    mx_seq<span class="hljs-variable">.start</span>(env<span class="hljs-variable">.agent</span><span class="hljs-variable">.sequencer</span>);  <span class="hljs-comment">// 혼합</span>
    phase<span class="hljs-variable">.drop_objection</span>(<span class="hljs-keyword">this</span>);
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>
</code></pre><p><strong>핵심</strong>: Test는 <strong>시나리오 조합</strong>만 담당, 세부 구현은 Sequence에 위임.</p>
</details>

<h3 id="15-3-3-라이브-코딩-팁">15.3.3 라이브 코딩 팁</h3>
<p>면접에서 화이트보드나 화면 공유로 코드를 작성할 때:</p>
<table>
<thead>
<tr>
<th>팁</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td><strong>뼈대 먼저</strong></td>
<td>클래스 선언, 생성자, Phase 메서드 틀을 먼저 작성</td>
</tr>
<tr>
<td><strong>주석으로 설명</strong></td>
<td>코드 전에 &quot;여기서 ~를 할 겁니다&quot; 주석을 먼저 작성</td>
</tr>
<tr>
<td><strong>매크로 잊지 않기</strong></td>
<td>component는 <code>`uvm_component_utils</code>, object는 <code>`uvm_object_utils</code></td>
</tr>
<tr>
<td><strong>super 호출</strong></td>
<td><code>build_phase</code>, <code>connect_phase</code>에서 <code>super</code> 호출 습관</td>
</tr>
<tr>
<td><strong>이름 규칙</strong></td>
<td><code>uart_driver</code>, <code>apb_monitor</code> 같은 명확한 네이밍</td>
</tr>
<tr>
<td><strong>완벽하지 않아도 됨</strong></td>
<td>전체 로직 흐름을 보여주는 것이 중요</td>
</tr>
</tbody></table>
<pre><code class="hljs language-systemverilog"><span class="hljs-comment">// 라이브 코딩 작성 순서 예시</span>
<span class="hljs-comment">// Step 1: 클래스 뼈대</span>
<span class="hljs-keyword">class</span> my_driver <span class="hljs-keyword">extends</span> uvm_driver <span class="hljs-variable">#(my_item)</span>;
  `uvm_component_utils(my_driver)
  <span class="hljs-keyword">virtual</span> my_if vif;

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-comment">// Step 2: build_phase — config_db에서 vif 가져오기</span>
  <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);
    <span class="hljs-keyword">if</span> (!uvm_config_db<span class="hljs-variable">#(virtual my_if)::get(this, &quot;&quot;, &quot;vif&quot;, vif))</span>
      `uvm_fatal(get_type_name(), <span class="hljs-string">&quot;vif를 가져올 수 없습니다&quot;</span>)
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-comment">// Step 3: run_phase — 핵심 드라이빙 로직</span>
  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> run_phase(uvm_phase phase);
    <span class="hljs-keyword">forever</span> <span class="hljs-keyword">begin</span>
      seq_item_port<span class="hljs-variable">.get_next_item</span>(req);
      <span class="hljs-comment">// 여기서 프로토콜에 맞게 신호를 구동합니다</span>
      @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span>);
      vif<span class="hljs-variable">.data</span> &lt;= req<span class="hljs-variable">.data</span>;
      seq_item_port<span class="hljs-variable">.item_done</span>();
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>
</code></pre><hr>
<h2 id="15-4-포트폴리오-프로젝트-구성">15.4 포트폴리오 프로젝트 구성</h2>
<blockquote>
<p><strong>이 절의 목표</strong>: Ch.11~14에서 만든 APB 검증 환경을 GitHub 포트폴리오로 정리하여 취업에 활용합니다.</p>
</blockquote>
<h3 id="15-4-1-ch-11-14-apb-프로젝트를-포트폴리오로">15.4.1 Ch.11~14 APB 프로젝트를 포트폴리오로</h3>
<p>이 책을 통해 만든 APB 검증 환경은 <strong>이미 포트폴리오가 될 수 있는 수준</strong>입니다. 포함된 기술:</p>
<table>
<thead>
<tr>
<th>챕터</th>
<th>기술</th>
<th>포트폴리오에서 어필 포인트</th>
</tr>
</thead>
<tbody><tr>
<td>Ch.11</td>
<td>APB Agent (Driver/Monitor/Sequencer)</td>
<td>&quot;UVM Agent를 처음부터 구축한 경험&quot;</td>
</tr>
<tr>
<td>Ch.12</td>
<td>RAL (Register Abstraction Layer)</td>
<td>&quot;레지스터 모델을 직접 작성한 경험&quot;</td>
</tr>
<tr>
<td>Ch.13</td>
<td>Virtual Sequence</td>
<td>&quot;다중 Agent 환경을 설계한 경험&quot;</td>
</tr>
<tr>
<td>Ch.14</td>
<td>Coverage + Assertion</td>
<td>&quot;커버리지 기반 검증 방법론 경험&quot;</td>
</tr>
</tbody></table>
<blockquote>
<p>💡 <strong>비유</strong>: 이력서가 <strong>&quot;설계도&quot;</strong>(내가 무엇을 할 수 있는지 설명)라면, 포트폴리오는 <strong>&quot;완성된 건물&quot;</strong>(실제로 해봤다는 증거)입니다. 면접관은 설계도보다 건물을 보고 싶어합니다.</p>
</blockquote>
<h3 id="15-4-2-github-저장소-구조와-readme">15.4.2 GitHub 저장소 구조와 README</h3>
<p><strong>권장 저장소 구조:</strong></p>

<div class="svg-diagram">
<svg viewBox="0 0 700 480" xmlns="http://www.w3.org/2000/svg" style="max-width:700px;width:100%">
  
  <style>
    .diagram-box { fill: #ffffff; stroke: #334155; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-accent { fill: #eff6ff; stroke: #2563eb; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-highlight { fill: #fef3c7; stroke: #f59e0b; stroke-width: 2.5; rx: 10; ry: 10; }
    .diagram-box-dark { fill: #1e293b; stroke: #1e293b; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-run { fill: #fef3c7; stroke: #f59e0b; stroke-width: 3; rx: 10; ry: 10; }
    .diagram-box-green { fill: #ecfdf5; stroke: #10b981; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-purple { fill: #f5f3ff; stroke: #7c3aed; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-red { fill: #fef2f2; stroke: #ef4444; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-gray { fill: #f8fafc; stroke: #94a3b8; stroke-width: 1.5; rx: 8; ry: 8; }
    .diagram-text { font-family: 'Noto Sans KR', sans-serif; fill: #1e293b; }
    .diagram-text-white { font-family: 'Noto Sans KR', sans-serif; fill: #ffffff; }
    .diagram-text-accent { font-family: 'Noto Sans KR', sans-serif; fill: #2563eb; }
    .diagram-text-small { font-family: 'Noto Sans KR', sans-serif; fill: #64748b; font-size: 12px; }
    .diagram-text-code { font-family: 'Fira Code', 'JetBrains Mono', monospace; fill: #1e293b; }
    .diagram-arrow { fill: none; stroke: #64748b; stroke-width: 1.5; }
    .diagram-arrow-accent { fill: none; stroke: #2563eb; stroke-width: 1.5; }
    .diagram-line { stroke: #cbd5e1; stroke-width: 1.5; stroke-dasharray: 6,3; }
  </style>
  <defs>
    <marker id="arrowhead" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#64748b" />
    </marker>
    <marker id="arrowhead-accent" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#2563eb" />
    </marker>
    <marker id="arrowhead-dark" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#1e293b" />
    </marker>
    <marker id="arrowhead-orange" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#f59e0b" />
    </marker>
    <filter id="shadow" x="-5%" y="-5%" width="115%" height="115%">
      <feDropShadow dx="0" dy="2" stdDeviation="3" flood-color="#000" flood-opacity="0.1"/>
    </filter>
  </defs>

  <!-- Title -->
  <rect x="10" y="10" width="680" height="36" rx="10" ry="10" fill="#1e293b"/>
  <text x="350" y="34" text-anchor="middle" class="diagram-text-white" font-size="14" font-weight="bold">포트폴리오 GitHub 저장소 구조</text>

  <!-- Root -->
  <text x="30" y="72" class="diagram-text-code" font-size="13" font-weight="bold" fill="#2563eb">apb-uvm-verification/</text>

  <!-- README -->
  <text x="50" y="96" class="diagram-text-code" font-size="12">├── README.md</text>
  <rect x="260" y="83" width="200" height="20" rx="4" fill="#fef3c7" stroke="#f59e0b" stroke-width="1"/>
  <text x="270" y="97" class="diagram-text" font-size="10" fill="#92400e">프로젝트 소개 (가장 중요!)</text>

  <!-- docs/ -->
  <text x="50" y="120" class="diagram-text-code" font-size="12">├── docs/</text>
  <text x="70" y="140" class="diagram-text-code" font-size="11" fill="#64748b">│   ├── verification_plan.md</text>
  <text x="70" y="158" class="diagram-text-code" font-size="11" fill="#64748b">│   ├── coverage_report.md</text>
  <text x="70" y="176" class="diagram-text-code" font-size="11" fill="#64748b">│   └── architecture.md</text>

  <!-- rtl/ -->
  <text x="50" y="200" class="diagram-text-code" font-size="12">├── rtl/</text>
  <rect x="130" y="187" width="80" height="20" rx="4" fill="#fef2f2" stroke="#ef4444" stroke-width="1"/>
  <text x="140" y="201" class="diagram-text" font-size="10" fill="#991b1b">DUT</text>
  <text x="70" y="220" class="diagram-text-code" font-size="11" fill="#64748b">│   └── apb_slave_memory.sv</text>

  <!-- tb/ -->
  <text x="50" y="244" class="diagram-text-code" font-size="12">├── tb/</text>
  <rect x="120" y="231" width="150" height="20" rx="4" fill="#eff6ff" stroke="#2563eb" stroke-width="1"/>
  <text x="130" y="245" class="diagram-text" font-size="10" fill="#1e40af">UVM 검증 컴포넌트</text>
  <text x="70" y="264" class="diagram-text-code" font-size="11" fill="#64748b">│   ├── apb_if.sv          (Interface)</text>
  <text x="70" y="282" class="diagram-text-code" font-size="11" fill="#64748b">│   ├── apb_seq_item.sv    (Transaction)</text>
  <text x="70" y="300" class="diagram-text-code" font-size="11" fill="#64748b">│   ├── apb_driver.sv      (Driver)</text>
  <text x="70" y="318" class="diagram-text-code" font-size="11" fill="#64748b">│   ├── apb_monitor.sv     (Monitor)</text>
  <text x="70" y="336" class="diagram-text-code" font-size="11" fill="#64748b">│   ├── apb_agent.sv       (Agent)</text>
  <text x="70" y="354" class="diagram-text-code" font-size="11" fill="#64748b">│   ├── apb_scoreboard.sv  (Scoreboard)</text>
  <text x="70" y="372" class="diagram-text-code" font-size="11" fill="#64748b">│   ├── apb_coverage.sv    (Coverage)</text>
  <text x="70" y="390" class="diagram-text-code" font-size="11" fill="#64748b">│   ├── apb_reg_model.sv   (RAL)</text>
  <text x="70" y="408" class="diagram-text-code" font-size="11" fill="#64748b">│   └── apb_env.sv         (Environment)</text>

  <!-- tests/ -->
  <text x="50" y="432" class="diagram-text-code" font-size="12">├── tests/</text>
  <rect x="140" y="419" width="100" height="20" rx="4" fill="#ecfdf5" stroke="#10b981" stroke-width="1"/>
  <text x="150" y="433" class="diagram-text" font-size="10" fill="#065f46">테스트 스위트</text>

  <!-- sim/ -->
  <text x="50" y="456" class="diagram-text-code" font-size="12">├── sim/</text>
  <rect x="120" y="443" width="100" height="20" rx="4" fill="#f5f3ff" stroke="#7c3aed" stroke-width="1"/>
  <text x="130" y="457" class="diagram-text" font-size="10" fill="#5b21b6">빌드/실행</text>

  <!-- LICENSE -->
  <text x="50" y="476" class="diagram-text-code" font-size="12">└── LICENSE</text>
</svg>
</div><p><strong>GitHub에 올리는 방법 (step by step):</strong></p>
<pre><code class="hljs language-bash"><span class="hljs-comment"># 1. 저장소 초기화</span>
<span class="hljs-built_in">mkdir</span> apb-uvm-verification
<span class="hljs-built_in">cd</span> apb-uvm-verification
git init

<span class="hljs-comment"># 2. 파일 구조 생성</span>
<span class="hljs-built_in">mkdir</span> -p docs rtl tb tests sim

<span class="hljs-comment"># 3. 코드 파일 복사 (Ch.11~14에서 작성한 파일들)</span>
<span class="hljs-built_in">cp</span> /path/to/apb_slave_memory.sv rtl/
<span class="hljs-built_in">cp</span> /path/to/apb_*.sv tb/
<span class="hljs-built_in">cp</span> /path/to/tests/*.sv tests/

<span class="hljs-comment"># 4. README.md 작성 (아래 템플릿 참고)</span>

<span class="hljs-comment"># 5. 첫 커밋</span>
git add .
git commit -m <span class="hljs-string">&quot;Initial commit: APB UVM verification environment&quot;</span>

<span class="hljs-comment"># 6. GitHub 저장소 생성 후 연결</span>
git remote add origin https://github.com/your-username/apb-uvm-verification.git
git branch -M main
git push -u origin main
</code></pre><p><strong>README.md 템플릿:</strong></p>
<pre><code class="hljs language-markdown"><span class="hljs-section"># APB Slave Memory UVM Verification Environment</span>

<span class="hljs-section">## Overview</span>
AMBA APB 프로토콜 기반 Slave Memory의 UVM 검증 환경입니다.
UVM 1.2 표준을 준수하며, Agent/RAL/Coverage/Assertion을 포함합니다.

<span class="hljs-section">## Architecture</span>
<span class="hljs-code">```
UVM Test
└── Environment
    ├── APB Agent (Active)
    │   ├── Sequencer
    │   ├── Driver
    │   └── Monitor
    ├── RAL Model
    │   └── Adapter
    ├── Scoreboard
    ├── Coverage Collector
    └── Virtual Sequencer
```</span>

<span class="hljs-section">## Features</span>
<span class="hljs-bullet">-</span> <span class="hljs-strong">**APB Agent**</span>: AMBA 3.0 APB 프로토콜 완전 지원
<span class="hljs-bullet">-</span> <span class="hljs-strong">**RAL Model**</span>: 16개 레지스터 추상화, 미러 검증
<span class="hljs-bullet">-</span> <span class="hljs-strong">**Coverage**</span>: 주소/데이터/동작 교차 커버리지 (목표: 95%)
<span class="hljs-bullet">-</span> <span class="hljs-strong">**Assertions**</span>: APB 프로토콜 규칙 5개 SVA 구현
<span class="hljs-bullet">-</span> <span class="hljs-strong">**Test Suite**</span>: Smoke, Random, Directed, Error Injection

<span class="hljs-section">## Results</span>
| 항목 | 결과 |
|------|------|
| 테스트 수 | 15개 |
| Pass Rate | 100% |
| Functional Coverage | 96.1% |
| Assertion Failures | 0 |

<span class="hljs-section">## How to Run</span>
<span class="hljs-code">```bash
# Questa
cd sim &amp;&amp; make questa

# VCS
cd sim &amp;&amp; make vcs
```</span>

<span class="hljs-section">## Skills Demonstrated</span>
<span class="hljs-bullet">-</span> UVM 1.2 Methodology
<span class="hljs-bullet">-</span> SystemVerilog OOP &amp; Constrained Random
<span class="hljs-bullet">-</span> AMBA APB Protocol
<span class="hljs-bullet">-</span> Coverage-Driven Verification
<span class="hljs-bullet">-</span> SVA (SystemVerilog Assertions)
<span class="hljs-bullet">-</span> Register Abstraction Layer (RAL)
</code></pre><h3 id="15-4-3-문서화와-시연-가이드">15.4.3 문서화와 시연 가이드</h3>
<p>포트폴리오에서 <strong>차별화 포인트</strong>가 되는 문서들:</p>
<p><strong>1. 검증 계획서 (Verification Plan)</strong></p>
<pre><code class="hljs language-markdown"><span class="hljs-section">## 검증 계획서 — APB Slave Memory</span>

<span class="hljs-section">### 1. DUT 기능 목록</span>
| 기능     | 설명                 | 검증 방법         |
|----------|----------------------|-------------------|
| 쓰기     | 주소에 데이터 저장   | Directed + Random |
| 읽기     | 주소에서 데이터 반환 | Back-to-back R/W  |
| 프로토콜 | APB 타이밍 준수      | SVA Assertion     |

<span class="hljs-section">### 2. 커버리지 목표</span>
| 항목          | 목표 | 현재  |
|---------------|------|-------|
| 주소 커버리지 | 100% | 100%  |
| 동작 커버리지 | 100% | 100%  |
| 교차 커버리지 | 90%  | 96.1% |
</code></pre><p><strong>2. 커버리지 결과 요약 — 숫자로 증명</strong></p>
<p>면접관이 가장 보고 싶어하는 것은 <strong>결과 숫자</strong>입니다:</p>
<ul>
<li>&quot;커버리지 96.1% 달성&quot;</li>
<li>&quot;15개 테스트 전수 통과&quot;</li>
<li>&quot;랜덤 테스트로 80%, 타겟으로 16.1% 추가&quot;</li>
</ul>
<hr>
<h2 id="15-5-이력서-amp-자기소개서-전략">15.5 이력서 &amp; 자기소개서 전략</h2>
<blockquote>
<p><strong>이 절의 목표</strong>: 검증 엔지니어 이력서를 작성하고, 자기소개서에서 UVM 경험을 효과적으로 어필합니다.</p>
</blockquote>
<h3 id="15-5-1-검증-엔지니어-이력서-작성법">15.5.1 검증 엔지니어 이력서 작성법</h3>
<p>**이력서의 핵심은 &quot;키워드 매칭&quot;**입니다. 채용 담당자는 이력서에서 관련 키워드를 검색합니다.</p>
<p><strong>필수 키워드 목록:</strong></p>
<table>
<thead>
<tr>
<th>카테고리</th>
<th>키워드</th>
</tr>
</thead>
<tbody><tr>
<td><strong>방법론</strong></td>
<td>UVM, SystemVerilog, Constrained Random, Coverage-Driven</td>
</tr>
<tr>
<td><strong>컴포넌트</strong></td>
<td>Agent, Driver, Monitor, Sequencer, Scoreboard, Coverage</td>
</tr>
<tr>
<td><strong>프로토콜</strong></td>
<td>APB, AXI, AHB (경험한 것)</td>
</tr>
<tr>
<td><strong>기법</strong></td>
<td>Factory Pattern, RAL, Virtual Sequence, SVA</td>
</tr>
<tr>
<td><strong>도구</strong></td>
<td>VCS, Questa, Xcelium, Verdi, DVE, SimVision</td>
</tr>
<tr>
<td><strong>프로세스</strong></td>
<td>Coverage Closure, Regression, Bug Tracking</td>
</tr>
<tr>
<td><strong>버전 관리</strong></td>
<td>Git, SVN, GitHub</td>
</tr>
<tr>
<td><strong>운영체제</strong></td>
<td>Linux, Shell Script (Bash/Tcl), Makefile</td>
</tr>
</tbody></table>
<blockquote>
<p>💡 <strong>팁</strong>: Git과 Linux는 이력서에 명시하지 않아도 당연히 사용할 수 있어야 하는 기본 기술입니다. 하지만 신입 이력서에는 명시적으로 포함하는 것이 좋습니다 — 면접관이 &quot;기본기가 있구나&quot;를 확인합니다.</p>
</blockquote>
<p><strong>프로젝트 경험 작성 예시:</strong></p>

<div class="svg-diagram">
<svg viewBox="0 0 700 280" xmlns="http://www.w3.org/2000/svg" style="max-width:700px;width:100%">
  
  <style>
    .diagram-box { fill: #ffffff; stroke: #334155; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-accent { fill: #eff6ff; stroke: #2563eb; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-highlight { fill: #fef3c7; stroke: #f59e0b; stroke-width: 2.5; rx: 10; ry: 10; }
    .diagram-box-dark { fill: #1e293b; stroke: #1e293b; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-run { fill: #fef3c7; stroke: #f59e0b; stroke-width: 3; rx: 10; ry: 10; }
    .diagram-box-green { fill: #ecfdf5; stroke: #10b981; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-purple { fill: #f5f3ff; stroke: #7c3aed; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-red { fill: #fef2f2; stroke: #ef4444; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-gray { fill: #f8fafc; stroke: #94a3b8; stroke-width: 1.5; rx: 8; ry: 8; }
    .diagram-text { font-family: 'Noto Sans KR', sans-serif; fill: #1e293b; }
    .diagram-text-white { font-family: 'Noto Sans KR', sans-serif; fill: #ffffff; }
    .diagram-text-accent { font-family: 'Noto Sans KR', sans-serif; fill: #2563eb; }
    .diagram-text-small { font-family: 'Noto Sans KR', sans-serif; fill: #64748b; font-size: 12px; }
    .diagram-text-code { font-family: 'Fira Code', 'JetBrains Mono', monospace; fill: #1e293b; }
    .diagram-arrow { fill: none; stroke: #64748b; stroke-width: 1.5; }
    .diagram-arrow-accent { fill: none; stroke: #2563eb; stroke-width: 1.5; }
    .diagram-line { stroke: #cbd5e1; stroke-width: 1.5; stroke-dasharray: 6,3; }
  </style>
  <defs>
    <marker id="arrowhead" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#64748b" />
    </marker>
    <marker id="arrowhead-accent" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#2563eb" />
    </marker>
    <marker id="arrowhead-dark" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#1e293b" />
    </marker>
    <marker id="arrowhead-orange" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#f59e0b" />
    </marker>
    <filter id="shadow" x="-5%" y="-5%" width="115%" height="115%">
      <feDropShadow dx="0" dy="2" stdDeviation="3" flood-color="#000" flood-opacity="0.1"/>
    </filter>
  </defs>

  <!-- Title -->
  <text x="350" y="24" text-anchor="middle" class="diagram-text" font-size="15" font-weight="bold">이력서 성과 표현 — 나쁜 예 vs 좋은 예</text>

  <!-- 나쁜 예 (Red) -->
  <rect x="20" y="42" width="310" height="100" rx="10" fill="#fef2f2" stroke="#ef4444" stroke-width="2" filter="url(#shadow)"/>
  <rect x="20" y="42" width="310" height="28" rx="10" fill="#ef4444"/>
  <rect x="20" y="62" width="310" height="4" fill="#ef4444"/>
  <text x="175" y="62" text-anchor="middle" class="diagram-text-white" font-size="12" font-weight="bold">나쁜 예</text>
  <text x="35" y="92" class="diagram-text" font-size="11" fill="#991b1b">&quot;UVM으로 테스트벤치를</text>
  <text x="35" y="110" class="diagram-text" font-size="11" fill="#991b1b">만들었습니다.&quot;</text>
  <text x="35" y="132" class="diagram-text-small" font-size="9" fill="#b91c1c">→ 구체적 대상/수치/결과 없음</text>

  <!-- 좋은 예 (Green) -->
  <rect x="370" y="42" width="310" height="220" rx="10" fill="#ecfdf5" stroke="#10b981" stroke-width="2" filter="url(#shadow)"/>
  <rect x="370" y="42" width="310" height="28" rx="10" fill="#10b981"/>
  <rect x="370" y="62" width="310" height="4" fill="#10b981"/>
  <text x="525" y="62" text-anchor="middle" class="diagram-text-white" font-size="12" font-weight="bold">좋은 예</text>
  <text x="385" y="90" class="diagram-text" font-size="11" fill="#065f46">&quot;APB Slave Memory에 대한</text>
  <text x="385" y="108" class="diagram-text" font-size="11" fill="#065f46">UVM 검증 환경을 구축하였습니다.&quot;</text>
  <text x="395" y="134" class="diagram-text" font-size="10" fill="#047857">• UVM 1.2 기반 Agent 설계 및 구현</text>
  <text x="395" y="154" class="diagram-text" font-size="10" fill="#047857">• RAL 활용 레지스터 검증 자동화</text>
  <text x="395" y="174" class="diagram-text" font-size="10" fill="#047857">• Functional Coverage 96.1% 달성</text>
  <text x="395" y="194" class="diagram-text" font-size="10" fill="#047857">• 5개 SVA 어서션 프로토콜 검증</text>
  <text x="385" y="220" class="diagram-text-small" font-size="9" fill="#059669">→ 키워드 + 비율 사용</text>
  <text x="385" y="236" class="diagram-text-small" font-size="9" fill="#059669">→ 구체적 대상 + 수치 결과 명시</text>
  <text x="385" y="252" class="diagram-text-small" font-size="9" fill="#059669">→ 기술 스택 자연스럽게 노출</text>

  <!-- Arrow -->
  <text x="345" y="100" text-anchor="middle" font-size="24" fill="#94a3b8">→</text>

  <!-- Bottom label: 나쁜예 박스 크기 맞추기 -->
  <rect x="20" y="152" width="310" height="110" rx="10" fill="#fef2f2" stroke="#fca5a5" stroke-width="1" stroke-dasharray="4,3"/>
  <text x="175" y="176" text-anchor="middle" class="diagram-text-small" font-size="10" fill="#dc2626">문제점:</text>
  <text x="35" y="196" class="diagram-text-small" font-size="9" fill="#b91c1c">• 어떤 DUT인지 불명확</text>
  <text x="35" y="214" class="diagram-text-small" font-size="9" fill="#b91c1c">• 기술 수준 판단 불가</text>
  <text x="35" y="232" class="diagram-text-small" font-size="9" fill="#b91c1c">• 성과/결과 없음</text>
  <text x="35" y="250" class="diagram-text-small" font-size="9" fill="#b91c1c">• 키워드 부족 → 서류 탈락</text>
</svg>
</div><blockquote>
<p>💡 <strong>핵심</strong>: <strong>구체적 숫자</strong>와 <strong>기술 용어</strong>를 사용하세요. &quot;검증을 했다&quot;가 아니라 &quot;Coverage 96.1%를 달성했다&quot;입니다.</p>
</blockquote>
<h3 id="15-5-2-기술-키워드와-성과-표현">15.5.2 기술 키워드와 성과 표현</h3>
<p>이력서에서 <strong>동사 선택</strong>이 중요합니다:</p>
<table>
<thead>
<tr>
<th>강한 동사</th>
<th>예시</th>
</tr>
</thead>
<tbody><tr>
<td><strong>설계</strong></td>
<td>&quot;UVM 검증 환경을 설계하였습니다&quot;</td>
</tr>
<tr>
<td><strong>구현</strong></td>
<td>&quot;APB Agent를 구현하였습니다&quot;</td>
</tr>
<tr>
<td><strong>달성</strong></td>
<td>&quot;Functional Coverage 96%를 달성하였습니다&quot;</td>
</tr>
<tr>
<td><strong>자동화</strong></td>
<td>&quot;커버리지 수집을 자동화하였습니다&quot;</td>
</tr>
<tr>
<td><strong>분석</strong></td>
<td>&quot;커버리지 홀을 분석하여 타겟 시퀀스를 작성하였습니다&quot;</td>
</tr>
</tbody></table>
<p><strong>성과 표현 공식: 동사 + 대상 + 수치/결과</strong></p>
<pre><code>&quot;RAL을 활용한 레지스터 검증을 자동화하여 검증 효율을 향상시켰습니다&quot;
&quot;5개의 APB 프로토콜 어서션으로 타이밍 위반을 자동 검출하였습니다&quot;
&quot;Constrained Random과 Directed 테스트 조합으로 Coverage Closure를 달성하였습니다&quot;
</code></pre><h3 id="15-5-3-자기소개서에서-uvm-경험-어필">15.5.3 자기소개서에서 UVM 경험 어필</h3>
<p>자기소개서에서 UVM 프로젝트를 설명하는 <strong>STAR 기법</strong>:</p>
<table>
<thead>
<tr>
<th>단계</th>
<th>내용</th>
<th>예시</th>
</tr>
</thead>
<tbody><tr>
<td><strong>S</strong>(Situation)</td>
<td>상황</td>
<td>&quot;APB Slave Memory를 검증해야 하는 상황에서&quot;</td>
</tr>
<tr>
<td><strong>T</strong>(Task)</td>
<td>과제</td>
<td>&quot;UVM 기반 자동화 검증 환경을 구축하는 것이 목표였습니다&quot;</td>
</tr>
<tr>
<td><strong>A</strong>(Action)</td>
<td>행동</td>
<td>&quot;Agent, RAL, Coverage Collector, Assertion을 설계하고 구현했습니다&quot;</td>
</tr>
<tr>
<td><strong>R</strong>(Result)</td>
<td>결과</td>
<td>&quot;Coverage 96.1% 달성, 15개 테스트 100% 통과&quot;</td>
</tr>
</tbody></table>
<hr>
<h2 id="15-6-실전-면접-시뮬레이션">15.6 실전 면접 시뮬레이션</h2>
<blockquote>
<p><strong>이 절의 목표</strong>: 실제 면접과 유사한 대화를 통해 답변 연습을 합니다.</p>
</blockquote>
<h3 id="15-6-1-1차-기술-면접-시뮬레이션">15.6.1 1차 기술 면접 시뮬레이션</h3>
<blockquote>
<p>상황: 팹리스 반도체 회사의 검증팀 신입 채용 1차 기술 면접</p>
</blockquote>
<p><strong>면접관</strong>: 자기소개와 함께 UVM 프로젝트 경험을 간단히 말씀해주세요.</p>
<p><strong>지원자 모범 답변</strong>:</p>
<blockquote>
<p>&quot;안녕하세요, 전자공학과를 졸업한 [이름]입니다. 졸업 프로젝트로 APB Slave Memory에 대한 UVM 검증 환경을 구축했습니다. Agent, RAL, Coverage Collector, Assertion을 포함한 완전한 환경을 설계했고, Functional Coverage 96%를 달성했습니다.&quot;</p>
</blockquote>
<hr>
<p><strong>면접관</strong>: UVM에서 Factory Pattern이 왜 중요한지 설명해주세요.</p>
<p><strong>지원자 모범 답변</strong>:</p>
<blockquote>
<p>&quot;Factory Pattern은 테스트별로 컴포넌트나 트랜잭션을 교체할 수 있게 해줍니다. 예를 들어 기본 테스트에서는 일반 드라이버를 쓰고, 에러 주입 테스트에서는 에러 드라이버로 교체할 때, 환경 코드를 전혀 수정하지 않고 Factory override 한 줄로 가능합니다. 이것이 UVM의 재사용성을 가능하게 하는 핵심 메커니즘입니다.&quot;</p>
</blockquote>
<hr>
<p><strong>면접관</strong>: Analysis Port와 일반 TLM Port의 차이를 설명해주세요.</p>
<p><strong>지원자 모범 답변</strong>:</p>
<blockquote>
<p>&quot;일반 TLM Port는 1:1 통신이고 blocking이 가능합니다. 반면 Analysis Port는 1:N 브로드캐스트입니다. Monitor가 트랜잭션을 캡처하면 Scoreboard, Coverage Collector 등 여러 구독자에게 동시에 전달됩니다. 연결된 구독자가 없어도 에러가 나지 않는 점도 차이입니다. write() 호출 시 모든 구독자의 write()가 순차적으로 호출되지만 포트 레벨에서는 non-blocking입니다.&quot;</p>
</blockquote>
<hr>
<p><strong>면접관</strong>: 이 코드에서 문제를 찾아보세요. (화면에 코드 표시)</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-keyword">class</span> my_test <span class="hljs-keyword">extends</span> uvm_test;
  my_env env;
  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> run_phase(uvm_phase phase);
    my_seq seq = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;seq&quot;</span>);
    seq<span class="hljs-variable">.start</span>(env<span class="hljs-variable">.agent</span><span class="hljs-variable">.sequencer</span>);
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>
</code></pre><p><strong>지원자 모범 답변</strong>:</p>
<blockquote>
<p>&quot;세 가지 문제가 있습니다. 첫째, <code>phase.raise_objection(this)</code>가 없어서 시뮬레이션이 즉시 종료됩니다. 둘째, Sequence를 <code>new()</code>로 생성했는데, Factory를 통해 <code>create()</code>로 생성해야 나중에 override가 가능합니다. 셋째, <code> `uvm_component_utils</code> 매크로가 없어서 이 Test 클래스 자체도 Factory에 등록되지 않습니다.&quot;</p>
</blockquote>
<hr>
<p><strong>면접관</strong>: Coverage Closure는 어떻게 진행하나요?</p>
<p><strong>지원자 모범 답변</strong>:</p>
<blockquote>
<p>&quot;먼저 Constrained Random 테스트를 대량 실행하여 기본 커버리지를 채웁니다. 보통 80% 정도까지 올라갑니다. 그 다음 커버리지 리포트를 분석하여 미달 항목을 찾고, 그 항목을 타겟하는 Directed 시퀀스를 작성합니다. 이 과정을 반복하여 목표 커버리지에 도달합니다. 실제 프로젝트에서 100% 달성이 어려운 경우에는 waiver 문서를 작성하여 달성 불가 사유를 기록합니다.&quot;</p>
</blockquote>
<h3 id="15-6-2-2차-심층-면접-시뮬레이션">15.6.2 2차 심층 면접 시뮬레이션</h3>
<blockquote>
<p>상황: 2차 면접은 팀 리드나 시니어 엔지니어가 진행. 더 깊은 기술 + 문제 해결 능력 평가</p>
</blockquote>
<p><strong>면접관</strong>: 새로운 SPI IP의 검증 환경을 처음부터 구축한다면, 어떤 순서로 진행하시겠습니까?</p>
<p><strong>지원자 모범 답변</strong>:</p>
<blockquote>
<p>&quot;먼저 SPI 프로토콜 스펙을 분석하여 인터페이스 신호와 프로토콜 규칙을 정리합니다. 다음으로 <code>spi_seq_item</code>을 정의하여 MOSI/MISO 데이터, 클록 극성(CPOL), 클록 위상(CPHA) 등을 필드로 선언합니다.</p>
<p>그 다음 SPI Agent를 구축합니다. Driver는 SPI 프로토콜에 맞게 SCK, MOSI 신호를 구동하고, Monitor는 MISO를 관찰하여 트랜잭션을 재구성합니다. Scoreboard는 전송한 데이터와 수신한 데이터를 비교합니다.</p>
<p>Smoke test로 기본 송수신을 검증한 후, CPOL/CPHA 4가지 모드, 다양한 데이터 길이, 연속 전송 등의 시나리오를 추가합니다. Coverage는 모드별, 데이터 크기별, 에러 조건별로 정의하고, Assertion으로 SCK 타이밍과 CS 활성화 규칙을 검증합니다.&quot;</p>
</blockquote>
<hr>
<p><strong>면접관</strong>: 시뮬레이션 중 Scoreboard에서 mismatch가 발생했는데, DUT 버그인지 테스트벤치 버그인지 어떻게 구분하시겠습니까?</p>
<p><strong>지원자 모범 답변</strong>:</p>
<blockquote>
<p>&quot;먼저 파형을 확인하여 DUT 인터페이스의 실제 신호를 봅니다. Monitor가 캡처한 트랜잭션과 실제 신호가 일치하는지 확인합니다. 만약 Monitor가 잘못 캡처했다면 테스트벤치 버그이고, 신호 자체가 잘못되었다면 DUT 버그입니다.</p>
<p>다음으로 Scoreboard의 참조 모델 로직을 검증합니다. 단순한 케이스(주소 0에 0xFF 쓰고 읽기)로 Scoreboard 동작을 확인합니다. 참조 모델이 정확한데 mismatch가 나면 DUT 버그입니다.</p>
<p>최종적으로 시뮬레이터의 wave dump 기능으로 DUT 내부 신호를 추적하여 어느 시점에서 데이터가 달라지는지 찾습니다.&quot;</p>
</blockquote>
<hr>
<p><strong>면접관</strong>: 마지막으로 질문 있으신가요?</p>
<blockquote>
<p>💡 <strong>팁</strong>: 반드시 질문을 준비하세요! 좋은 질문 예시:</p>
</blockquote>
<table>
<thead>
<tr>
<th>좋은 질문</th>
<th>인상</th>
</tr>
</thead>
<tbody><tr>
<td>&quot;팀에서 주로 사용하는 프로토콜과 VIP는 무엇인가요?&quot;</td>
<td>실무 관심</td>
</tr>
<tr>
<td>&quot;신입에게 기대하는 첫 3개월 목표가 있나요?&quot;</td>
<td>적극적 자세</td>
</tr>
<tr>
<td>&quot;코드 리뷰 문화가 있나요?&quot;</td>
<td>성장 의지</td>
</tr>
<tr>
<td>&quot;커버리지 클로저 목표는 보통 몇 %인가요?&quot;</td>
<td>전문성</td>
</tr>
</tbody></table>
<h3 id="15-6-3-면접-후-팔로업">15.6.3 면접 후 팔로업</h3>
<p>면접이 끝난 후에도 해야 할 일이 있습니다:</p>
<ol>
<li><p><strong>감사 이메일</strong> (당일 또는 다음 날):</p>
<ul>
<li>면접 기회에 대한 감사</li>
<li>면접에서 논의한 핵심 주제 언급</li>
<li>팀에 기여하고 싶다는 의지</li>
</ul>
</li>
<li><p><strong>처우 협의 준비</strong>:</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>항목</th>
<th>확인 사항</th>
</tr>
</thead>
<tbody><tr>
<td>연봉</td>
<td>업계 평균 확인 (반도체 검증 신입 기준)</td>
</tr>
<tr>
<td>성과급</td>
<td>연봉 외 보너스 구조</td>
</tr>
<tr>
<td>교육 지원</td>
<td>학회, 교육, 자격증 지원 여부</td>
</tr>
<tr>
<td>장비</td>
<td>개발 환경, 시뮬레이터 라이선스</td>
</tr>
<tr>
<td>성장 경로</td>
<td>시니어 엔지니어 → 팀 리드 경로</td>
</tr>
</tbody></table>
<hr>
<h2 id="15-7-체크포인트">15.7 체크포인트</h2>
<blockquote>
<p><strong>이 절의 목표</strong>: 면접 준비 상태를 점검하고, 전체 책 학습을 마무리합니다.</p>
</blockquote>
<h3 id="15-7-1-셀프-체크">15.7.1 셀프 체크</h3>
<p>다음 질문에 자신 있게 답할 수 있는지 확인하세요:</p>
<table>
<thead>
<tr>
<th>번호</th>
<th>질문</th>
<th>자신감</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Factory Pattern의 목적과 create()를 쓰는 이유를 설명할 수 있는가?</td>
<td>☐</td>
</tr>
<tr>
<td>2</td>
<td>UVM Phase의 종류와 build/connect/run의 차이를 설명할 수 있는가?</td>
<td>☐</td>
</tr>
<tr>
<td>3</td>
<td>Analysis Port의 1:N 브로드캐스트 동작을 설명할 수 있는가?</td>
<td>☐</td>
</tr>
<tr>
<td>4</td>
<td>UVM 코드를 보고 3가지 이상의 문제를 찾을 수 있는가?</td>
<td>☐</td>
</tr>
<tr>
<td>5</td>
<td>포트폴리오 프로젝트의 핵심 기술을 3분 안에 설명할 수 있는가?</td>
<td>☐</td>
</tr>
<tr>
<td>6</td>
<td>Coverage Closure 프로세스를 단계별로 설명할 수 있는가?</td>
<td>☐</td>
</tr>
</tbody></table>
<blockquote>
<p>6개 모두 체크했다면 <strong>면접 준비 완료</strong>입니다!</p>
</blockquote>
<h3 id="15-7-2-연습문제">15.7.2 연습문제</h3>
<p><strong>문제 1 (쉬움): 면접 답변 작성</strong></p>
<p>다음 질문에 대해 &quot;핵심 → 이유 → 예시&quot; 구조로 답변을 작성하세요:
&quot;UVM에서 Sequence와 Transaction의 차이는 무엇인가요?&quot;</p>
<details>
<summary>모범 답안 보기</summary>

<p>Transaction(<code>uvm_sequence_item</code>)은 <strong>데이터의 단위</strong>이고, Sequence(<code>uvm_sequence</code>)는 <strong>여러 Transaction을 순서대로 생성하는 시나리오</strong>입니다. Transaction이 &quot;편지 한 장&quot;이라면, Sequence는 &quot;편지를 쓰는 과정(초안→수정→발송)&quot;입니다.</p>
<p>예를 들어 APB 쓰기 트랜잭션에는 주소와 데이터가 들어있고, APB 쓰기 시퀀스는 이 트랜잭션을 10번 반복 생성하여 연속 쓰기 테스트를 수행합니다.</p>
<p>참고: Transaction은 <code> `uvm_object_utils</code>로 등록하고, Sequence도 <code> `uvm_object_utils</code>로 등록합니다 — 둘 다 <code>uvm_object</code> 계열입니다.</p>
</details>

<p><strong>문제 2 (보통): 코드 리뷰 연습</strong></p>
<p>다음 코드에서 문제점을 모두 찾고 수정하세요:</p>
<pre><code class="hljs language-systemverilog"><span class="hljs-keyword">class</span> apb_monitor <span class="hljs-keyword">extends</span> uvm_monitor;
  <span class="hljs-keyword">virtual</span> apb_if vif;
  uvm_analysis_port <span class="hljs-variable">#(apb_seq_item)</span> ap;

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> run_phase(uvm_phase phase);
    apb_seq_item item;
    <span class="hljs-keyword">forever</span> <span class="hljs-keyword">begin</span>
      @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span> <span class="hljs-keyword">iff</span> vif<span class="hljs-variable">.psel</span>);
      item = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;item&quot;</span>);
      item<span class="hljs-variable">.paddr</span>  = vif<span class="hljs-variable">.paddr</span>;
      item<span class="hljs-variable">.pwdata</span> = vif<span class="hljs-variable">.pwdata</span>;
      item<span class="hljs-variable">.pwrite</span> = vif<span class="hljs-variable">.pwrite</span>;
      ap<span class="hljs-variable">.write</span>(item);
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>
</code></pre><details>
<summary>정답 보기</summary>

<ol>
<li><strong><code>`uvm_component_utils</code> 누락</strong> — Factory 미등록 (Monitor는 component이므로 <code>uvm_component_utils</code>)</li>
<li><strong><code>build_phase</code> 없음</strong> — <code>ap</code>를 생성하지 않음, <code>vif</code>를 <code>config_db</code>에서 가져오지 않음</li>
<li><strong><code>item = new(&quot;item&quot;)</code> → <code>create()</code> 사용</strong> — Factory를 통해 생성해야 함</li>
<li><strong>APB Access phase 미대기</strong> — <code>psel</code> 후 <code>penable</code>이 올라가는 Access phase 완료를 기다려야 실제 데이터를 캡처</li>
<li><strong>읽기 시 <code>prdata</code> 캡처 누락</strong> — <code>pwrite==0</code>일 때 <code>prdata</code>도 캡처해야 함</li>
</ol>
<pre><code class="hljs language-systemverilog"><span class="hljs-keyword">class</span> apb_monitor <span class="hljs-keyword">extends</span> uvm_monitor;
  `uvm_component_utils(apb_monitor)  <span class="hljs-comment">// (1) Factory 등록</span>
  <span class="hljs-keyword">virtual</span> apb_if vif;
  uvm_analysis_port <span class="hljs-variable">#(apb_seq_item)</span> ap;

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">string</span> name, uvm_component parent);
    <span class="hljs-keyword">super</span><span class="hljs-variable">.new</span>(name, parent);
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">void</span> build_phase(uvm_phase phase);  <span class="hljs-comment">// (2) build_phase 추가</span>
    <span class="hljs-keyword">super</span><span class="hljs-variable">.build_phase</span>(phase);
    ap = <span class="hljs-keyword">new</span>(<span class="hljs-string">&quot;ap&quot;</span>, <span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">if</span> (!uvm_config_db<span class="hljs-variable">#(virtual apb_if)::get(this, &quot;&quot;, &quot;vif&quot;, vif))</span>
      `uvm_fatal(get_type_name(), <span class="hljs-string">&quot;vif not found&quot;</span>)
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> run_phase(uvm_phase phase);
    apb_seq_item item;
    <span class="hljs-keyword">forever</span> <span class="hljs-keyword">begin</span>
      @(<span class="hljs-keyword">posedge</span> vif<span class="hljs-variable">.clk</span> <span class="hljs-keyword">iff</span> (vif<span class="hljs-variable">.psel</span> &amp;&amp; vif<span class="hljs-variable">.penable</span>));  <span class="hljs-comment">// (4) Access phase</span>
      item = apb_seq_item::type_id::create(<span class="hljs-string">&quot;item&quot;</span>);       <span class="hljs-comment">// (3) Factory</span>
      item<span class="hljs-variable">.paddr</span>  = vif<span class="hljs-variable">.paddr</span>;
      item<span class="hljs-variable">.pwdata</span> = vif<span class="hljs-variable">.pwdata</span>;
      item<span class="hljs-variable">.pwrite</span> = vif<span class="hljs-variable">.pwrite</span>;
      <span class="hljs-keyword">if</span> (!vif<span class="hljs-variable">.pwrite</span>) item<span class="hljs-variable">.prdata</span> = vif<span class="hljs-variable">.prdata</span>;           <span class="hljs-comment">// (5) 읽기 데이터</span>
      ap<span class="hljs-variable">.write</span>(item);
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>
</code></pre></details>

<p><strong>문제 3 (어려움): 포트폴리오 README 작성</strong></p>
<p>Ch.11~14에서 만든 APB 검증 환경에 대한 GitHub README.md를 직접 작성하세요. 다음 항목을 포함해야 합니다:</p>
<ul>
<li>프로젝트 개요 (3문장)</li>
<li>아키텍처 다이어그램 (ASCII)</li>
<li>주요 기능 (5개 이상)</li>
<li>검증 결과 (숫자 포함)</li>
<li>실행 방법</li>
</ul>
<details>
<summary>모범 답안 보기</summary>

<p>15.4.2의 README 템플릿을 참고하여, 자신만의 문장으로 재구성하세요. 핵심은 <strong>숫자</strong>와 <strong>구체적 기술 용어</strong>입니다.</p>
</details>

<h3 id="15-7-3-이-챕터에서-배운-것">15.7.3 이 챕터에서 배운 것</h3>
<p>이 챕터에서 준비한 취업 관련 자료:</p>

<div class="svg-diagram">
<svg viewBox="0 0 700 340" xmlns="http://www.w3.org/2000/svg" style="max-width:700px;width:100%">
  
  <style>
    .diagram-box { fill: #ffffff; stroke: #334155; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-accent { fill: #eff6ff; stroke: #2563eb; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-highlight { fill: #fef3c7; stroke: #f59e0b; stroke-width: 2.5; rx: 10; ry: 10; }
    .diagram-box-dark { fill: #1e293b; stroke: #1e293b; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-run { fill: #fef3c7; stroke: #f59e0b; stroke-width: 3; rx: 10; ry: 10; }
    .diagram-box-green { fill: #ecfdf5; stroke: #10b981; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-purple { fill: #f5f3ff; stroke: #7c3aed; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-red { fill: #fef2f2; stroke: #ef4444; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-gray { fill: #f8fafc; stroke: #94a3b8; stroke-width: 1.5; rx: 8; ry: 8; }
    .diagram-text { font-family: 'Noto Sans KR', sans-serif; fill: #1e293b; }
    .diagram-text-white { font-family: 'Noto Sans KR', sans-serif; fill: #ffffff; }
    .diagram-text-accent { font-family: 'Noto Sans KR', sans-serif; fill: #2563eb; }
    .diagram-text-small { font-family: 'Noto Sans KR', sans-serif; fill: #64748b; font-size: 12px; }
    .diagram-text-code { font-family: 'Fira Code', 'JetBrains Mono', monospace; fill: #1e293b; }
    .diagram-arrow { fill: none; stroke: #64748b; stroke-width: 1.5; }
    .diagram-arrow-accent { fill: none; stroke: #2563eb; stroke-width: 1.5; }
    .diagram-line { stroke: #cbd5e1; stroke-width: 1.5; stroke-dasharray: 6,3; }
  </style>
  <defs>
    <marker id="arrowhead" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#64748b" />
    </marker>
    <marker id="arrowhead-accent" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#2563eb" />
    </marker>
    <marker id="arrowhead-dark" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#1e293b" />
    </marker>
    <marker id="arrowhead-orange" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#f59e0b" />
    </marker>
    <filter id="shadow" x="-5%" y="-5%" width="115%" height="115%">
      <feDropShadow dx="0" dy="2" stdDeviation="3" flood-color="#000" flood-opacity="0.1"/>
    </filter>
  </defs>

  <!-- Title -->
  <rect x="10" y="10" width="680" height="36" rx="10" ry="10" fill="#1e293b"/>
  <text x="350" y="34" text-anchor="middle" class="diagram-text-white" font-size="14" font-weight="bold">면접 &amp; 포트폴리오 준비 현황</text>

  <!-- Category 1: 면접 대비 -->
  <rect x="20" y="60" width="210" height="260" class="diagram-box-accent" filter="url(#shadow)"/>
  <rect x="20" y="60" width="210" height="28" rx="10" ry="10" fill="#2563eb" stroke="#2563eb"/>
  <rect x="20" y="80" width="210" height="4" fill="#2563eb"/>
  <text x="125" y="80" text-anchor="middle" class="diagram-text-white" font-size="12" font-weight="bold">면접 대비</text>

  <rect x="35" y="100" width="180" height="46" rx="6" fill="#ffffff" stroke="#cbd5e1" stroke-width="1"/>
  <text x="45" y="118" class="diagram-text" font-size="11">UVM 빈출 질문 30선</text>
  <text x="45" y="135" class="diagram-text-small" font-size="9">+ 접이식 모범 답안</text>

  <rect x="35" y="156" width="180" height="46" rx="6" fill="#ffffff" stroke="#cbd5e1" stroke-width="1"/>
  <text x="45" y="174" class="diagram-text" font-size="11">코드 리뷰 문제 3세트</text>
  <text x="45" y="191" class="diagram-text-small" font-size="9">쉬움 / 보통 / 어려움</text>

  <rect x="35" y="212" width="180" height="46" rx="6" fill="#ffffff" stroke="#cbd5e1" stroke-width="1"/>
  <text x="45" y="230" class="diagram-text" font-size="11">면접 시뮬레이션 2세트</text>
  <text x="45" y="247" class="diagram-text-small" font-size="9">1차 기술 / 2차 심층</text>

  <!-- Category 2: 포트폴리오 -->
  <rect x="245" y="60" width="210" height="260" class="diagram-box-green" filter="url(#shadow)"/>
  <rect x="245" y="60" width="210" height="28" rx="10" ry="10" fill="#10b981" stroke="#10b981"/>
  <rect x="245" y="80" width="210" height="4" fill="#10b981"/>
  <text x="350" y="80" text-anchor="middle" class="diagram-text-white" font-size="12" font-weight="bold">포트폴리오</text>

  <rect x="260" y="100" width="180" height="46" rx="6" fill="#ffffff" stroke="#cbd5e1" stroke-width="1"/>
  <text x="270" y="118" class="diagram-text" font-size="11">GitHub 저장소 구조</text>
  <text x="270" y="135" class="diagram-text-small" font-size="9">+ README 템플릿</text>

  <rect x="260" y="156" width="180" height="46" rx="6" fill="#ffffff" stroke="#cbd5e1" stroke-width="1"/>
  <text x="270" y="174" class="diagram-text" font-size="11">검증 계획서 템플릿</text>
  <text x="270" y="191" class="diagram-text-small" font-size="9">DUT 기능 + 커버리지 목표</text>

  <rect x="260" y="212" width="180" height="46" rx="6" fill="#ffffff" stroke="#cbd5e1" stroke-width="1"/>
  <text x="270" y="230" class="diagram-text" font-size="11">커버리지 결과 요약</text>
  <text x="270" y="247" class="diagram-text-small" font-size="9">숫자로 증명하기</text>

  <!-- Category 3: 이력서/자소서 -->
  <rect x="470" y="60" width="210" height="260" class="diagram-box-purple" filter="url(#shadow)"/>
  <rect x="470" y="60" width="210" height="28" rx="10" ry="10" fill="#7c3aed" stroke="#7c3aed"/>
  <rect x="470" y="80" width="210" height="4" fill="#7c3aed"/>
  <text x="575" y="80" text-anchor="middle" class="diagram-text-white" font-size="12" font-weight="bold">이력서 / 자소서</text>

  <rect x="485" y="100" width="180" height="46" rx="6" fill="#ffffff" stroke="#cbd5e1" stroke-width="1"/>
  <text x="495" y="118" class="diagram-text" font-size="11">필수 키워드 목록</text>
  <text x="495" y="135" class="diagram-text-small" font-size="9">UVM, SV, Coverage, VIP ...</text>

  <rect x="485" y="156" width="180" height="46" rx="6" fill="#ffffff" stroke="#cbd5e1" stroke-width="1"/>
  <text x="495" y="174" class="diagram-text" font-size="11">성과 표현 공식</text>
  <text x="495" y="191" class="diagram-text-small" font-size="9">동사 + 대상 + 수치/결과</text>

  <rect x="485" y="212" width="180" height="46" rx="6" fill="#ffffff" stroke="#cbd5e1" stroke-width="1"/>
  <text x="495" y="230" class="diagram-text" font-size="11">STAR 기법 가이드</text>
  <text x="495" y="247" class="diagram-text-small" font-size="9">Situation → Task → Action → Result</text>

  <!-- Bottom summary -->
  <text x="350" y="310" text-anchor="middle" class="diagram-text" font-size="12" font-weight="600">Ch.15 완료 = 취업 준비 완료!</text>
</svg>
</div><h3 id="15-7-4-전체-책-마무리-ch-1-15-학습-로드맵">15.7.4 전체 책 마무리 — Ch.1~15 학습 로드맵</h3>
<p>축하합니다! 15개 챕터를 모두 마쳤습니다. 여기까지 온 여러분의 여정을 되돌아봅시다:</p>

<div class="svg-diagram">
<svg viewBox="0 0 840 460" xmlns="http://www.w3.org/2000/svg" style="max-width:840px;width:100%">
  
  <style>
    .diagram-box { fill: #ffffff; stroke: #334155; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-accent { fill: #eff6ff; stroke: #2563eb; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-highlight { fill: #fef3c7; stroke: #f59e0b; stroke-width: 2.5; rx: 10; ry: 10; }
    .diagram-box-dark { fill: #1e293b; stroke: #1e293b; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-run { fill: #fef3c7; stroke: #f59e0b; stroke-width: 3; rx: 10; ry: 10; }
    .diagram-box-green { fill: #ecfdf5; stroke: #10b981; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-purple { fill: #f5f3ff; stroke: #7c3aed; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-red { fill: #fef2f2; stroke: #ef4444; stroke-width: 2; rx: 10; ry: 10; }
    .diagram-box-gray { fill: #f8fafc; stroke: #94a3b8; stroke-width: 1.5; rx: 8; ry: 8; }
    .diagram-text { font-family: 'Noto Sans KR', sans-serif; fill: #1e293b; }
    .diagram-text-white { font-family: 'Noto Sans KR', sans-serif; fill: #ffffff; }
    .diagram-text-accent { font-family: 'Noto Sans KR', sans-serif; fill: #2563eb; }
    .diagram-text-small { font-family: 'Noto Sans KR', sans-serif; fill: #64748b; font-size: 12px; }
    .diagram-text-code { font-family: 'Fira Code', 'JetBrains Mono', monospace; fill: #1e293b; }
    .diagram-arrow { fill: none; stroke: #64748b; stroke-width: 1.5; }
    .diagram-arrow-accent { fill: none; stroke: #2563eb; stroke-width: 1.5; }
    .diagram-line { stroke: #cbd5e1; stroke-width: 1.5; stroke-dasharray: 6,3; }
  </style>
  <defs>
    <marker id="arrowhead" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#64748b" />
    </marker>
    <marker id="arrowhead-accent" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#2563eb" />
    </marker>
    <marker id="arrowhead-dark" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#1e293b" />
    </marker>
    <marker id="arrowhead-orange" markerWidth="8" markerHeight="5.6" refX="7" refY="2.8" orient="auto">
      <polygon points="0 0, 8 2.8, 0 5.6" fill="#f59e0b" />
    </marker>
    <filter id="shadow" x="-5%" y="-5%" width="115%" height="115%">
      <feDropShadow dx="0" dy="2" stdDeviation="3" flood-color="#000" flood-opacity="0.1"/>
    </filter>
  </defs>

  <!-- Title -->
  <text x="420" y="24" text-anchor="middle" class="diagram-text" font-size="16" font-weight="bold">Ch.1~15 전체 학습 로드맵</text>

  <!-- Part 1 label -->
  <rect x="10" y="44" width="820" height="108" rx="12" fill="#eff6ff" stroke="#2563eb" stroke-width="2"/>
  <text x="25" y="65" class="diagram-text-accent" font-size="13" font-weight="bold">Part 1: 시작하기</text>

  <!-- Ch.1~5 boxes (all 140px wide, 160px pitch) -->
  <rect x="25" y="76" width="140" height="64" class="diagram-box-accent" filter="url(#shadow)"/>
  <text x="95" y="100" text-anchor="middle" class="diagram-text" font-size="12" font-weight="bold">Ch.1</text>
  <text x="95" y="116" text-anchor="middle" class="diagram-text-small" font-size="10">UVM 소개</text>
  <line x1="165" y1="108" x2="185" y2="108" class="diagram-arrow" marker-end="url(#arrowhead)"/>

  <rect x="185" y="76" width="140" height="64" class="diagram-box-accent" filter="url(#shadow)"/>
  <text x="255" y="100" text-anchor="middle" class="diagram-text" font-size="12" font-weight="bold">Ch.2</text>
  <text x="255" y="116" text-anchor="middle" class="diagram-text-small" font-size="10">환경 설정</text>
  <line x1="325" y1="108" x2="345" y2="108" class="diagram-arrow" marker-end="url(#arrowhead)"/>

  <rect x="345" y="76" width="140" height="64" class="diagram-box-accent" filter="url(#shadow)"/>
  <text x="415" y="100" text-anchor="middle" class="diagram-text" font-size="12" font-weight="bold">Ch.3</text>
  <text x="415" y="116" text-anchor="middle" class="diagram-text-small" font-size="10">SystemVerilog</text>
  <line x1="485" y1="108" x2="505" y2="108" class="diagram-arrow" marker-end="url(#arrowhead)"/>

  <rect x="505" y="76" width="140" height="64" class="diagram-box-accent" filter="url(#shadow)"/>
  <text x="575" y="100" text-anchor="middle" class="diagram-text" font-size="12" font-weight="bold">Ch.4</text>
  <text x="575" y="116" text-anchor="middle" class="diagram-text-small" font-size="10">기본 컴포넌트</text>
  <line x1="645" y1="108" x2="665" y2="108" class="diagram-arrow" marker-end="url(#arrowhead)"/>

  <rect x="665" y="76" width="140" height="64" class="diagram-box-accent" filter="url(#shadow)"/>
  <text x="735" y="100" text-anchor="middle" class="diagram-text" font-size="12" font-weight="bold">Ch.5</text>
  <text x="735" y="116" text-anchor="middle" class="diagram-text-small" font-size="10">첫 TB 작성</text>

  <!-- Part 1→2 connector -->
  <line x1="420" y1="152" x2="420" y2="168" class="diagram-arrow" marker-end="url(#arrowhead)"/>

  <!-- Part 2 label -->
  <rect x="10" y="168" width="820" height="108" rx="12" fill="#ecfdf5" stroke="#10b981" stroke-width="2"/>
  <text x="25" y="189" class="diagram-text" font-size="13" font-weight="bold" fill="#10b981">Part 2: 깊이 파기</text>

  <!-- Ch.6~10 boxes (all 140px wide) -->
  <rect x="25" y="200" width="140" height="64" class="diagram-box-green" filter="url(#shadow)"/>
  <text x="95" y="224" text-anchor="middle" class="diagram-text" font-size="12" font-weight="bold">Ch.6</text>
  <text x="95" y="240" text-anchor="middle" class="diagram-text-small" font-size="10">시퀀스 &amp; 시퀀서</text>
  <line x1="165" y1="232" x2="185" y2="232" class="diagram-arrow" marker-end="url(#arrowhead)"/>

  <rect x="185" y="200" width="140" height="64" class="diagram-box-green" filter="url(#shadow)"/>
  <text x="255" y="224" text-anchor="middle" class="diagram-text" font-size="12" font-weight="bold">Ch.7</text>
  <text x="255" y="240" text-anchor="middle" class="diagram-text-small" font-size="10">Driver &amp; Monitor</text>
  <line x1="325" y1="232" x2="345" y2="232" class="diagram-arrow" marker-end="url(#arrowhead)"/>

  <rect x="345" y="200" width="140" height="64" class="diagram-box-green" filter="url(#shadow)"/>
  <text x="415" y="224" text-anchor="middle" class="diagram-text" font-size="12" font-weight="bold">Ch.8</text>
  <text x="415" y="240" text-anchor="middle" class="diagram-text-small" font-size="10">Scoreboard</text>
  <line x1="485" y1="232" x2="505" y2="232" class="diagram-arrow" marker-end="url(#arrowhead)"/>

  <rect x="505" y="200" width="140" height="64" class="diagram-box-green" filter="url(#shadow)"/>
  <text x="575" y="224" text-anchor="middle" class="diagram-text" font-size="12" font-weight="bold">Ch.9</text>
  <text x="575" y="240" text-anchor="middle" class="diagram-text-small" font-size="10">테스트 시나리오</text>
  <line x1="645" y1="232" x2="665" y2="232" class="diagram-arrow" marker-end="url(#arrowhead)"/>

  <rect x="665" y="200" width="140" height="64" class="diagram-box-green" filter="url(#shadow)"/>
  <text x="735" y="224" text-anchor="middle" class="diagram-text" font-size="12" font-weight="bold">Ch.10</text>
  <text x="735" y="240" text-anchor="middle" class="diagram-text-small" font-size="10">디버깅 기법</text>

  <!-- Part 2→3 connector -->
  <line x1="420" y1="276" x2="420" y2="292" class="diagram-arrow" marker-end="url(#arrowhead)"/>

  <!-- Part 3 label -->
  <rect x="10" y="292" width="820" height="128" rx="12" fill="#f5f3ff" stroke="#7c3aed" stroke-width="2"/>
  <text x="25" y="313" font-family="'Noto Sans KR',sans-serif" fill="#7c3aed" font-size="13" font-weight="bold">Part 3: 완성하기</text>

  <!-- Ch.11~14 boxes (all 140px wide) -->
  <rect x="25" y="324" width="140" height="64" class="diagram-box-purple" filter="url(#shadow)"/>
  <text x="95" y="348" text-anchor="middle" class="diagram-text" font-size="12" font-weight="bold">Ch.11</text>
  <text x="95" y="364" text-anchor="middle" class="diagram-text-small" font-size="10">인터페이스 &amp; BFM</text>
  <line x1="165" y1="356" x2="185" y2="356" class="diagram-arrow" marker-end="url(#arrowhead)"/>

  <rect x="185" y="324" width="140" height="64" class="diagram-box-purple" filter="url(#shadow)"/>
  <text x="255" y="348" text-anchor="middle" class="diagram-text" font-size="12" font-weight="bold">Ch.12</text>
  <text x="255" y="364" text-anchor="middle" class="diagram-text-small" font-size="10">RAL</text>
  <line x1="325" y1="356" x2="345" y2="356" class="diagram-arrow" marker-end="url(#arrowhead)"/>

  <rect x="345" y="324" width="140" height="64" class="diagram-box-purple" filter="url(#shadow)"/>
  <text x="415" y="348" text-anchor="middle" class="diagram-text" font-size="12" font-weight="bold">Ch.13</text>
  <text x="415" y="364" text-anchor="middle" class="diagram-text-small" font-size="10">고급 시퀀스</text>
  <line x1="485" y1="356" x2="505" y2="356" class="diagram-arrow" marker-end="url(#arrowhead)"/>

  <rect x="505" y="324" width="140" height="64" class="diagram-box-purple" filter="url(#shadow)"/>
  <text x="575" y="348" text-anchor="middle" class="diagram-text" font-size="12" font-weight="bold">Ch.14</text>
  <text x="575" y="364" text-anchor="middle" class="diagram-text-small" font-size="10">검증 자동화</text>
  <line x1="645" y1="356" x2="665" y2="356" class="diagram-arrow-accent" marker-end="url(#arrowhead-accent)" stroke-width="2"/>

  <!-- Ch.15 highlighted (same width 140px) -->
  <rect x="665" y="320" width="140" height="72" class="diagram-box-highlight" filter="url(#shadow)"/>
  <text x="735" y="346" text-anchor="middle" class="diagram-text" font-size="12" font-weight="bold">Ch.15</text>
  <text x="735" y="362" text-anchor="middle" class="diagram-text" font-size="10">면접 &amp;</text>
  <text x="735" y="376" text-anchor="middle" class="diagram-text" font-size="10">포트폴리오</text>
  <text x="735" y="408" text-anchor="middle" class="diagram-text-small" font-size="11" font-weight="600" fill="#f59e0b">지금 여기!</text>

  <!-- Bottom message -->
  <text x="420" y="448" text-anchor="middle" class="diagram-text" font-size="12" font-weight="600" fill="#1e293b">15개 챕터 완주 — 팹리스 검증 엔지니어 준비 완료!</text>
</svg>
</div><p><strong>Part 1에서 배운 것 — &quot;기초 체력 만들기&quot;</strong>: UVM이 무엇인지 이해하고(Ch.1), 개발 환경을 설정하고(Ch.2), SystemVerilog 핵심 문법을 익히고(Ch.3), UVM 기본 컴포넌트의 동작 원리를 배우고(Ch.4), 처음으로 완전한 테스트벤치를 만들었습니다(Ch.5).</p>
<p><strong>Part 2에서 배운 것 — &quot;기술 하나하나 깊이 파기&quot;</strong>: Sequence로 테스트 시나리오를 설계하고(Ch.6), Driver와 Monitor로 DUT와 소통하고(Ch.7), Scoreboard로 자동 비교하고(Ch.8), Constrained Random으로 다양한 테스트를 작성하고(Ch.9), 디버깅 기법으로 문제를 해결하는 능력을 갖추었습니다(Ch.10).</p>
<p><strong>Part 3에서 배운 것 — &quot;실무 수준으로 완성하기&quot;</strong>: APB 에이전트를 구축하고(Ch.11), RAL로 레지스터를 추상화하고(Ch.12), Virtual Sequence로 복잡한 시나리오를 조율하고(Ch.13), Coverage와 Assertion으로 검증 완전성을 확보하고(Ch.14), 이 모든 것을 면접과 포트폴리오에 담는 방법을 배웠습니다(Ch.15).</p>
<p><strong>이 책을 완독한 여러분은:</strong></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> UVM 테스트벤치를 처음부터 구축할 수 있습니다</li>
<li><input checked="" disabled="" type="checkbox"> 커버리지 기반 검증 방법론을 이해하고 적용할 수 있습니다</li>
<li><input checked="" disabled="" type="checkbox"> 면접에서 UVM 질문에 자신 있게 답할 수 있습니다</li>
<li><input checked="" disabled="" type="checkbox"> GitHub 포트폴리오로 역량을 증명할 수 있습니다</li>
<li><input checked="" disabled="" type="checkbox"> 팹리스 검증 엔지니어로 첫 걸음을 내딛을 준비가 되었습니다</li>
</ul>
<blockquote>
<p>이 책의 목표는 &quot;초보자도 따라하면 팹리스 검증 엔지니어로 취업할 수 있는 실전 UVM 교재&quot;였습니다. 15개 챕터를 통해 그 여정을 함께 했습니다. 이제 남은 것은 <strong>실행</strong>입니다. 포트폴리오를 GitHub에 올리고, 이력서를 준비하고, 면접에 도전하세요. 여러분은 이미 충분히 준비되어 있습니다.</p>
</blockquote>

    <nav class="chapter-nav"><a href="chapter-14-final.html" class="nav-prev">
      <span class="nav-label">이전 챕터</span>
      <span class="nav-title">Ch.14 실전 프로젝트</span>
    </a><div></div></nav>
  </div>

  <footer class="book-footer">
    <p>팹리스 검증 엔지니어가 되기 위한 UVM 완전정복</p>
    <p>Published by UVM Book Publisher Agent</p>
  </footer>

  <!-- Back to Top Button -->
  <button class="back-to-top" id="backToTop" onclick="window.scrollTo({top:0,behavior:'smooth'})">↑</button>

  <script>
    // Reading progress bar
    window.addEventListener('scroll', () => {
      const h = document.documentElement;
      const pct = (h.scrollTop / (h.scrollHeight - h.clientHeight)) * 100;
      document.getElementById('progressBar').style.width = pct + '%';
      document.getElementById('backToTop').classList.toggle('visible', h.scrollTop > 400);
    });

    // Language labels for code blocks
    document.querySelectorAll('pre').forEach(pre => {
      const code = pre.querySelector('code');
      if (code) {
        const cls = code.className || '';
        const m = cls.match(/language-(\w+)/);
        if (m) {
          const map = {
            systemverilog:'SystemVerilog', sv:'SystemVerilog', verilog:'Verilog',
            bash:'Bash', shell:'Shell', tcl:'TCL', makefile:'Makefile',
            python:'Python', javascript:'JavaScript', text:'Output'
          };
          pre.setAttribute('data-lang', map[m[1]] || m[1]);
        }
      }
    });

    // Smart labels for plain code blocks
    document.querySelectorAll('pre code:not([class*="language-"])').forEach(code => {
      const pre = code.parentElement;
      if (!pre.getAttribute('data-lang')) {
        const t = code.textContent || '';
        if (t.includes('UVM_INFO') || t.includes('UVM_WARNING')) {
          pre.setAttribute('data-lang', 'Simulation Output');
        } else if (t.includes('[채용') || t.includes('필수 자격')) {
          pre.setAttribute('data-lang', '');
        } else if (t.includes('Step') || t.includes('패널') || t.includes('편집기')) {
          pre.setAttribute('data-lang', 'Setup Guide');
        } else {
          pre.setAttribute('data-lang', 'Info');
        }
      }
    });

    // Smooth scroll for TOC links
    document.querySelectorAll('.toc a').forEach(a => {
      a.addEventListener('click', e => {
        e.preventDefault();
        const id = a.getAttribute('href').slice(1);
        const target = document.getElementById(id);
        if (target) target.scrollIntoView({ behavior: 'smooth', block: 'start' });
      });
    });
  </script>
</body>
</html>